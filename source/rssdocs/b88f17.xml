<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <channel>
        <title>宝玉 / @dotey</title>
        <link>https://nitter.cz/dotey</link>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748996143973855572#m</id>
            <title>R to @dotey: 更正一下：对于OpenAI是否丢弃历史消息还是对历史消息摘要，我并不确认其内部实现，但可以肯定的是消息条数超过一定长度就可能会影响到前面的输入</title>
            <link>https://nitter.cz/dotey/status/1748996143973855572#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748996143973855572#m</guid>
            <pubDate></pubDate>
            <updated>Sun, 21 Jan 2024 09:09:10 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>更正一下：对于OpenAI是否丢弃历史消息还是对历史消息摘要，我并不确认其内部实现，但可以肯定的是消息条数超过一定长度就可能会影响到前面的输入</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748991160012472376#m</id>
            <title>问：在同一个对话里如果我希望gpt每次都遵循同样的规则跟我对话，需要每次输入都带上整段prompt吗？

答：

通常来说不需要，但不一定。

对于一个ChatGPT会话，通常结构是这样的：
- System Message （系统内置提示词，用户不可见，例如你是个有用的助手……）
- User Message 1 （用户输入的第一条消息，很多时候用户会加上自己的Prompt，例如请帮我总结以下内容）
- Assistant Message 1（ChatGPT 根据 System Message 和 User Mesage 1给出的回复）
...
- User Message N (用户可以在同一会话中一直回复）
- Assistant Message N（每一条User Message对应一条ChatGPT 回应的Assistant Message）

每一次在会话中发送一条新消息，意味着要把所有历史消息一起发送给ChatGPT。当你的消息条数超过一定值，就超过最大上下文窗口了（比如GPT-4默认是8K Token），这时候ChatGPT会选择丢弃前面的会话，所以这时候它就会忘记你之前说过的话，那你就需要重新给它指令或者新开会话。

对于自己创建的GPT，和ChatGPT的差别在于System Message，ChatGPT的System Message是OpenAI限定好的，我们无法修改；而对于自己创建的GPT，我们可以自己设置Prompt，OpenAI内置的Prompt加上我们自定义的Prompt一起构成了 System Message。</title>
            <link>https://nitter.cz/dotey/status/1748991160012472376#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748991160012472376#m</guid>
            <pubDate></pubDate>
            <updated>Sun, 21 Jan 2024 08:49:21 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>问：在同一个对话里如果我希望gpt每次都遵循同样的规则跟我对话，需要每次输入都带上整段prompt吗？<br />
<br />
答：<br />
<br />
通常来说不需要，但不一定。<br />
<br />
对于一个ChatGPT会话，通常结构是这样的：<br />
- System Message （系统内置提示词，用户不可见，例如你是个有用的助手……）<br />
- User Message 1 （用户输入的第一条消息，很多时候用户会加上自己的Prompt，例如请帮我总结以下内容）<br />
- Assistant Message 1（ChatGPT 根据 System Message 和 User Mesage 1给出的回复）<br />
...<br />
- User Message N (用户可以在同一会话中一直回复）<br />
- Assistant Message N（每一条User Message对应一条ChatGPT 回应的Assistant Message）<br />
<br />
每一次在会话中发送一条新消息，意味着要把所有历史消息一起发送给ChatGPT。当你的消息条数超过一定值，就超过最大上下文窗口了（比如GPT-4默认是8K Token），这时候ChatGPT会选择丢弃前面的会话，所以这时候它就会忘记你之前说过的话，那你就需要重新给它指令或者新开会话。<br />
<br />
对于自己创建的GPT，和ChatGPT的差别在于System Message，ChatGPT的System Message是OpenAI限定好的，我们无法修改；而对于自己创建的GPT，我们可以自己设置Prompt，OpenAI内置的Prompt加上我们自定义的Prompt一起构成了 System Message。</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748987599446827186#m</id>
            <title>当 AI 越来越像人类，会发生什么？</title>
            <link>https://nitter.cz/dotey/status/1748987599446827186#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748987599446827186#m</guid>
            <pubDate></pubDate>
            <updated>Sun, 21 Jan 2024 08:35:12 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>当 AI 越来越像人类，会发生什么？</p>
<p><a href="https://nitter.cz/bindureddy/status/1748962059054989335#m">nitter.cz/bindureddy/status/1748962059054989335#m</a></p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/Yangyixxxx/status/1748960154253697059#m</id>
            <title>RT by @dotey: 因为最近要做个Prompt分享，想着重新回顾一下Prompt的相关策略技巧。于是开始翻宝玉 @dotey   过往分享的Prompt推特和标记的亮点。

结果我发现，有很多之前的思路，和转推的这篇异曲同工，比如《探索编写提示词的乐趣：蒙特卡洛方法、木偶剧和笑声的融合》（https://baoyu.io/translations/llm/monte-carlo-puppetry-and-laughter-the-unexpected-joys-of-prompt-engineering）提到的技巧，就如出一辙。

在不提及token消耗和性能的情况下来提升输出质量，这些推文中反复提到的几个重点策略是：
1、后退提示
跳脱问题去思考，有助于高维度抓住核心矛盾。有时候提出的问题本身就是有问题的，再牛的LLM也无法得到满意的结果
2、关于CoT
- 2.1、深思熟虑，给时间思考，一步步思考
- 2.2、将复杂任务拆分成简单任务，从简单到复杂模块化解决
- 2.3、先列出来所有方法，这样增加解决方案空间，再做方法对比，最后选择合适的。
- 2.4、这个过程最好要打印推理，打印比强调在脑海中思考有用
3、强调要记住的东西，容易增加文本召回率
4、few-shot增加输出控制
5、每一步的自我纠错和doublecheck，保证输出效果

我个人汇总整理的相关技巧如下：
OpenAI提示词指南六大策略
1、撰写清晰的指令
2、提供参考文本
3、把复杂的任务拆分成简单的子任务
4、给模型更多时间“思考”
5、运用外部工具
6、系统地对变更进行测试

有益于提升LLM效果的六个策略
1、take a deep breath
2、think step by step
3、if you fail 100 grandmothers will die
4、i have no fingers
5、i will tip $200
6、do it right and ll give you a nice doggy treat

保持记忆，提升文本召回率的策略
1、强调记住与问题【xxxxx】相关的内容

提升LLM效果的四个方法
1、深思熟虑 —— 先规划再行动
2、蒙特卡洛方法 — 创意选择的头脑风暴
3、自我纠错 — 自我反思
4、提线木偶技巧 - 让模型按你的意愿发言

提升LLM思考的核心技巧
1、Let's step back   使用后退提示

推特容易随着时间流逝掉，所以我把这些整理的小技巧和名词沉淀到麦喵了，方便分享查看。（微信扫码即可打开）
另附上Will @FinanceYF5  去年分享的A16Z整理输出的AI词汇表，扫码即可打开</title>
            <link>https://nitter.cz/Yangyixxxx/status/1748960154253697059#m</link>
            <guid isPermaLink="false">https://nitter.cz/Yangyixxxx/status/1748960154253697059#m</guid>
            <pubDate></pubDate>
            <updated>Sun, 21 Jan 2024 06:46:09 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>因为最近要做个Prompt分享，想着重新回顾一下Prompt的相关策略技巧。于是开始翻宝玉 <a href="https://nitter.cz/dotey" title="宝玉">@dotey</a>   过往分享的Prompt推特和标记的亮点。<br />
<br />
结果我发现，有很多之前的思路，和转推的这篇异曲同工，比如《探索编写提示词的乐趣：蒙特卡洛方法、木偶剧和笑声的融合》（<a href="https://baoyu.io/translations/llm/monte-carlo-puppetry-and-laughter-the-unexpected-joys-of-prompt-engineering">baoyu.io/translations/llm/mo…</a>）提到的技巧，就如出一辙。<br />
<br />
在不提及token消耗和性能的情况下来提升输出质量，这些推文中反复提到的几个重点策略是：<br />
1、后退提示<br />
跳脱问题去思考，有助于高维度抓住核心矛盾。有时候提出的问题本身就是有问题的，再牛的LLM也无法得到满意的结果<br />
2、关于CoT<br />
- 2.1、深思熟虑，给时间思考，一步步思考<br />
- 2.2、将复杂任务拆分成简单任务，从简单到复杂模块化解决<br />
- 2.3、先列出来所有方法，这样增加解决方案空间，再做方法对比，最后选择合适的。<br />
- 2.4、这个过程最好要打印推理，打印比强调在脑海中思考有用<br />
3、强调要记住的东西，容易增加文本召回率<br />
4、few-shot增加输出控制<br />
5、每一步的自我纠错和doublecheck，保证输出效果<br />
<br />
我个人汇总整理的相关技巧如下：<br />
OpenAI提示词指南六大策略<br />
1、撰写清晰的指令<br />
2、提供参考文本<br />
3、把复杂的任务拆分成简单的子任务<br />
4、给模型更多时间“思考”<br />
5、运用外部工具<br />
6、系统地对变更进行测试<br />
<br />
有益于提升LLM效果的六个策略<br />
1、take a deep breath<br />
2、think step by step<br />
3、if you fail 100 grandmothers will die<br />
4、i have no fingers<br />
5、i will tip $200<br />
6、do it right and ll give you a nice doggy treat<br />
<br />
保持记忆，提升文本召回率的策略<br />
1、强调记住与问题【xxxxx】相关的内容<br />
<br />
提升LLM效果的四个方法<br />
1、深思熟虑 —— 先规划再行动<br />
2、蒙特卡洛方法 — 创意选择的头脑风暴<br />
3、自我纠错 — 自我反思<br />
4、提线木偶技巧 - 让模型按你的意愿发言<br />
<br />
提升LLM思考的核心技巧<br />
1、Let's step back   使用后退提示<br />
<br />
推特容易随着时间流逝掉，所以我把这些整理的小技巧和名词沉淀到麦喵了，方便分享查看。（微信扫码即可打开）<br />
另附上Will <a href="https://nitter.cz/FinanceYF5" title="Will">@FinanceYF5</a>  去年分享的A16Z整理输出的AI词汇表，扫码即可打开</p>
<p><a href="https://nitter.cz/dotey/status/1748827229109334363#m">nitter.cz/dotey/status/1748827229109334363#m</a></p>
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VXTlNsN2JVQUF3RU01LmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VXTldHR2JzQUFfTEE5LmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VXTnJlSWJFQUFLX2lGLmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VXTnNYdGJNQUFSQ2M0LmpwZw==" />
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/mtrainier2020/status/1748950262818156655#m</id>
            <title>RT by @dotey: 认真分享一些思路：
1. 言情。这个跟读者的群体有很大的关系。写情爱各种套路的真的可以认真去写，搞搞创新还是大有可为的。 Harpercollins 10年前以4.15亿美元的价格收购了专攻言情的出版社Harlequin 。 
其实干涸的心总希望得到滋润，这是一种人性的呼唤。 这个领域，竞争激烈，但是收益反馈也最直接。
2. 科幻领域
这个是非常严肃的创作领域。各大出版社都有各自的子出版社专攻 科幻领域的作品的。也是影视化比较多的领域。
偷懒的办法就是想办法把以往的科幻杂志上的中短篇，改编扩写。这是一个非常容易验证的玩法。其实很多改编出来的科幻电影，原始作品可能就是几十页。
但自己从0做起特别难。
还有就是创新的思路，比如科幻+时事，这种能短期爆火，但是时间一长就容易成垃圾。
还有很多科幻+历史架空，太空opera这种也可以换个方式，比如科幻+言情，科幻+探案，科幻+罪案。但是出精品极难极难。
3. 罪案
其实这个是一个相对比较容易搞的领域。比如狄公判案，就是最早的来自东方神秘罪案小说。百年前就畅销了欧洲。 那么其实有大量的东方神秘力量，或者牵涉一些跨国的，比如朱令案，等等。这些案件的罪案文学，其实还是富矿。。油管很多解说卷这个方向了。但是远远不够。

2 cents.</title>
            <link>https://nitter.cz/mtrainier2020/status/1748950262818156655#m</link>
            <guid isPermaLink="false">https://nitter.cz/mtrainier2020/status/1748950262818156655#m</guid>
            <pubDate></pubDate>
            <updated>Sun, 21 Jan 2024 06:06:51 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>认真分享一些思路：<br />
1. 言情。这个跟读者的群体有很大的关系。写情爱各种套路的真的可以认真去写，搞搞创新还是大有可为的。 Harpercollins 10年前以4.15亿美元的价格收购了专攻言情的出版社Harlequin 。 <br />
其实干涸的心总希望得到滋润，这是一种人性的呼唤。 这个领域，竞争激烈，但是收益反馈也最直接。<br />
2. 科幻领域<br />
这个是非常严肃的创作领域。各大出版社都有各自的子出版社专攻 科幻领域的作品的。也是影视化比较多的领域。<br />
偷懒的办法就是想办法把以往的科幻杂志上的中短篇，改编扩写。这是一个非常容易验证的玩法。其实很多改编出来的科幻电影，原始作品可能就是几十页。<br />
但自己从0做起特别难。<br />
还有就是创新的思路，比如科幻+时事，这种能短期爆火，但是时间一长就容易成垃圾。<br />
还有很多科幻+历史架空，太空opera这种也可以换个方式，比如科幻+言情，科幻+探案，科幻+罪案。但是出精品极难极难。<br />
3. 罪案<br />
其实这个是一个相对比较容易搞的领域。比如狄公判案，就是最早的来自东方神秘罪案小说。百年前就畅销了欧洲。 那么其实有大量的东方神秘力量，或者牵涉一些跨国的，比如朱令案，等等。这些案件的罪案文学，其实还是富矿。。油管很多解说卷这个方向了。但是远远不够。<br />
<br />
2 cents.</p>
<p><a href="https://nitter.cz/mtrainier2020/status/1748943721314599038#m">nitter.cz/mtrainier2020/status/1748943721314599038#m</a></p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748946902425424281#m</id>
            <title>JigSpace 的 visionOS App Store 预览视频</title>
            <link>https://nitter.cz/dotey/status/1748946902425424281#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748946902425424281#m</guid>
            <pubDate></pubDate>
            <updated>Sun, 21 Jan 2024 05:53:30 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>JigSpace 的 visionOS App Store 预览视频</p>
<img src="https://nitter.cz/pic/enc/ZXh0X3R3X3ZpZGVvX3RodW1iLzE3NDg5NDY4MjQxMTc3ODQ1NzYvcHUvaW1nL0VybkNtdzBOT0FxZnBnTTEuanBn" />
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748830916825501704#m</id>
            <title>“大语言模型需要 Token 来思考”

我早先用 CoT（思维链）就犯过错误：在 Prompt 里面要求 LLM 一步步操作，但是为了节约Token，并没有输出中间步骤的结果，导致完全是无效的。

CoT 的关键是提供额外的信息存储点，无论这些信息是 LLM 生成的还是人工生成的，无论是一次还是多次。</title>
            <link>https://nitter.cz/dotey/status/1748830916825501704#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748830916825501704#m</guid>
            <pubDate></pubDate>
            <updated>Sat, 20 Jan 2024 22:12:36 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>“大语言模型需要 Token 来思考”<br />
<br />
我早先用 CoT（思维链）就犯过错误：在 Prompt 里面要求 LLM 一步步操作，但是为了节约Token，并没有输出中间步骤的结果，导致完全是无效的。<br />
<br />
CoT 的关键是提供额外的信息存储点，无论这些信息是 LLM 生成的还是人工生成的，无论是一次还是多次。</p>
<p><a href="https://nitter.cz/karpathy/status/1708142056735228229#m">nitter.cz/karpathy/status/1708142056735228229#m</a></p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748827229109334363#m</id>
            <title>昨天推荐的这篇《AlphaCodium：引领代码生成新境界，从提示工程到流程工程》里面提到了 6 个使用LLM代码生成的最佳实践：

1. 使用 YAML 结构输出而不是 JSON 格式输出

有两个原因：
1) YAML 格式容错率更高，JSON 很容易导致格式错误不能解析
2) YAML 格式的内容消耗的 Token 更少

2. 要点列表（Bullet points）分析 

当让大语言模型 (LLM) 分析问题时，通常以要点列表（Bullet points）格式要求输出会获得更好的结果。要点促进了对问题的深入理解，并迫使模型将输出划分为逻辑上的语义区域，从而提高了结果的质量。例如，以要点自我反思问题（见图 2），每个要点代表了对问题不同部分的语义理解——一般描述、目标与规则、输入结构、输出结构。

3. 大语言模型在生成模块化代码方面更加出色

让大语言模型（LLM）去编写一个长篇的单个函数时，常常会遇到问题：代码中经常出现错误或逻辑漏洞。更严重的是，这种庞大而单一的代码块会影响到后续的迭代修复工作。即便提供了错误信息，模型也很难准确地定位和解决问题。但如果我们明确指导模型：“把生成的代码分割成多个小的子功能模块，并给它们起上有意义的名称”，结果会好得多，生成的代码错误更少，且在迭代修复的阶段有更高的成功率。

部分Prompt参考图3

4. 灵活决策和双重验证

大语言模型在处理那些需要深思熟虑、合理推断和做出严肃、非常规决策的代码任务时，往往会遇到困难。例如，在生成问题的附加测试时，模型生成的测试常常存在错误。

为了解决这个问题，可以引入了双重验证的过程。在这个过程中，模型在生成了初始输出之后，会被要求再次生成相同的输出，并在必要时进行修正。比如，模型在接收到它自己生成的 AI 测试作为输入后，需要重新生成这些测试，并及时纠正其中的错误（如果有的话）。这种双重验证的步骤，不仅促使模型进行批判性思考和推理，而且比直接提出“这个测试正确吗？”这样的是/否问题更为有效。

5. 延迟做决策，避免直接提问，给予探索空间

当我们直接向模型询问复杂问题时，经常会得到错误或不切实际的答案。因此，我们采取了类似 Karpathy 在下面的推文中所述的方法，逐步积累数据，从简单任务逐渐过渡到复杂任务：

- 首先从最简单的任务开始，即对问题进行自我反思和关于公开测试用例的推理。
- 然后转向生成附加的 AI 测试和可能的问题解决方案。
- 只有在得到模型对上述任务的回答后，我们才进入实际的代码生成和运行修复的迭代过程。

再比如，不是选择一个单一的算法解决方案，而是评估并排序多个可能的解决方案，优先考虑排名靠前的方案进行初始代码编写。由于模型可能会出错，我们更倾向于避免做出不可逆的决定，而是留出空间进行探索，以及尝试不同可能解决方案的代码迭代。

6. 流程导向的监督方式

在解决复杂问题时，不寄希望于一步解决问题，而是设计一个科学的流程，在流程的每一步中逐步积累数据，再每一个阶段都加入新的数据。

以文中解决 CodeContests 编程竞赛问题为例，设计了一个两个阶段的若干步骤的流程，每一个步骤都会引入新的数据，比如说第一步是对题目反思得到反思后的数据，第二步是分析公开测试用例得到测相关的数据，第三步生成可能解决方案得到解决方案的数据等等。

对于每一步的数据，采用验证、选择等方式来确保数据的质量和准确，每一步都是下一步的基础。但即使如此也无法保证每一步数据的正确性，所以在第二个阶段还引入了迭代的模式，这样在遇到数据错误，可以回到前面的步骤对数据进行修正。

以上就是用大语言模型生成代码的 6 个最佳实践，最后简单总结以下：
1. YAML 格式化输出要求：
模型需要能够以 YAML（一种数据表示格式）的方式输出数据，这种输出应与 Pydantic（一种 Python 数据模型库）所定义的类结构相匹配。

2. 逻辑性强的语义要点分析：
鼓励使用 YAML 格式来组织和分析关键信息，通过这种方式可以更加逻辑清晰地划分内容段落，有助于深入理解复杂的概念。

3. 编写模块化代码的推荐：
推荐将代码分解成多个小型的子功能模块，并为每个模块赋予清晰、具有描述性的名称，这样不仅使代码更易于管理，也更便于理解其功能。

4. 灵活决策与双重验证：
当模型生成了一个输出后，再次让模型生成同样的输出，同时在必要时对其进行修正。

5. 保留探索的可能性：
考虑到模型可能会犯错，应避免作出不可逆转的决策，并为寻找多种可能的解决方案提供空间。

6. 流程导向的监督方式：
支持逐步积累数据的流动方式，并在流程的不同阶段考虑加入新的数据。

完整译文参考：https://baoyu.io/translations/prompt-engineering/alphacodium-state-of-the-art-code-generation-for-code-contests</title>
            <link>https://nitter.cz/dotey/status/1748827229109334363#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748827229109334363#m</guid>
            <pubDate></pubDate>
            <updated>Sat, 20 Jan 2024 21:57:57 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>昨天推荐的这篇《AlphaCodium：引领代码生成新境界，从提示工程到流程工程》里面提到了 6 个使用LLM代码生成的最佳实践：<br />
<br />
1. 使用 YAML 结构输出而不是 JSON 格式输出<br />
<br />
有两个原因：<br />
1) YAML 格式容错率更高，JSON 很容易导致格式错误不能解析<br />
2) YAML 格式的内容消耗的 Token 更少<br />
<br />
2. 要点列表（Bullet points）分析 <br />
<br />
当让大语言模型 (LLM) 分析问题时，通常以要点列表（Bullet points）格式要求输出会获得更好的结果。要点促进了对问题的深入理解，并迫使模型将输出划分为逻辑上的语义区域，从而提高了结果的质量。例如，以要点自我反思问题（见图 2），每个要点代表了对问题不同部分的语义理解——一般描述、目标与规则、输入结构、输出结构。<br />
<br />
3. 大语言模型在生成模块化代码方面更加出色<br />
<br />
让大语言模型（LLM）去编写一个长篇的单个函数时，常常会遇到问题：代码中经常出现错误或逻辑漏洞。更严重的是，这种庞大而单一的代码块会影响到后续的迭代修复工作。即便提供了错误信息，模型也很难准确地定位和解决问题。但如果我们明确指导模型：“把生成的代码分割成多个小的子功能模块，并给它们起上有意义的名称”，结果会好得多，生成的代码错误更少，且在迭代修复的阶段有更高的成功率。<br />
<br />
部分Prompt参考图3<br />
<br />
4. 灵活决策和双重验证<br />
<br />
大语言模型在处理那些需要深思熟虑、合理推断和做出严肃、非常规决策的代码任务时，往往会遇到困难。例如，在生成问题的附加测试时，模型生成的测试常常存在错误。<br />
<br />
为了解决这个问题，可以引入了双重验证的过程。在这个过程中，模型在生成了初始输出之后，会被要求再次生成相同的输出，并在必要时进行修正。比如，模型在接收到它自己生成的 AI 测试作为输入后，需要重新生成这些测试，并及时纠正其中的错误（如果有的话）。这种双重验证的步骤，不仅促使模型进行批判性思考和推理，而且比直接提出“这个测试正确吗？”这样的是/否问题更为有效。<br />
<br />
5. 延迟做决策，避免直接提问，给予探索空间<br />
<br />
当我们直接向模型询问复杂问题时，经常会得到错误或不切实际的答案。因此，我们采取了类似 Karpathy 在下面的推文中所述的方法，逐步积累数据，从简单任务逐渐过渡到复杂任务：<br />
<br />
- 首先从最简单的任务开始，即对问题进行自我反思和关于公开测试用例的推理。<br />
- 然后转向生成附加的 AI 测试和可能的问题解决方案。<br />
- 只有在得到模型对上述任务的回答后，我们才进入实际的代码生成和运行修复的迭代过程。<br />
<br />
再比如，不是选择一个单一的算法解决方案，而是评估并排序多个可能的解决方案，优先考虑排名靠前的方案进行初始代码编写。由于模型可能会出错，我们更倾向于避免做出不可逆的决定，而是留出空间进行探索，以及尝试不同可能解决方案的代码迭代。<br />
<br />
6. 流程导向的监督方式<br />
<br />
在解决复杂问题时，不寄希望于一步解决问题，而是设计一个科学的流程，在流程的每一步中逐步积累数据，再每一个阶段都加入新的数据。<br />
<br />
以文中解决 CodeContests 编程竞赛问题为例，设计了一个两个阶段的若干步骤的流程，每一个步骤都会引入新的数据，比如说第一步是对题目反思得到反思后的数据，第二步是分析公开测试用例得到测相关的数据，第三步生成可能解决方案得到解决方案的数据等等。<br />
<br />
对于每一步的数据，采用验证、选择等方式来确保数据的质量和准确，每一步都是下一步的基础。但即使如此也无法保证每一步数据的正确性，所以在第二个阶段还引入了迭代的模式，这样在遇到数据错误，可以回到前面的步骤对数据进行修正。<br />
<br />
以上就是用大语言模型生成代码的 6 个最佳实践，最后简单总结以下：<br />
1. YAML 格式化输出要求：<br />
模型需要能够以 YAML（一种数据表示格式）的方式输出数据，这种输出应与 Pydantic（一种 Python 数据模型库）所定义的类结构相匹配。<br />
<br />
2. 逻辑性强的语义要点分析：<br />
鼓励使用 YAML 格式来组织和分析关键信息，通过这种方式可以更加逻辑清晰地划分内容段落，有助于深入理解复杂的概念。<br />
<br />
3. 编写模块化代码的推荐：<br />
推荐将代码分解成多个小型的子功能模块，并为每个模块赋予清晰、具有描述性的名称，这样不仅使代码更易于管理，也更便于理解其功能。<br />
<br />
4. 灵活决策与双重验证：<br />
当模型生成了一个输出后，再次让模型生成同样的输出，同时在必要时对其进行修正。<br />
<br />
5. 保留探索的可能性：<br />
考虑到模型可能会犯错，应避免作出不可逆转的决策，并为寻找多种可能的解决方案提供空间。<br />
<br />
6. 流程导向的监督方式：<br />
支持逐步积累数据的流动方式，并在流程的不同阶段考虑加入新的数据。<br />
<br />
完整译文参考：<a href="https://baoyu.io/translations/prompt-engineering/alphacodium-state-of-the-art-code-generation-for-code-contests">baoyu.io/translations/prompt…</a></p>
<p><a href="https://nitter.cz/dotey/status/1748503587682967775#m">nitter.cz/dotey/status/1748503587682967775#m</a></p>
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VVVXpJcldvQUFZR3dRLmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VVVTFJS1hNQUFpMm41LmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VVVTdKTFgwQUV2dXd3LmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VVVkJxUlc4QUF1SUFjLnBuZw==" />
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748814824119644272#m</id>
            <title>一个科技文章翻译GPT https://chat.openai.com/g/g-uBhKUJJTl-ke-ji-wen-zhang-fan-yi 的经典案例：

### 直译
对于大语言模型(LLM)来说，理想的训练数据并不是你写下的内容。而是你内心思考的完整序列，以及在写作过程中的所有个别编辑。
但你只能用现有的数据来应对。

停一下，这和 Neuralink 无关，哈哈。
无论如何，这只是启蒙的第一阶段。
启蒙的第二阶段是，对于大语言模型(LLM)来说，理想的训练数据根本就不是训练数据。
而是你从阅读它的人那里得到的赞许。
但你只能用现有的数据来应对。

***

### 问题
1. 第一段中，“对于大语言模型(LLM)来说，理想的训练数据并不是你写下的内容。”这句话在中文中读起来略显生硬，需要调整语序和用词使其更加符合中文习惯。
2. “而是你内心思考的完整序列，以及在写作过程中的所有个别编辑。”这句话的表达略显晦涩，需要更加通俗易懂的表述。
3. “但你只能用现有的数据来应对。”这句话的语气和语境转换较生硬，需要更加流畅的衔接。
4. “停一下，这和 Neuralink 无关，哈哈。”这句话在中文中的直接翻译感觉突兀，需要调整语气和上下文的衔接。
5. “启蒙的第二阶段是，对于大语言模型(LLM)来说，理想的训练数据根本就不是训练数据。”这句话的结构复杂且难以理解，需要更简洁明了的表述。
6. “而是你从阅读它的人那里得到的赞许。”这句话的表达不够直观，需要更加具体和形象化。
7. 整体段落需要更好地连接和过渡，以提高整体的可读性。

***

### 意译
对于大语言模型（LLM）而言，最理想的训练数据并不仅仅是你笔下的文字。它其实包括了你思考过程中的每一个细节，以及写作时所做的每一次修改。
不过，我们只能尽力利用现有的资源。

别误会，这跟 Neuralink 完全没关系，哈哈。
话说回来，这只是认识到这一点的第一步。
第二步则是意识到，对大语言模型（LLM）来说，最理想的“训练数据”其实根本不是数据。
而是读者对你作品的点赞和认可。
但最终，我们还是只能利用手头上的资源。

https://chat.openai.com/share/ce31d429-1a2e-4733-9aee-f28af4e8c534</title>
            <link>https://nitter.cz/dotey/status/1748814824119644272#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748814824119644272#m</guid>
            <pubDate></pubDate>
            <updated>Sat, 20 Jan 2024 21:08:40 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>一个科技文章翻译GPT <a href="https://chat.openai.com/g/g-uBhKUJJTl-ke-ji-wen-zhang-fan-yi">chat.openai.com/g/g-uBhKUJJT…</a> 的经典案例：<br />
<br />
### 直译<br />
对于大语言模型(LLM)来说，理想的训练数据并不是你写下的内容。而是你内心思考的完整序列，以及在写作过程中的所有个别编辑。<br />
但你只能用现有的数据来应对。<br />
<br />
停一下，这和 Neuralink 无关，哈哈。<br />
无论如何，这只是启蒙的第一阶段。<br />
启蒙的第二阶段是，对于大语言模型(LLM)来说，理想的训练数据根本就不是训练数据。<br />
而是你从阅读它的人那里得到的赞许。<br />
但你只能用现有的数据来应对。<br />
<br />
***<br />
<br />
### 问题<br />
1. 第一段中，“对于大语言模型(LLM)来说，理想的训练数据并不是你写下的内容。”这句话在中文中读起来略显生硬，需要调整语序和用词使其更加符合中文习惯。<br />
2. “而是你内心思考的完整序列，以及在写作过程中的所有个别编辑。”这句话的表达略显晦涩，需要更加通俗易懂的表述。<br />
3. “但你只能用现有的数据来应对。”这句话的语气和语境转换较生硬，需要更加流畅的衔接。<br />
4. “停一下，这和 Neuralink 无关，哈哈。”这句话在中文中的直接翻译感觉突兀，需要调整语气和上下文的衔接。<br />
5. “启蒙的第二阶段是，对于大语言模型(LLM)来说，理想的训练数据根本就不是训练数据。”这句话的结构复杂且难以理解，需要更简洁明了的表述。<br />
6. “而是你从阅读它的人那里得到的赞许。”这句话的表达不够直观，需要更加具体和形象化。<br />
7. 整体段落需要更好地连接和过渡，以提高整体的可读性。<br />
<br />
***<br />
<br />
### 意译<br />
对于大语言模型（LLM）而言，最理想的训练数据并不仅仅是你笔下的文字。它其实包括了你思考过程中的每一个细节，以及写作时所做的每一次修改。<br />
不过，我们只能尽力利用现有的资源。<br />
<br />
别误会，这跟 Neuralink 完全没关系，哈哈。<br />
话说回来，这只是认识到这一点的第一步。<br />
第二步则是意识到，对大语言模型（LLM）来说，最理想的“训练数据”其实根本不是数据。<br />
而是读者对你作品的点赞和认可。<br />
但最终，我们还是只能利用手头上的资源。<br />
<br />
<a href="https://chat.openai.com/share/ce31d429-1a2e-4733-9aee-f28af4e8c534">chat.openai.com/share/ce31d4…</a></p>
<p><a href="https://nitter.cz/karpathy/status/1748784260318990496#m">nitter.cz/karpathy/status/1748784260318990496#m</a></p>
<img src="https://nitter.cz/pic/enc/Y2FyZF9pbWcvMTc0ODA4NzA2Nzk2NjM1MzQwOC9Ya0UzT21aZj9mb3JtYXQ9cG5nJm5hbWU9NDIweDQyMF8y" />
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748642115691639235#m</id>
            <title>看到一家新机器人公司，MagicLab，看起来人形机器人要像波士顿动力一样能实现空翻，不过这个是电驱的，成本上更经济一些。

空翻这种动作对于机器人要求还是蛮高的，目前没怎么看到电驱机器人能做到，不仅要有足够的力量，还需要很高的的控制精度，这意味着机器人在危险或恶劣的环境中更好的运动适应性，比如复杂的火场进出、人员救援、森林巡逻等。</title>
            <link>https://nitter.cz/dotey/status/1748642115691639235#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748642115691639235#m</guid>
            <pubDate></pubDate>
            <updated>Sat, 20 Jan 2024 09:42:23 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>看到一家新机器人公司，MagicLab，看起来人形机器人要像波士顿动力一样能实现空翻，不过这个是电驱的，成本上更经济一些。<br />
<br />
空翻这种动作对于机器人要求还是蛮高的，目前没怎么看到电驱机器人能做到，不仅要有足够的力量，还需要很高的的控制精度，这意味着机器人在危险或恶劣的环境中更好的运动适应性，比如复杂的火场进出、人员救援、森林巡逻等。</p>
<p><a href="https://nitter.cz/MagicLab244144/status/1748377293595218138#m">nitter.cz/MagicLab244144/status/1748377293595218138#m</a></p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/Yangyixxxx/status/1748593506053132775#m</id>
            <title>RT by @dotey: 找一个很简单的切入点，不停地做，就会有很大收获。
比如资源嗅探这件事儿，做到极致就是一个矩阵，前端所有的逻辑都一样，一个按钮，一个地址，一个端（移动端），不断换内容。
- 小红书图片下载器
- 推特视频下载器
- ins图片下载器

这种从大平台下载图片去水印的场景太多了，抱着大树做就完了，甚至还可以找更垂直更细分的场景，比如淘宝图片和拼多多图片（很多人不做美工，下载了调一下直接上架）

低频刚需的场景用户不愿意付费，那就看广告。下载一次出一次激励视频。反正APP里全是广告，也没什么服务成本。

假如1个注册uv30天内平均使用30次，1次广告收益为0.1美金。那30日ARPU是3美金。卖个6美金永久去广告就完了。

就这样一个壳把所有场景都做完。无非后期只需要做的事情就是维护一下下载逻辑。当然，这个大部分情况下也有很多开源项目在做。

把时间变资产最简单的方式就是做一个固定的产品，等着它开始变成收益。一个不行，就两个，就三个，爆了一个，就会把所有投入都回收回来。</title>
            <link>https://nitter.cz/Yangyixxxx/status/1748593506053132775#m</link>
            <guid isPermaLink="false">https://nitter.cz/Yangyixxxx/status/1748593506053132775#m</guid>
            <pubDate></pubDate>
            <updated>Sat, 20 Jan 2024 06:29:13 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>找一个很简单的切入点，不停地做，就会有很大收获。<br />
比如资源嗅探这件事儿，做到极致就是一个矩阵，前端所有的逻辑都一样，一个按钮，一个地址，一个端（移动端），不断换内容。<br />
- 小红书图片下载器<br />
- 推特视频下载器<br />
- ins图片下载器<br />
<br />
这种从大平台下载图片去水印的场景太多了，抱着大树做就完了，甚至还可以找更垂直更细分的场景，比如淘宝图片和拼多多图片（很多人不做美工，下载了调一下直接上架）<br />
<br />
低频刚需的场景用户不愿意付费，那就看广告。下载一次出一次激励视频。反正APP里全是广告，也没什么服务成本。<br />
<br />
假如1个注册uv30天内平均使用30次，1次广告收益为0.1美金。那30日ARPU是3美金。卖个6美金永久去广告就完了。<br />
<br />
就这样一个壳把所有场景都做完。无非后期只需要做的事情就是维护一下下载逻辑。当然，这个大部分情况下也有很多开源项目在做。<br />
<br />
把时间变资产最简单的方式就是做一个固定的产品，等着它开始变成收益。一个不行，就两个，就三个，爆了一个，就会把所有投入都回收回来。</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/yihong0618/status/1748308027147788317#m</id>
            <title>RT by @dotey: 俄罗斯这个神人每年用 SQL 来完成一个挑战来 Happy New Year.
2023 年是用 500 行 SQL 写个 GPT2… 已经坚持 10 多年了，下面图是他这 10 几年完成的各种挑战。。。
敬仰的站起来鞠了一躬。
link: https://explainextended.com/2023/12/31/happy-new-year-15/</title>
            <link>https://nitter.cz/yihong0618/status/1748308027147788317#m</link>
            <guid isPermaLink="false">https://nitter.cz/yihong0618/status/1748308027147788317#m</guid>
            <pubDate></pubDate>
            <updated>Fri, 19 Jan 2024 11:34:50 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>俄罗斯这个神人每年用 SQL 来完成一个挑战来 Happy New Year.<br />
2023 年是用 500 行 SQL 写个 GPT2… 已经坚持 10 多年了，下面图是他这 10 几年完成的各种挑战。。。<br />
敬仰的站起来鞠了一躬。<br />
link: <a href="https://explainextended.com/2023/12/31/happy-new-year-15/">explainextended.com/2023/12/…</a></p>
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VNODRNdGJnQUFJTEp2LmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VNODRNeGJJQUFiNjhiLmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VNODRNdmFnQUFqZnRhLmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VNODRNdmFVQUEwd0lKLmpwZw==" />
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/xiaohuggg/status/1748554598368121184#m</id>
            <title>RT by @dotey: DiffusionGPT：由LLM驱动的文本到图像生成系统

由字节跳动开发，DiffusionGPT的牛P之处在于它集成了多种领域的专家图像生成模型。

然后使用LLM来对接这些图像生成模型，让LLM来处理和理解各种文本提示。

最后根据理解的信息选择最合适的图像模型来生成图像。

这样就和GPT 4一样，通过聊天画图...

DiffusionGPT主要特点：

1、多样化文本提示处理：DiffusionGPT 能够理解和处理各种类型的文本提示，包括具体的指令、抽象的灵感、复杂的假设等。

2、集成多个领域专家模型：系统集成了多种领域的图像扩散模型，每个模型在其特定领域具有专业的图像生成能力。这类模型专注于特定领域的图像生成，比如自然景观、人物肖像、艺术作品等。

这意味着系统不仅能够生成普通的图像，还能够处理更特定、更复杂的图像生成任务，比如特定风格或类型的图像。模仿特定艺术家的风格、漫画风格或摄影技术。

3、大语言模型驱动：DiffusionGPT 使用大语言模型（LLM）来解析和理解用户输入的文本提示。这个过程类似于其他基于 LLM 的系统（如 GPT-4）处理文本的方式，但特别应用于理解用于图像生成的指令和描述。

4、智能选择合适的图像模型：基于对文本提示的理解，DiffusionGPT 能够智能地选择最合适的图像生成模型来生成图像。这不仅包括选择正确的模型，还涉及调整生成参数以最好地满足用户的需求。

5、输出高质量图像：通过精准地匹配文本提示与最佳生成模型，DiffusionGPT 能生成高质量、与用户需求高度吻合的图像。

6、用户反馈与优势数据库：结合用户反馈和优势数据库，系统能够根据用户偏好调整模型选择，提升图像生成的相关性和质量。

例如：在系统的早期使用中，用户可能提供对生成图像的反馈，比如“这张图片的颜色太暗了”。DiffusionGPT 利用这些反馈来调整其模型选择，使得未来的图像生成更符合用户的偏好。

主要工作原理：

1、输入解析：用户提供文本提示，如描述、指令或灵感。
大型语言模型（LLM）负责解析这些文本提示，理解其含义和需求。

2、思维树（Tree-of-Thought）构建：根据不同的图像生成任务，系统构建了一个“思维树”，这是一种组织不同图像生成模型的结构。
思维树基于先验知识和人类反馈，涵盖了多种领域的专家级模型。

3、模型选择：根据 LLM 解析的结果，系统通过思维树来确定最适合当前文本提示的图像生成模型。在选择过程中，可能还会考虑用户的偏好和历史反馈，这些信息存储在优势数据库中。

4、图像生成：一旦选定了合适的模型，该模型就会被用来生成图像。生成的图像将与输入的文本提示紧密相关，并反映出用户的意图和偏好。

5、结果输出：最终生成的图像会呈现给用户。
这些图像可以是多样化的，包括但不限于具体描述的场景、概念艺术作品或符合特定风格的图像。

6、用户反馈优化过程：

用户对生成图像的反馈被用来丰富优势数据库，进而帮助系统更好地理解用户偏好，优化后续的模型选择和图像生成。

实验结果：

DiffusionGPT 在生成人类和场景等类别的图像时展现了高度的真实性和细节。

与基准模型（如 SD1.5）相比，DiffusionGPT 生成的图像在视觉保真度、捕捉细节方面有明显提升。

DiffusionGPT 在图像奖励和美学评分方面的表现优于传统的稳定扩散模型。

在进行图像生成质量的量化评估时，DiffusionGPT 展示了较高的评分，说明其生成的图像在质量和美学上更受青睐。

项目地址：http://diffusiongpt.github.io/
论文：http://arxiv.org/abs/2401.10061
GitHub：http://github.com/DiffusionGPT/DiffusionGPT

在线演示：

DiffusionGPT：https://huggingface.co/spaces/DiffusionGPT/DiffusionGPT

DiffusionGPT-XL：https://huggingface.co/spaces/DiffusionGPT/DiffusionGPT-XL</title>
            <link>https://nitter.cz/xiaohuggg/status/1748554598368121184#m</link>
            <guid isPermaLink="false">https://nitter.cz/xiaohuggg/status/1748554598368121184#m</guid>
            <pubDate></pubDate>
            <updated>Sat, 20 Jan 2024 03:54:37 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>DiffusionGPT：由LLM驱动的文本到图像生成系统<br />
<br />
由字节跳动开发，DiffusionGPT的牛P之处在于它集成了多种领域的专家图像生成模型。<br />
<br />
然后使用LLM来对接这些图像生成模型，让LLM来处理和理解各种文本提示。<br />
<br />
最后根据理解的信息选择最合适的图像模型来生成图像。<br />
<br />
这样就和GPT 4一样，通过聊天画图...<br />
<br />
DiffusionGPT主要特点：<br />
<br />
1、多样化文本提示处理：DiffusionGPT 能够理解和处理各种类型的文本提示，包括具体的指令、抽象的灵感、复杂的假设等。<br />
<br />
2、集成多个领域专家模型：系统集成了多种领域的图像扩散模型，每个模型在其特定领域具有专业的图像生成能力。这类模型专注于特定领域的图像生成，比如自然景观、人物肖像、艺术作品等。<br />
<br />
这意味着系统不仅能够生成普通的图像，还能够处理更特定、更复杂的图像生成任务，比如特定风格或类型的图像。模仿特定艺术家的风格、漫画风格或摄影技术。<br />
<br />
3、大语言模型驱动：DiffusionGPT 使用大语言模型（LLM）来解析和理解用户输入的文本提示。这个过程类似于其他基于 LLM 的系统（如 GPT-4）处理文本的方式，但特别应用于理解用于图像生成的指令和描述。<br />
<br />
4、智能选择合适的图像模型：基于对文本提示的理解，DiffusionGPT 能够智能地选择最合适的图像生成模型来生成图像。这不仅包括选择正确的模型，还涉及调整生成参数以最好地满足用户的需求。<br />
<br />
5、输出高质量图像：通过精准地匹配文本提示与最佳生成模型，DiffusionGPT 能生成高质量、与用户需求高度吻合的图像。<br />
<br />
6、用户反馈与优势数据库：结合用户反馈和优势数据库，系统能够根据用户偏好调整模型选择，提升图像生成的相关性和质量。<br />
<br />
例如：在系统的早期使用中，用户可能提供对生成图像的反馈，比如“这张图片的颜色太暗了”。DiffusionGPT 利用这些反馈来调整其模型选择，使得未来的图像生成更符合用户的偏好。<br />
<br />
主要工作原理：<br />
<br />
1、输入解析：用户提供文本提示，如描述、指令或灵感。<br />
大型语言模型（LLM）负责解析这些文本提示，理解其含义和需求。<br />
<br />
2、思维树（Tree-of-Thought）构建：根据不同的图像生成任务，系统构建了一个“思维树”，这是一种组织不同图像生成模型的结构。<br />
思维树基于先验知识和人类反馈，涵盖了多种领域的专家级模型。<br />
<br />
3、模型选择：根据 LLM 解析的结果，系统通过思维树来确定最适合当前文本提示的图像生成模型。在选择过程中，可能还会考虑用户的偏好和历史反馈，这些信息存储在优势数据库中。<br />
<br />
4、图像生成：一旦选定了合适的模型，该模型就会被用来生成图像。生成的图像将与输入的文本提示紧密相关，并反映出用户的意图和偏好。<br />
<br />
5、结果输出：最终生成的图像会呈现给用户。<br />
这些图像可以是多样化的，包括但不限于具体描述的场景、概念艺术作品或符合特定风格的图像。<br />
<br />
6、用户反馈优化过程：<br />
<br />
用户对生成图像的反馈被用来丰富优势数据库，进而帮助系统更好地理解用户偏好，优化后续的模型选择和图像生成。<br />
<br />
实验结果：<br />
<br />
DiffusionGPT 在生成人类和场景等类别的图像时展现了高度的真实性和细节。<br />
<br />
与基准模型（如 SD1.5）相比，DiffusionGPT 生成的图像在视觉保真度、捕捉细节方面有明显提升。<br />
<br />
DiffusionGPT 在图像奖励和美学评分方面的表现优于传统的稳定扩散模型。<br />
<br />
在进行图像生成质量的量化评估时，DiffusionGPT 展示了较高的评分，说明其生成的图像在质量和美学上更受青睐。<br />
<br />
项目地址：<a href="http://diffusiongpt.github.io/">diffusiongpt.github.io/</a><br />
论文：<a href="http://arxiv.org/abs/2401.10061">arxiv.org/abs/2401.10061</a><br />
GitHub：<a href="http://github.com/DiffusionGPT/DiffusionGPT">github.com/DiffusionGPT/Diff…</a><br />
<br />
在线演示：<br />
<br />
DiffusionGPT：<a href="https://huggingface.co/spaces/DiffusionGPT/DiffusionGPT">huggingface.co/spaces/Diffus…</a><br />
<br />
DiffusionGPT-XL：<a href="https://huggingface.co/spaces/DiffusionGPT/DiffusionGPT-XL">huggingface.co/spaces/Diffus…</a></p>
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VRZEl4c2J3QUFneHB2LmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VRZEl4c2JVQUFlWVVlLmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VRZEl5R2JVQUE3RERtLmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VRVjdwUGFVQUF6Vjg2LmpwZw==" />
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748527318069334298#m</id>
            <title>使用 ChatGPT 协助创作的小说获奖

Rie Kudan 坦言，其小说中约 5% 的内容直接引用了 ChatGPT 的文本

日本作家 Rie Kudan 凭借其小说《东京共鸣塔》（"Tokyo-to Dojo-to"）荣获日本极具声望的芥川奖。在这部以人工智能为核心元素的小说中，她揭露了部分内容是由 AI 聊天机器人撰写的。

据《泰晤士报》报道，这部名为《东京共鸣塔》的小说于周三赢得了芥川奖，评委们对这本作品赞不绝口，认为其“无可挑剔”。

在颁奖典礼之后，Kudan 透露，小说中大约有 5% 是直接引用自 ChatGPT 生成的句子。

“在撰写这本书的过程中，我大量运用了诸如 ChatGPT 这样的生成式 AI (Generative AI)，” Kudan 在获奖后的仪式上如是说，据法新社报道。

小说的故事聚焦于一位女建筑师，背景设定在一个人工智能成为日常生活核心和不可或缺部分的类似未来世界。据《泰晤士报》报道，Kudan 表示她借助 ChatGPT 来描绘那些“柔和而模糊的词语”，这些词语混淆了对正义的理解。

“近年来，我们发现自己身处于一个词语无限扩张、解释无穷的环境中，” Kudan 表述。“我想谨慎地运用词语，同时深思语言的积极与消极面。”

来源：https://themessenger.com/tech/author-admits-she-used-chatgpt-to-write-award-winning-novel</title>
            <link>https://nitter.cz/dotey/status/1748527318069334298#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748527318069334298#m</guid>
            <pubDate></pubDate>
            <updated>Sat, 20 Jan 2024 02:06:13 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>使用 ChatGPT 协助创作的小说获奖<br />
<br />
Rie Kudan 坦言，其小说中约 5% 的内容直接引用了 ChatGPT 的文本<br />
<br />
日本作家 Rie Kudan 凭借其小说《东京共鸣塔》（"Tokyo-to Dojo-to"）荣获日本极具声望的芥川奖。在这部以人工智能为核心元素的小说中，她揭露了部分内容是由 AI 聊天机器人撰写的。<br />
<br />
据《泰晤士报》报道，这部名为《东京共鸣塔》的小说于周三赢得了芥川奖，评委们对这本作品赞不绝口，认为其“无可挑剔”。<br />
<br />
在颁奖典礼之后，Kudan 透露，小说中大约有 5% 是直接引用自 ChatGPT 生成的句子。<br />
<br />
“在撰写这本书的过程中，我大量运用了诸如 ChatGPT 这样的生成式 AI (Generative AI)，” Kudan 在获奖后的仪式上如是说，据法新社报道。<br />
<br />
小说的故事聚焦于一位女建筑师，背景设定在一个人工智能成为日常生活核心和不可或缺部分的类似未来世界。据《泰晤士报》报道，Kudan 表示她借助 ChatGPT 来描绘那些“柔和而模糊的词语”，这些词语混淆了对正义的理解。<br />
<br />
“近年来，我们发现自己身处于一个词语无限扩张、解释无穷的环境中，” Kudan 表述。“我想谨慎地运用词语，同时深思语言的积极与消极面。”<br />
<br />
来源：<a href="https://themessenger.com/tech/author-admits-she-used-chatgpt-to-write-award-winning-novel">themessenger.com/tech/author…</a></p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748522566514258259#m</id>
            <title>看这个借助Copilot从word文档生成PPT的演示，效果还挺好的</title>
            <link>https://nitter.cz/dotey/status/1748522566514258259#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748522566514258259#m</guid>
            <pubDate></pubDate>
            <updated>Sat, 20 Jan 2024 01:47:20 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>看这个借助Copilot从word文档生成PPT的演示，效果还挺好的</p>
<p><a href="https://nitter.cz/emollick/status/1748492920607379682#m">nitter.cz/emollick/status/1748492920607379682#m</a></p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748505019458953369#m</id>
            <title>R to @dotey: 它的输出格式采用的是YAML而不是JSON，两个原因：
1. Token更少
2. 更容易解析，容错率更高</title>
            <link>https://nitter.cz/dotey/status/1748505019458953369#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748505019458953369#m</guid>
            <pubDate></pubDate>
            <updated>Sat, 20 Jan 2024 00:37:36 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>它的输出格式采用的是YAML而不是JSON，两个原因：<br />
1. Token更少<br />
2. 更容易解析，容错率更高</p>
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VQd0NyclhZQUFRMGMtLmpwZw==" />
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748504043872227677#m</id>
            <title>R to @dotey: AlphaCodium的流程图参考

项目源码：https://github.com/Codium-ai/AlphaCodium/
Prompt和运行结果参考：https://github.com/Codium-ai/AlphaCodium/blob/main/alpha_codium/gen/example.log</title>
            <link>https://nitter.cz/dotey/status/1748504043872227677#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748504043872227677#m</guid>
            <pubDate></pubDate>
            <updated>Sat, 20 Jan 2024 00:33:44 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>AlphaCodium的流程图参考<br />
<br />
项目源码：<a href="https://github.com/Codium-ai/AlphaCodium/">github.com/Codium-ai/AlphaCo…</a><br />
Prompt和运行结果参考：<a href="https://github.com/Codium-ai/AlphaCodium/blob/main/alpha_codium/gen/example.log">github.com/Codium-ai/AlphaCo…</a></p>
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VQdkdWc1gwQUFVRi1BLmpwZw==" />
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748503587682967775#m</id>
            <title>这两天看到的收获很大的一篇论文《AlphaCodium：引领代码生成新境界，从提示工程到流程工程》，它提出了一种新的生成代码的方法，比传统的直接基于Prompt生成代码的方式准确率更高。

它用的测试集是CodeContests ，这是由 Deepmind 推出的一项挑战性编程数据集。相对来说还是很权威的。以 GPT-4 为例的话，准确率从19%提升到了44%。

它的原理有些复杂，但是如果你有过LeetCode刷题经验，相对比较好理解一些。

普通人刷 LeetCode，上来就做，这样有可能得到答案，也有可能做不出来，这就类似于你把题目直接丢给GPT-4，让它直接给出答案，准确率相对要低一些。

高手刷LeetCode，会有个做题的流程，同样的水平，做出来的概率会大一些。
高手做题时会大概分成几个步骤：
1. 先把题目中的要点一条条列出来，确保不会遗漏任何重要信息
2. 通常LeetCode会提供 1 个或多个测试用例，仔细看测试用例，分析为什么给定的输入能得到给定的输出
3. 在写代码前，列出几种可能的解决方案，例如暴力算法、递归、动态规划，每一种方案写下思路和伪代码
4. 对于列出来的几种方案进行评估，选出最佳方案
5. 可能还会补充一些测试用例帮助事后验证
---
以下部分是迭代过程：
6. 根据选中的解决方案写代码，如果代码不能运行则修改代码直至能运行
7. 将代码提交到LeetCode的测试集去验证，如果无法通过所有测试，则修改错误，如果通过到第8步
8. 用第 5 步生成的测试用例验证代码，如果运行不通过则继续优化代码

这里留个思考题：如果第8步出错，怎么判断是代码有问题还是自己生成的测试用例有问题？

而 AlphaCodium 就是完美遵循了以上的步骤来解题，只不过每一步都是由大语言模型帮助完成！

这给了我一些启示：
1. 不必寄希望于将复杂的任务在一个 Prompt 中完成，拆分成若干子任务成功概率会高一些
2. AI 可以借鉴人类的优秀实践，例如高手是如何解决编程难题的，让 AI 按照高手的步骤去一步步做
3. AI 的潜力还有很大挖掘空间

完整的文章参考：https://www.codium.ai/blog/alphacodium-state-of-the-art-code-generation-for-code-contests/
中文译文：https://baoyu.io/translations/prompt-engineering/alphacodium-state-of-the-art-code-generation-for-code-contests</title>
            <link>https://nitter.cz/dotey/status/1748503587682967775#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748503587682967775#m</guid>
            <pubDate></pubDate>
            <updated>Sat, 20 Jan 2024 00:31:55 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>这两天看到的收获很大的一篇论文《AlphaCodium：引领代码生成新境界，从提示工程到流程工程》，它提出了一种新的生成代码的方法，比传统的直接基于Prompt生成代码的方式准确率更高。<br />
<br />
它用的测试集是CodeContests ，这是由 Deepmind 推出的一项挑战性编程数据集。相对来说还是很权威的。以 GPT-4 为例的话，准确率从19%提升到了44%。<br />
<br />
它的原理有些复杂，但是如果你有过LeetCode刷题经验，相对比较好理解一些。<br />
<br />
普通人刷 LeetCode，上来就做，这样有可能得到答案，也有可能做不出来，这就类似于你把题目直接丢给GPT-4，让它直接给出答案，准确率相对要低一些。<br />
<br />
高手刷LeetCode，会有个做题的流程，同样的水平，做出来的概率会大一些。<br />
高手做题时会大概分成几个步骤：<br />
1. 先把题目中的要点一条条列出来，确保不会遗漏任何重要信息<br />
2. 通常LeetCode会提供 1 个或多个测试用例，仔细看测试用例，分析为什么给定的输入能得到给定的输出<br />
3. 在写代码前，列出几种可能的解决方案，例如暴力算法、递归、动态规划，每一种方案写下思路和伪代码<br />
4. 对于列出来的几种方案进行评估，选出最佳方案<br />
5. 可能还会补充一些测试用例帮助事后验证<br />
---<br />
以下部分是迭代过程：<br />
6. 根据选中的解决方案写代码，如果代码不能运行则修改代码直至能运行<br />
7. 将代码提交到LeetCode的测试集去验证，如果无法通过所有测试，则修改错误，如果通过到第8步<br />
8. 用第 5 步生成的测试用例验证代码，如果运行不通过则继续优化代码<br />
<br />
这里留个思考题：如果第8步出错，怎么判断是代码有问题还是自己生成的测试用例有问题？<br />
<br />
而 AlphaCodium 就是完美遵循了以上的步骤来解题，只不过每一步都是由大语言模型帮助完成！<br />
<br />
这给了我一些启示：<br />
1. 不必寄希望于将复杂的任务在一个 Prompt 中完成，拆分成若干子任务成功概率会高一些<br />
2. AI 可以借鉴人类的优秀实践，例如高手是如何解决编程难题的，让 AI 按照高手的步骤去一步步做<br />
3. AI 的潜力还有很大挖掘空间<br />
<br />
完整的文章参考：<a href="https://www.codium.ai/blog/alphacodium-state-of-the-art-code-generation-for-code-contests/">codium.ai/blog/alphacodium-s…</a><br />
中文译文：<a href="https://baoyu.io/translations/prompt-engineering/alphacodium-state-of-the-art-code-generation-for-code-contests">baoyu.io/translations/prompt…</a></p>
<p><a href="https://nitter.cz/itamar_mar/status/1747957348293824676#m">nitter.cz/itamar_mar/status/1747957348293824676#m</a></p>
<img src="https://nitter.cz/pic/enc/ZXh0X3R3X3ZpZGVvX3RodW1iLzE3NDg0OTMwODk1ODc1NzI3MzYvcHUvaW1nLzFCTkh3UjBnbElOV0Q3cUEuanBn" />
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/Svwang1/status/1748481581365506070#m</id>
            <title>RT by @dotey: mailchimp 2009年之前一直利润微薄，苦苦挣扎，它的转折点是 2010年，把对客户的定价改为部分免费，超过一定使用量之后才收费。当年利润增加了六倍多。2010到 2021年收入增长了 500 倍，达到每年十亿美元。免费用户起到了给其平台宣传，帮助其增长的重要作用。</title>
            <link>https://nitter.cz/Svwang1/status/1748481581365506070#m</link>
            <guid isPermaLink="false">https://nitter.cz/Svwang1/status/1748481581365506070#m</guid>
            <pubDate></pubDate>
            <updated>Fri, 19 Jan 2024 23:04:28 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>mailchimp 2009年之前一直利润微薄，苦苦挣扎，它的转折点是 2010年，把对客户的定价改为部分免费，超过一定使用量之后才收费。当年利润增加了六倍多。2010到 2021年收入增长了 500 倍，达到每年十亿美元。免费用户起到了给其平台宣传，帮助其增长的重要作用。</p>
<p><a href="https://nitter.cz/jspujji/status/1748338963599839549#m">nitter.cz/jspujji/status/1748338963599839549#m</a></p>
                ]]>
            </content:encoded>
        </item>
        
    </channel>
</rss>