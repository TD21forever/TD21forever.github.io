<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <channel>
        <title>宝玉 / @dotey</title>
        <link>https://nitter.cz/dotey</link>
        
        <item>
            <id>https://nitter.cz/AndrewBBoo/status/1749249379322724780#m</id>
            <title>RT by @dotey: 确实，优质语料的缺乏是中文大模型训练的最大门槛。我补充另外一个可能的角度，大模型在做embedding时，是将单词切分为更小的词元来进行编码的，比如常用的BPE编码。对于英文来说，空格可以作为单词的边界，且很方便基于其词根/前缀/后缀编码以及推断新词的含义；而中文是一种象形文字，很难进行这样的切分及新词的推断，也一定程度上影响了模型的训练</title>
            <link>https://nitter.cz/AndrewBBoo/status/1749249379322724780#m</link>
            <guid isPermaLink="false">https://nitter.cz/AndrewBBoo/status/1749249379322724780#m</guid>
            <pubDate></pubDate>
            <updated>Mon, 22 Jan 2024 01:55:26 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>确实，优质语料的缺乏是中文大模型训练的最大门槛。我补充另外一个可能的角度，大模型在做embedding时，是将单词切分为更小的词元来进行编码的，比如常用的BPE编码。对于英文来说，空格可以作为单词的边界，且很方便基于其词根/前缀/后缀编码以及推断新词的含义；而中文是一种象形文字，很难进行这样的切分及新词的推断，也一定程度上影响了模型的训练</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1749243458412224865#m</id>
            <title>很多人以为中文信息密度大，所以用来训练大语言模型更经济，但中文信息密度大，本身是一种有损压缩，极其依赖上下文，通常一个词有多种意义，这对于训练大语言模型来说反倒是一种障碍。

另外高质量的信息，中文的数量也确实不够多。

你认为呢？</title>
            <link>https://nitter.cz/dotey/status/1749243458412224865#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1749243458412224865#m</guid>
            <pubDate></pubDate>
            <updated>Mon, 22 Jan 2024 01:31:54 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>很多人以为中文信息密度大，所以用来训练大语言模型更经济，但中文信息密度大，本身是一种有损压缩，极其依赖上下文，通常一个词有多种意义，这对于训练大语言模型来说反倒是一种障碍。<br />
<br />
另外高质量的信息，中文的数量也确实不够多。<br />
<br />
你认为呢？</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1749222200312295535#m</id>
            <title>一代经典</title>
            <link>https://nitter.cz/dotey/status/1749222200312295535#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1749222200312295535#m</guid>
            <pubDate></pubDate>
            <updated>Mon, 22 Jan 2024 00:07:26 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>一代经典</p>
<p><a href="https://nitter.cz/UNESCO_chinese/status/1748923372921380883#m">nitter.cz/UNESCO_chinese/status/1748923372921380883#m</a></p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1749221247961960557#m</id>
            <title>阴差阳错</title>
            <link>https://nitter.cz/dotey/status/1749221247961960557#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1749221247961960557#m</guid>
            <pubDate></pubDate>
            <updated>Mon, 22 Jan 2024 00:03:39 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>阴差阳错</p>
<p><a href="https://nitter.cz/foxshuo/status/1749077744804360474#m">nitter.cz/foxshuo/status/1749077744804360474#m</a></p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/Gorden_Sun/status/1749066402789781569#m</id>
            <title>RT by @dotey: Open TTS Tracker：开源TTS大全
这个项目收集开源的TTS项目，并标注出每个TTS的信息，包括：支持哪些语言、协议、是否支持微调、在线使用地址等。大多数是英文模型，个别支持多语言和中文。
没有采集到国内开发者训练或者二创的模型。
Github：https://github.com/Vaibhavs10/open-tts-tracker</title>
            <link>https://nitter.cz/Gorden_Sun/status/1749066402789781569#m</link>
            <guid isPermaLink="false">https://nitter.cz/Gorden_Sun/status/1749066402789781569#m</guid>
            <pubDate></pubDate>
            <updated>Sun, 21 Jan 2024 13:48:21 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>Open TTS Tracker：开源TTS大全<br />
这个项目收集开源的TTS项目，并标注出每个TTS的信息，包括：支持哪些语言、协议、是否支持微调、在线使用地址等。大多数是英文模型，个别支持多语言和中文。<br />
没有采集到国内开发者训练或者二创的模型。<br />
Github：<a href="https://github.com/Vaibhavs10/open-tts-tracker">github.com/Vaibhavs10/open-t…</a></p>
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VYdWpFM2JNQUFRNmkzLmpwZw==" />
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/Yangyixxxx/status/1749007949991956555#m</id>
            <title>RT by @dotey: LLM的信息记忆交互是个非常值得研究的课题。
虽然Langchain在持续不断抽象解决这个问题，但可能还需要一定时间才能做的更好。

以下是我自己的一些认识：
1、滚动窗口，设定一个滚动窗口，LLM记的住窗口内部的内容，这种更像是一种缓存机制
2、对历史对话不断总结，比如针对Q1A1-Q2A2....做summary，但信息会有折损
3、对消息进行外部存储，通过提问和上下文做召回，将召回内容返回给LLM的对话窗口以便使用
这种工程化作业就很多了，用矢量库的，或者redis的，各种各样。多半知识库也是利用这个
4、还有很多有意思的工程，比如replika设定的mark，可以让用户主动标记某个消息，如用户的生日，构成外部优先级比较高的存储信息

目前从整体方法上讲虽然就这些，但实际上的使用要区分场景和实施细节，结果会完全不一样。

比如一条信息，到底是以实体的方式存储维护，还是单单是一个单纯的文本，亦或是构建成知识图谱三元组？这些往往要因场景和预期效果而定。对token消耗，响应时间，召回效果上做不可能三角的平衡，用到的Langchain的方法也不太一样（比如下图）

这里有一个将Langchain翻译过的中文站，之前看过一些，感觉工程上还是有非常非常多细节的。
https://www.langchain.com.cn</title>
            <link>https://nitter.cz/Yangyixxxx/status/1749007949991956555#m</link>
            <guid isPermaLink="false">https://nitter.cz/Yangyixxxx/status/1749007949991956555#m</guid>
            <pubDate></pubDate>
            <updated>Sun, 21 Jan 2024 09:56:04 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>LLM的信息记忆交互是个非常值得研究的课题。<br />
虽然Langchain在持续不断抽象解决这个问题，但可能还需要一定时间才能做的更好。<br />
<br />
以下是我自己的一些认识：<br />
1、滚动窗口，设定一个滚动窗口，LLM记的住窗口内部的内容，这种更像是一种缓存机制<br />
2、对历史对话不断总结，比如针对Q1A1-Q2A2....做summary，但信息会有折损<br />
3、对消息进行外部存储，通过提问和上下文做召回，将召回内容返回给LLM的对话窗口以便使用<br />
这种工程化作业就很多了，用矢量库的，或者redis的，各种各样。多半知识库也是利用这个<br />
4、还有很多有意思的工程，比如replika设定的mark，可以让用户主动标记某个消息，如用户的生日，构成外部优先级比较高的存储信息<br />
<br />
目前从整体方法上讲虽然就这些，但实际上的使用要区分场景和实施细节，结果会完全不一样。<br />
<br />
比如一条信息，到底是以实体的方式存储维护，还是单单是一个单纯的文本，亦或是构建成知识图谱三元组？这些往往要因场景和预期效果而定。对token消耗，响应时间，召回效果上做不可能三角的平衡，用到的Langchain的方法也不太一样（比如下图）<br />
<br />
这里有一个将Langchain翻译过的中文站，之前看过一些，感觉工程上还是有非常非常多细节的。<br />
<a href="https://www.langchain.com.cn">langchain.com.cn</a></p>
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VXM0U2WGJrQUFBZmNBLmpwZw==" />
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748997349320364122#m</id>
            <title>#AI开源项目推荐#：ML-Papers-of-the-Week

每周 AI 论文推荐！

https://github.com/dair-ai/ML-Papers-of-the-Week</title>
            <link>https://nitter.cz/dotey/status/1748997349320364122#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748997349320364122#m</guid>
            <pubDate></pubDate>
            <updated>Sun, 21 Jan 2024 09:13:57 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>#AI开源项目推荐#：ML-Papers-of-the-Week<br />
<br />
每周 AI 论文推荐！<br />
<br />
<a href="https://github.com/dair-ai/ML-Papers-of-the-Week">github.com/dair-ai/ML-Papers…</a></p>
<p><a href="https://nitter.cz/omarsar0/status/1748735510854377927#m">nitter.cz/omarsar0/status/1748735510854377927#m</a></p>
<img src="https://nitter.cz/pic/enc/Y2FyZF9pbWcvMTc0Njk2OTMwNDI5MjA4OTg1Ni81Y3FMZlNaUz9mb3JtYXQ9anBnJm5hbWU9ODAweDQxOQ==" />
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748996143973855572#m</id>
            <title>R to @dotey: 更正一下：对于OpenAI是否丢弃历史消息还是对历史消息摘要，我并不确认其内部实现，但可以肯定的是消息条数超过一定长度就可能会影响到前面的输入</title>
            <link>https://nitter.cz/dotey/status/1748996143973855572#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748996143973855572#m</guid>
            <pubDate></pubDate>
            <updated>Sun, 21 Jan 2024 09:09:10 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>更正一下：对于OpenAI是否丢弃历史消息还是对历史消息摘要，我并不确认其内部实现，但可以肯定的是消息条数超过一定长度就可能会影响到前面的输入</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748991160012472376#m</id>
            <title>问：在同一个对话里如果我希望gpt每次都遵循同样的规则跟我对话，需要每次输入都带上整段prompt吗？

答：

通常来说不需要，但不一定。

对于一个ChatGPT会话，通常结构是这样的：
- System Message （系统内置提示词，用户不可见，例如你是个有用的助手……）
- User Message 1 （用户输入的第一条消息，很多时候用户会加上自己的Prompt，例如请帮我总结以下内容）
- Assistant Message 1（ChatGPT 根据 System Message 和 User Mesage 1给出的回复）
...
- User Message N (用户可以在同一会话中一直回复）
- Assistant Message N（每一条User Message对应一条ChatGPT 回应的Assistant Message）

每一次在会话中发送一条新消息，意味着要把所有历史消息一起发送给ChatGPT。当你的消息条数超过一定值，就超过最大上下文窗口了（比如GPT-4默认是8K Token），这时候ChatGPT会选择丢弃前面的会话，所以这时候它就会忘记你之前说过的话，那你就需要重新给它指令或者新开会话。

对于自己创建的GPT，和ChatGPT的差别在于System Message，ChatGPT的System Message是OpenAI限定好的，我们无法修改；而对于自己创建的GPT，我们可以自己设置Prompt，OpenAI内置的Prompt加上我们自定义的Prompt一起构成了 System Message。</title>
            <link>https://nitter.cz/dotey/status/1748991160012472376#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748991160012472376#m</guid>
            <pubDate></pubDate>
            <updated>Sun, 21 Jan 2024 08:49:21 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>问：在同一个对话里如果我希望gpt每次都遵循同样的规则跟我对话，需要每次输入都带上整段prompt吗？<br />
<br />
答：<br />
<br />
通常来说不需要，但不一定。<br />
<br />
对于一个ChatGPT会话，通常结构是这样的：<br />
- System Message （系统内置提示词，用户不可见，例如你是个有用的助手……）<br />
- User Message 1 （用户输入的第一条消息，很多时候用户会加上自己的Prompt，例如请帮我总结以下内容）<br />
- Assistant Message 1（ChatGPT 根据 System Message 和 User Mesage 1给出的回复）<br />
...<br />
- User Message N (用户可以在同一会话中一直回复）<br />
- Assistant Message N（每一条User Message对应一条ChatGPT 回应的Assistant Message）<br />
<br />
每一次在会话中发送一条新消息，意味着要把所有历史消息一起发送给ChatGPT。当你的消息条数超过一定值，就超过最大上下文窗口了（比如GPT-4默认是8K Token），这时候ChatGPT会选择丢弃前面的会话，所以这时候它就会忘记你之前说过的话，那你就需要重新给它指令或者新开会话。<br />
<br />
对于自己创建的GPT，和ChatGPT的差别在于System Message，ChatGPT的System Message是OpenAI限定好的，我们无法修改；而对于自己创建的GPT，我们可以自己设置Prompt，OpenAI内置的Prompt加上我们自定义的Prompt一起构成了 System Message。</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748987599446827186#m</id>
            <title>当 AI 越来越像人类，会发生什么？</title>
            <link>https://nitter.cz/dotey/status/1748987599446827186#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748987599446827186#m</guid>
            <pubDate></pubDate>
            <updated>Sun, 21 Jan 2024 08:35:12 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>当 AI 越来越像人类，会发生什么？</p>
<p><a href="https://nitter.cz/bindureddy/status/1748962059054989335#m">nitter.cz/bindureddy/status/1748962059054989335#m</a></p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/Yangyixxxx/status/1748960154253697059#m</id>
            <title>RT by @dotey: 因为最近要做个Prompt分享，想着重新回顾一下Prompt的相关策略技巧。于是开始翻宝玉 @dotey   过往分享的Prompt推特和标记的亮点。

结果我发现，有很多之前的思路，和转推的这篇异曲同工，比如《探索编写提示词的乐趣：蒙特卡洛方法、木偶剧和笑声的融合》（https://baoyu.io/translations/llm/monte-carlo-puppetry-and-laughter-the-unexpected-joys-of-prompt-engineering）提到的技巧，就如出一辙。

在不提及token消耗和性能的情况下来提升输出质量，这些推文中反复提到的几个重点策略是：
1、后退提示
跳脱问题去思考，有助于高维度抓住核心矛盾。有时候提出的问题本身就是有问题的，再牛的LLM也无法得到满意的结果
2、关于CoT
- 2.1、深思熟虑，给时间思考，一步步思考
- 2.2、将复杂任务拆分成简单任务，从简单到复杂模块化解决
- 2.3、先列出来所有方法，这样增加解决方案空间，再做方法对比，最后选择合适的。
- 2.4、这个过程最好要打印推理，打印比强调在脑海中思考有用
3、强调要记住的东西，容易增加文本召回率
4、few-shot增加输出控制
5、每一步的自我纠错和doublecheck，保证输出效果

我个人汇总整理的相关技巧如下：
OpenAI提示词指南六大策略
1、撰写清晰的指令
2、提供参考文本
3、把复杂的任务拆分成简单的子任务
4、给模型更多时间“思考”
5、运用外部工具
6、系统地对变更进行测试

有益于提升LLM效果的六个策略
1、take a deep breath
2、think step by step
3、if you fail 100 grandmothers will die
4、i have no fingers
5、i will tip $200
6、do it right and ll give you a nice doggy treat

保持记忆，提升文本召回率的策略
1、强调记住与问题【xxxxx】相关的内容

提升LLM效果的四个方法
1、深思熟虑 —— 先规划再行动
2、蒙特卡洛方法 — 创意选择的头脑风暴
3、自我纠错 — 自我反思
4、提线木偶技巧 - 让模型按你的意愿发言

提升LLM思考的核心技巧
1、Let's step back   使用后退提示

推特容易随着时间流逝掉，所以我把这些整理的小技巧和名词沉淀到麦喵了，方便分享查看。（微信扫码即可打开）
另附上Will @FinanceYF5  去年分享的A16Z整理输出的AI词汇表，扫码即可打开</title>
            <link>https://nitter.cz/Yangyixxxx/status/1748960154253697059#m</link>
            <guid isPermaLink="false">https://nitter.cz/Yangyixxxx/status/1748960154253697059#m</guid>
            <pubDate></pubDate>
            <updated>Sun, 21 Jan 2024 06:46:09 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>因为最近要做个Prompt分享，想着重新回顾一下Prompt的相关策略技巧。于是开始翻宝玉 <a href="https://nitter.cz/dotey" title="宝玉">@dotey</a>   过往分享的Prompt推特和标记的亮点。<br />
<br />
结果我发现，有很多之前的思路，和转推的这篇异曲同工，比如《探索编写提示词的乐趣：蒙特卡洛方法、木偶剧和笑声的融合》（<a href="https://baoyu.io/translations/llm/monte-carlo-puppetry-and-laughter-the-unexpected-joys-of-prompt-engineering">baoyu.io/translations/llm/mo…</a>）提到的技巧，就如出一辙。<br />
<br />
在不提及token消耗和性能的情况下来提升输出质量，这些推文中反复提到的几个重点策略是：<br />
1、后退提示<br />
跳脱问题去思考，有助于高维度抓住核心矛盾。有时候提出的问题本身就是有问题的，再牛的LLM也无法得到满意的结果<br />
2、关于CoT<br />
- 2.1、深思熟虑，给时间思考，一步步思考<br />
- 2.2、将复杂任务拆分成简单任务，从简单到复杂模块化解决<br />
- 2.3、先列出来所有方法，这样增加解决方案空间，再做方法对比，最后选择合适的。<br />
- 2.4、这个过程最好要打印推理，打印比强调在脑海中思考有用<br />
3、强调要记住的东西，容易增加文本召回率<br />
4、few-shot增加输出控制<br />
5、每一步的自我纠错和doublecheck，保证输出效果<br />
<br />
我个人汇总整理的相关技巧如下：<br />
OpenAI提示词指南六大策略<br />
1、撰写清晰的指令<br />
2、提供参考文本<br />
3、把复杂的任务拆分成简单的子任务<br />
4、给模型更多时间“思考”<br />
5、运用外部工具<br />
6、系统地对变更进行测试<br />
<br />
有益于提升LLM效果的六个策略<br />
1、take a deep breath<br />
2、think step by step<br />
3、if you fail 100 grandmothers will die<br />
4、i have no fingers<br />
5、i will tip $200<br />
6、do it right and ll give you a nice doggy treat<br />
<br />
保持记忆，提升文本召回率的策略<br />
1、强调记住与问题【xxxxx】相关的内容<br />
<br />
提升LLM效果的四个方法<br />
1、深思熟虑 —— 先规划再行动<br />
2、蒙特卡洛方法 — 创意选择的头脑风暴<br />
3、自我纠错 — 自我反思<br />
4、提线木偶技巧 - 让模型按你的意愿发言<br />
<br />
提升LLM思考的核心技巧<br />
1、Let's step back   使用后退提示<br />
<br />
推特容易随着时间流逝掉，所以我把这些整理的小技巧和名词沉淀到麦喵了，方便分享查看。（微信扫码即可打开）<br />
另附上Will <a href="https://nitter.cz/FinanceYF5" title="Will">@FinanceYF5</a>  去年分享的A16Z整理输出的AI词汇表，扫码即可打开</p>
<p><a href="https://nitter.cz/dotey/status/1748827229109334363#m">nitter.cz/dotey/status/1748827229109334363#m</a></p>
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VXTlNsN2JVQUF3RU01LmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VXTldHR2JzQUFfTEE5LmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VXTnJlSWJFQUFLX2lGLmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VXTnNYdGJNQUFSQ2M0LmpwZw==" />
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/mtrainier2020/status/1748950262818156655#m</id>
            <title>RT by @dotey: 认真分享一些思路：
1. 言情。这个跟读者的群体有很大的关系。写情爱各种套路的真的可以认真去写，搞搞创新还是大有可为的。 Harpercollins 10年前以4.15亿美元的价格收购了专攻言情的出版社Harlequin 。 
其实干涸的心总希望得到滋润，这是一种人性的呼唤。 这个领域，竞争激烈，但是收益反馈也最直接。
2. 科幻领域
这个是非常严肃的创作领域。各大出版社都有各自的子出版社专攻 科幻领域的作品的。也是影视化比较多的领域。
偷懒的办法就是想办法把以往的科幻杂志上的中短篇，改编扩写。这是一个非常容易验证的玩法。其实很多改编出来的科幻电影，原始作品可能就是几十页。
但自己从0做起特别难。
还有就是创新的思路，比如科幻+时事，这种能短期爆火，但是时间一长就容易成垃圾。
还有很多科幻+历史架空，太空opera这种也可以换个方式，比如科幻+言情，科幻+探案，科幻+罪案。但是出精品极难极难。
3. 罪案
其实这个是一个相对比较容易搞的领域。比如狄公判案，就是最早的来自东方神秘罪案小说。百年前就畅销了欧洲。 那么其实有大量的东方神秘力量，或者牵涉一些跨国的，比如朱令案，等等。这些案件的罪案文学，其实还是富矿。。油管很多解说卷这个方向了。但是远远不够。

2 cents.</title>
            <link>https://nitter.cz/mtrainier2020/status/1748950262818156655#m</link>
            <guid isPermaLink="false">https://nitter.cz/mtrainier2020/status/1748950262818156655#m</guid>
            <pubDate></pubDate>
            <updated>Sun, 21 Jan 2024 06:06:51 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>认真分享一些思路：<br />
1. 言情。这个跟读者的群体有很大的关系。写情爱各种套路的真的可以认真去写，搞搞创新还是大有可为的。 Harpercollins 10年前以4.15亿美元的价格收购了专攻言情的出版社Harlequin 。 <br />
其实干涸的心总希望得到滋润，这是一种人性的呼唤。 这个领域，竞争激烈，但是收益反馈也最直接。<br />
2. 科幻领域<br />
这个是非常严肃的创作领域。各大出版社都有各自的子出版社专攻 科幻领域的作品的。也是影视化比较多的领域。<br />
偷懒的办法就是想办法把以往的科幻杂志上的中短篇，改编扩写。这是一个非常容易验证的玩法。其实很多改编出来的科幻电影，原始作品可能就是几十页。<br />
但自己从0做起特别难。<br />
还有就是创新的思路，比如科幻+时事，这种能短期爆火，但是时间一长就容易成垃圾。<br />
还有很多科幻+历史架空，太空opera这种也可以换个方式，比如科幻+言情，科幻+探案，科幻+罪案。但是出精品极难极难。<br />
3. 罪案<br />
其实这个是一个相对比较容易搞的领域。比如狄公判案，就是最早的来自东方神秘罪案小说。百年前就畅销了欧洲。 那么其实有大量的东方神秘力量，或者牵涉一些跨国的，比如朱令案，等等。这些案件的罪案文学，其实还是富矿。。油管很多解说卷这个方向了。但是远远不够。<br />
<br />
2 cents.</p>
<p><a href="https://nitter.cz/mtrainier2020/status/1748943721314599038#m">nitter.cz/mtrainier2020/status/1748943721314599038#m</a></p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748946902425424281#m</id>
            <title>JigSpace 的 visionOS App Store 预览视频</title>
            <link>https://nitter.cz/dotey/status/1748946902425424281#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748946902425424281#m</guid>
            <pubDate></pubDate>
            <updated>Sun, 21 Jan 2024 05:53:30 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>JigSpace 的 visionOS App Store 预览视频</p>
<img src="https://nitter.cz/pic/enc/ZXh0X3R3X3ZpZGVvX3RodW1iLzE3NDg5NDY4MjQxMTc3ODQ1NzYvcHUvaW1nL0VybkNtdzBOT0FxZnBnTTEuanBn" />
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748830916825501704#m</id>
            <title>“大语言模型需要 Token 来思考”

我早先用 CoT（思维链）就犯过错误：在 Prompt 里面要求 LLM 一步步操作，但是为了节约Token，并没有输出中间步骤的结果，导致完全是无效的。

CoT 的关键是提供额外的信息存储点，无论这些信息是 LLM 生成的还是人工生成的，无论是一次还是多次。</title>
            <link>https://nitter.cz/dotey/status/1748830916825501704#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748830916825501704#m</guid>
            <pubDate></pubDate>
            <updated>Sat, 20 Jan 2024 22:12:36 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>“大语言模型需要 Token 来思考”<br />
<br />
我早先用 CoT（思维链）就犯过错误：在 Prompt 里面要求 LLM 一步步操作，但是为了节约Token，并没有输出中间步骤的结果，导致完全是无效的。<br />
<br />
CoT 的关键是提供额外的信息存储点，无论这些信息是 LLM 生成的还是人工生成的，无论是一次还是多次。</p>
<p><a href="https://nitter.cz/karpathy/status/1708142056735228229#m">nitter.cz/karpathy/status/1708142056735228229#m</a></p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748827229109334363#m</id>
            <title>昨天推荐的这篇《AlphaCodium：引领代码生成新境界，从提示工程到流程工程》里面提到了 6 个使用LLM代码生成的最佳实践：

1. 使用 YAML 结构输出而不是 JSON 格式输出

有两个原因：
1) YAML 格式容错率更高，JSON 很容易导致格式错误不能解析
2) YAML 格式的内容消耗的 Token 更少

2. 要点列表（Bullet points）分析 

当让大语言模型 (LLM) 分析问题时，通常以要点列表（Bullet points）格式要求输出会获得更好的结果。要点促进了对问题的深入理解，并迫使模型将输出划分为逻辑上的语义区域，从而提高了结果的质量。例如，以要点自我反思问题（见图 2），每个要点代表了对问题不同部分的语义理解——一般描述、目标与规则、输入结构、输出结构。

3. 大语言模型在生成模块化代码方面更加出色

让大语言模型（LLM）去编写一个长篇的单个函数时，常常会遇到问题：代码中经常出现错误或逻辑漏洞。更严重的是，这种庞大而单一的代码块会影响到后续的迭代修复工作。即便提供了错误信息，模型也很难准确地定位和解决问题。但如果我们明确指导模型：“把生成的代码分割成多个小的子功能模块，并给它们起上有意义的名称”，结果会好得多，生成的代码错误更少，且在迭代修复的阶段有更高的成功率。

部分Prompt参考图3

4. 灵活决策和双重验证

大语言模型在处理那些需要深思熟虑、合理推断和做出严肃、非常规决策的代码任务时，往往会遇到困难。例如，在生成问题的附加测试时，模型生成的测试常常存在错误。

为了解决这个问题，可以引入了双重验证的过程。在这个过程中，模型在生成了初始输出之后，会被要求再次生成相同的输出，并在必要时进行修正。比如，模型在接收到它自己生成的 AI 测试作为输入后，需要重新生成这些测试，并及时纠正其中的错误（如果有的话）。这种双重验证的步骤，不仅促使模型进行批判性思考和推理，而且比直接提出“这个测试正确吗？”这样的是/否问题更为有效。

5. 延迟做决策，避免直接提问，给予探索空间

当我们直接向模型询问复杂问题时，经常会得到错误或不切实际的答案。因此，我们采取了类似 Karpathy 在下面的推文中所述的方法，逐步积累数据，从简单任务逐渐过渡到复杂任务：

- 首先从最简单的任务开始，即对问题进行自我反思和关于公开测试用例的推理。
- 然后转向生成附加的 AI 测试和可能的问题解决方案。
- 只有在得到模型对上述任务的回答后，我们才进入实际的代码生成和运行修复的迭代过程。

再比如，不是选择一个单一的算法解决方案，而是评估并排序多个可能的解决方案，优先考虑排名靠前的方案进行初始代码编写。由于模型可能会出错，我们更倾向于避免做出不可逆的决定，而是留出空间进行探索，以及尝试不同可能解决方案的代码迭代。

6. 流程导向的监督方式

在解决复杂问题时，不寄希望于一步解决问题，而是设计一个科学的流程，在流程的每一步中逐步积累数据，再每一个阶段都加入新的数据。

以文中解决 CodeContests 编程竞赛问题为例，设计了一个两个阶段的若干步骤的流程，每一个步骤都会引入新的数据，比如说第一步是对题目反思得到反思后的数据，第二步是分析公开测试用例得到测相关的数据，第三步生成可能解决方案得到解决方案的数据等等。

对于每一步的数据，采用验证、选择等方式来确保数据的质量和准确，每一步都是下一步的基础。但即使如此也无法保证每一步数据的正确性，所以在第二个阶段还引入了迭代的模式，这样在遇到数据错误，可以回到前面的步骤对数据进行修正。

以上就是用大语言模型生成代码的 6 个最佳实践，最后简单总结以下：
1. YAML 格式化输出要求：
模型需要能够以 YAML（一种数据表示格式）的方式输出数据，这种输出应与 Pydantic（一种 Python 数据模型库）所定义的类结构相匹配。

2. 逻辑性强的语义要点分析：
鼓励使用 YAML 格式来组织和分析关键信息，通过这种方式可以更加逻辑清晰地划分内容段落，有助于深入理解复杂的概念。

3. 编写模块化代码的推荐：
推荐将代码分解成多个小型的子功能模块，并为每个模块赋予清晰、具有描述性的名称，这样不仅使代码更易于管理，也更便于理解其功能。

4. 灵活决策与双重验证：
当模型生成了一个输出后，再次让模型生成同样的输出，同时在必要时对其进行修正。

5. 保留探索的可能性：
考虑到模型可能会犯错，应避免作出不可逆转的决策，并为寻找多种可能的解决方案提供空间。

6. 流程导向的监督方式：
支持逐步积累数据的流动方式，并在流程的不同阶段考虑加入新的数据。

完整译文参考：https://baoyu.io/translations/prompt-engineering/alphacodium-state-of-the-art-code-generation-for-code-contests</title>
            <link>https://nitter.cz/dotey/status/1748827229109334363#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748827229109334363#m</guid>
            <pubDate></pubDate>
            <updated>Sat, 20 Jan 2024 21:57:57 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>昨天推荐的这篇《AlphaCodium：引领代码生成新境界，从提示工程到流程工程》里面提到了 6 个使用LLM代码生成的最佳实践：<br />
<br />
1. 使用 YAML 结构输出而不是 JSON 格式输出<br />
<br />
有两个原因：<br />
1) YAML 格式容错率更高，JSON 很容易导致格式错误不能解析<br />
2) YAML 格式的内容消耗的 Token 更少<br />
<br />
2. 要点列表（Bullet points）分析 <br />
<br />
当让大语言模型 (LLM) 分析问题时，通常以要点列表（Bullet points）格式要求输出会获得更好的结果。要点促进了对问题的深入理解，并迫使模型将输出划分为逻辑上的语义区域，从而提高了结果的质量。例如，以要点自我反思问题（见图 2），每个要点代表了对问题不同部分的语义理解——一般描述、目标与规则、输入结构、输出结构。<br />
<br />
3. 大语言模型在生成模块化代码方面更加出色<br />
<br />
让大语言模型（LLM）去编写一个长篇的单个函数时，常常会遇到问题：代码中经常出现错误或逻辑漏洞。更严重的是，这种庞大而单一的代码块会影响到后续的迭代修复工作。即便提供了错误信息，模型也很难准确地定位和解决问题。但如果我们明确指导模型：“把生成的代码分割成多个小的子功能模块，并给它们起上有意义的名称”，结果会好得多，生成的代码错误更少，且在迭代修复的阶段有更高的成功率。<br />
<br />
部分Prompt参考图3<br />
<br />
4. 灵活决策和双重验证<br />
<br />
大语言模型在处理那些需要深思熟虑、合理推断和做出严肃、非常规决策的代码任务时，往往会遇到困难。例如，在生成问题的附加测试时，模型生成的测试常常存在错误。<br />
<br />
为了解决这个问题，可以引入了双重验证的过程。在这个过程中，模型在生成了初始输出之后，会被要求再次生成相同的输出，并在必要时进行修正。比如，模型在接收到它自己生成的 AI 测试作为输入后，需要重新生成这些测试，并及时纠正其中的错误（如果有的话）。这种双重验证的步骤，不仅促使模型进行批判性思考和推理，而且比直接提出“这个测试正确吗？”这样的是/否问题更为有效。<br />
<br />
5. 延迟做决策，避免直接提问，给予探索空间<br />
<br />
当我们直接向模型询问复杂问题时，经常会得到错误或不切实际的答案。因此，我们采取了类似 Karpathy 在下面的推文中所述的方法，逐步积累数据，从简单任务逐渐过渡到复杂任务：<br />
<br />
- 首先从最简单的任务开始，即对问题进行自我反思和关于公开测试用例的推理。<br />
- 然后转向生成附加的 AI 测试和可能的问题解决方案。<br />
- 只有在得到模型对上述任务的回答后，我们才进入实际的代码生成和运行修复的迭代过程。<br />
<br />
再比如，不是选择一个单一的算法解决方案，而是评估并排序多个可能的解决方案，优先考虑排名靠前的方案进行初始代码编写。由于模型可能会出错，我们更倾向于避免做出不可逆的决定，而是留出空间进行探索，以及尝试不同可能解决方案的代码迭代。<br />
<br />
6. 流程导向的监督方式<br />
<br />
在解决复杂问题时，不寄希望于一步解决问题，而是设计一个科学的流程，在流程的每一步中逐步积累数据，再每一个阶段都加入新的数据。<br />
<br />
以文中解决 CodeContests 编程竞赛问题为例，设计了一个两个阶段的若干步骤的流程，每一个步骤都会引入新的数据，比如说第一步是对题目反思得到反思后的数据，第二步是分析公开测试用例得到测相关的数据，第三步生成可能解决方案得到解决方案的数据等等。<br />
<br />
对于每一步的数据，采用验证、选择等方式来确保数据的质量和准确，每一步都是下一步的基础。但即使如此也无法保证每一步数据的正确性，所以在第二个阶段还引入了迭代的模式，这样在遇到数据错误，可以回到前面的步骤对数据进行修正。<br />
<br />
以上就是用大语言模型生成代码的 6 个最佳实践，最后简单总结以下：<br />
1. YAML 格式化输出要求：<br />
模型需要能够以 YAML（一种数据表示格式）的方式输出数据，这种输出应与 Pydantic（一种 Python 数据模型库）所定义的类结构相匹配。<br />
<br />
2. 逻辑性强的语义要点分析：<br />
鼓励使用 YAML 格式来组织和分析关键信息，通过这种方式可以更加逻辑清晰地划分内容段落，有助于深入理解复杂的概念。<br />
<br />
3. 编写模块化代码的推荐：<br />
推荐将代码分解成多个小型的子功能模块，并为每个模块赋予清晰、具有描述性的名称，这样不仅使代码更易于管理，也更便于理解其功能。<br />
<br />
4. 灵活决策与双重验证：<br />
当模型生成了一个输出后，再次让模型生成同样的输出，同时在必要时对其进行修正。<br />
<br />
5. 保留探索的可能性：<br />
考虑到模型可能会犯错，应避免作出不可逆转的决策，并为寻找多种可能的解决方案提供空间。<br />
<br />
6. 流程导向的监督方式：<br />
支持逐步积累数据的流动方式，并在流程的不同阶段考虑加入新的数据。<br />
<br />
完整译文参考：<a href="https://baoyu.io/translations/prompt-engineering/alphacodium-state-of-the-art-code-generation-for-code-contests">baoyu.io/translations/prompt…</a></p>
<p><a href="https://nitter.cz/dotey/status/1748503587682967775#m">nitter.cz/dotey/status/1748503587682967775#m</a></p>
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VVVXpJcldvQUFZR3dRLmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VVVTFJS1hNQUFpMm41LmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VVVTdKTFgwQUV2dXd3LmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VVVkJxUlc4QUF1SUFjLnBuZw==" />
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748814824119644272#m</id>
            <title>一个科技文章翻译GPT https://chat.openai.com/g/g-uBhKUJJTl-ke-ji-wen-zhang-fan-yi 的经典案例：

### 直译
对于大语言模型(LLM)来说，理想的训练数据并不是你写下的内容。而是你内心思考的完整序列，以及在写作过程中的所有个别编辑。
但你只能用现有的数据来应对。

停一下，这和 Neuralink 无关，哈哈。
无论如何，这只是启蒙的第一阶段。
启蒙的第二阶段是，对于大语言模型(LLM)来说，理想的训练数据根本就不是训练数据。
而是你从阅读它的人那里得到的赞许。
但你只能用现有的数据来应对。

***

### 问题
1. 第一段中，“对于大语言模型(LLM)来说，理想的训练数据并不是你写下的内容。”这句话在中文中读起来略显生硬，需要调整语序和用词使其更加符合中文习惯。
2. “而是你内心思考的完整序列，以及在写作过程中的所有个别编辑。”这句话的表达略显晦涩，需要更加通俗易懂的表述。
3. “但你只能用现有的数据来应对。”这句话的语气和语境转换较生硬，需要更加流畅的衔接。
4. “停一下，这和 Neuralink 无关，哈哈。”这句话在中文中的直接翻译感觉突兀，需要调整语气和上下文的衔接。
5. “启蒙的第二阶段是，对于大语言模型(LLM)来说，理想的训练数据根本就不是训练数据。”这句话的结构复杂且难以理解，需要更简洁明了的表述。
6. “而是你从阅读它的人那里得到的赞许。”这句话的表达不够直观，需要更加具体和形象化。
7. 整体段落需要更好地连接和过渡，以提高整体的可读性。

***

### 意译
对于大语言模型（LLM）而言，最理想的训练数据并不仅仅是你笔下的文字。它其实包括了你思考过程中的每一个细节，以及写作时所做的每一次修改。
不过，我们只能尽力利用现有的资源。

别误会，这跟 Neuralink 完全没关系，哈哈。
话说回来，这只是认识到这一点的第一步。
第二步则是意识到，对大语言模型（LLM）来说，最理想的“训练数据”其实根本不是数据。
而是读者对你作品的点赞和认可。
但最终，我们还是只能利用手头上的资源。

https://chat.openai.com/share/ce31d429-1a2e-4733-9aee-f28af4e8c534</title>
            <link>https://nitter.cz/dotey/status/1748814824119644272#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748814824119644272#m</guid>
            <pubDate></pubDate>
            <updated>Sat, 20 Jan 2024 21:08:40 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>一个科技文章翻译GPT <a href="https://chat.openai.com/g/g-uBhKUJJTl-ke-ji-wen-zhang-fan-yi">chat.openai.com/g/g-uBhKUJJT…</a> 的经典案例：<br />
<br />
### 直译<br />
对于大语言模型(LLM)来说，理想的训练数据并不是你写下的内容。而是你内心思考的完整序列，以及在写作过程中的所有个别编辑。<br />
但你只能用现有的数据来应对。<br />
<br />
停一下，这和 Neuralink 无关，哈哈。<br />
无论如何，这只是启蒙的第一阶段。<br />
启蒙的第二阶段是，对于大语言模型(LLM)来说，理想的训练数据根本就不是训练数据。<br />
而是你从阅读它的人那里得到的赞许。<br />
但你只能用现有的数据来应对。<br />
<br />
***<br />
<br />
### 问题<br />
1. 第一段中，“对于大语言模型(LLM)来说，理想的训练数据并不是你写下的内容。”这句话在中文中读起来略显生硬，需要调整语序和用词使其更加符合中文习惯。<br />
2. “而是你内心思考的完整序列，以及在写作过程中的所有个别编辑。”这句话的表达略显晦涩，需要更加通俗易懂的表述。<br />
3. “但你只能用现有的数据来应对。”这句话的语气和语境转换较生硬，需要更加流畅的衔接。<br />
4. “停一下，这和 Neuralink 无关，哈哈。”这句话在中文中的直接翻译感觉突兀，需要调整语气和上下文的衔接。<br />
5. “启蒙的第二阶段是，对于大语言模型(LLM)来说，理想的训练数据根本就不是训练数据。”这句话的结构复杂且难以理解，需要更简洁明了的表述。<br />
6. “而是你从阅读它的人那里得到的赞许。”这句话的表达不够直观，需要更加具体和形象化。<br />
7. 整体段落需要更好地连接和过渡，以提高整体的可读性。<br />
<br />
***<br />
<br />
### 意译<br />
对于大语言模型（LLM）而言，最理想的训练数据并不仅仅是你笔下的文字。它其实包括了你思考过程中的每一个细节，以及写作时所做的每一次修改。<br />
不过，我们只能尽力利用现有的资源。<br />
<br />
别误会，这跟 Neuralink 完全没关系，哈哈。<br />
话说回来，这只是认识到这一点的第一步。<br />
第二步则是意识到，对大语言模型（LLM）来说，最理想的“训练数据”其实根本不是数据。<br />
而是读者对你作品的点赞和认可。<br />
但最终，我们还是只能利用手头上的资源。<br />
<br />
<a href="https://chat.openai.com/share/ce31d429-1a2e-4733-9aee-f28af4e8c534">chat.openai.com/share/ce31d4…</a></p>
<p><a href="https://nitter.cz/karpathy/status/1748784260318990496#m">nitter.cz/karpathy/status/1748784260318990496#m</a></p>
<img src="https://nitter.cz/pic/enc/Y2FyZF9pbWcvMTc0ODA4NzA2Nzk2NjM1MzQwOC9Ya0UzT21aZj9mb3JtYXQ9cG5nJm5hbWU9NDIweDQyMF8y" />
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/dotey/status/1748642115691639235#m</id>
            <title>看到一家新机器人公司，MagicLab，看起来人形机器人要像波士顿动力一样能实现空翻，不过这个是电驱的，成本上更经济一些。

空翻这种动作对于机器人要求还是蛮高的，目前没怎么看到电驱机器人能做到，不仅要有足够的力量，还需要很高的的控制精度，这意味着机器人在危险或恶劣的环境中更好的运动适应性，比如复杂的火场进出、人员救援、森林巡逻等。</title>
            <link>https://nitter.cz/dotey/status/1748642115691639235#m</link>
            <guid isPermaLink="false">https://nitter.cz/dotey/status/1748642115691639235#m</guid>
            <pubDate></pubDate>
            <updated>Sat, 20 Jan 2024 09:42:23 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>看到一家新机器人公司，MagicLab，看起来人形机器人要像波士顿动力一样能实现空翻，不过这个是电驱的，成本上更经济一些。<br />
<br />
空翻这种动作对于机器人要求还是蛮高的，目前没怎么看到电驱机器人能做到，不仅要有足够的力量，还需要很高的的控制精度，这意味着机器人在危险或恶劣的环境中更好的运动适应性，比如复杂的火场进出、人员救援、森林巡逻等。</p>
<p><a href="https://nitter.cz/MagicLab244144/status/1748377293595218138#m">nitter.cz/MagicLab244144/status/1748377293595218138#m</a></p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/Yangyixxxx/status/1748593506053132775#m</id>
            <title>RT by @dotey: 找一个很简单的切入点，不停地做，就会有很大收获。
比如资源嗅探这件事儿，做到极致就是一个矩阵，前端所有的逻辑都一样，一个按钮，一个地址，一个端（移动端），不断换内容。
- 小红书图片下载器
- 推特视频下载器
- ins图片下载器

这种从大平台下载图片去水印的场景太多了，抱着大树做就完了，甚至还可以找更垂直更细分的场景，比如淘宝图片和拼多多图片（很多人不做美工，下载了调一下直接上架）

低频刚需的场景用户不愿意付费，那就看广告。下载一次出一次激励视频。反正APP里全是广告，也没什么服务成本。

假如1个注册uv30天内平均使用30次，1次广告收益为0.1美金。那30日ARPU是3美金。卖个6美金永久去广告就完了。

就这样一个壳把所有场景都做完。无非后期只需要做的事情就是维护一下下载逻辑。当然，这个大部分情况下也有很多开源项目在做。

把时间变资产最简单的方式就是做一个固定的产品，等着它开始变成收益。一个不行，就两个，就三个，爆了一个，就会把所有投入都回收回来。</title>
            <link>https://nitter.cz/Yangyixxxx/status/1748593506053132775#m</link>
            <guid isPermaLink="false">https://nitter.cz/Yangyixxxx/status/1748593506053132775#m</guid>
            <pubDate></pubDate>
            <updated>Sat, 20 Jan 2024 06:29:13 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>找一个很简单的切入点，不停地做，就会有很大收获。<br />
比如资源嗅探这件事儿，做到极致就是一个矩阵，前端所有的逻辑都一样，一个按钮，一个地址，一个端（移动端），不断换内容。<br />
- 小红书图片下载器<br />
- 推特视频下载器<br />
- ins图片下载器<br />
<br />
这种从大平台下载图片去水印的场景太多了，抱着大树做就完了，甚至还可以找更垂直更细分的场景，比如淘宝图片和拼多多图片（很多人不做美工，下载了调一下直接上架）<br />
<br />
低频刚需的场景用户不愿意付费，那就看广告。下载一次出一次激励视频。反正APP里全是广告，也没什么服务成本。<br />
<br />
假如1个注册uv30天内平均使用30次，1次广告收益为0.1美金。那30日ARPU是3美金。卖个6美金永久去广告就完了。<br />
<br />
就这样一个壳把所有场景都做完。无非后期只需要做的事情就是维护一下下载逻辑。当然，这个大部分情况下也有很多开源项目在做。<br />
<br />
把时间变资产最简单的方式就是做一个固定的产品，等着它开始变成收益。一个不行，就两个，就三个，爆了一个，就会把所有投入都回收回来。</p>
                ]]>
            </content:encoded>
        </item>
        
        <item>
            <id>https://nitter.cz/yihong0618/status/1748308027147788317#m</id>
            <title>RT by @dotey: 俄罗斯这个神人每年用 SQL 来完成一个挑战来 Happy New Year.
2023 年是用 500 行 SQL 写个 GPT2… 已经坚持 10 多年了，下面图是他这 10 几年完成的各种挑战。。。
敬仰的站起来鞠了一躬。
link: https://explainextended.com/2023/12/31/happy-new-year-15/</title>
            <link>https://nitter.cz/yihong0618/status/1748308027147788317#m</link>
            <guid isPermaLink="false">https://nitter.cz/yihong0618/status/1748308027147788317#m</guid>
            <pubDate></pubDate>
            <updated>Fri, 19 Jan 2024 11:34:50 GMT</updated>
                
                
            <content:encoded>
                <![CDATA[
                    
                    <p>俄罗斯这个神人每年用 SQL 来完成一个挑战来 Happy New Year.<br />
2023 年是用 500 行 SQL 写个 GPT2… 已经坚持 10 多年了，下面图是他这 10 几年完成的各种挑战。。。<br />
敬仰的站起来鞠了一躬。<br />
link: <a href="https://explainextended.com/2023/12/31/happy-new-year-15/">explainextended.com/2023/12/…</a></p>
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VNODRNdGJnQUFJTEp2LmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VNODRNeGJJQUFiNjhiLmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VNODRNdmFnQUFqZnRhLmpwZw==" />
<img src="https://nitter.cz/pic/enc/bWVkaWEvR0VNODRNdmFVQUEwd0lKLmpwZw==" />
                ]]>
            </content:encoded>
        </item>
        
    </channel>
</rss>