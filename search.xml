<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020博客重大更新</title>
    <url>/post/d8d5597/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这两天大概有三十个小时扑在博客上，不禁感慨能把时间花在自己热爱的事情上，是多么幸运的事情。这次把<code>hexo</code> 更新到了 <code>5.2.0</code> ，<code>next</code> 主题也更新到了 <code>8.1.0</code> 。升级完还是很值得的，<code>hexo</code>现在渲染速度飞快。但期间还是踩了大量的坑，我得从<code>node.js</code>开始讲起</p>
<h2 id="Node-amp-Npm"><a href="#Node-amp-Npm" class="headerlink" title="Node&amp;Npm"></a>Node&amp;Npm</h2><p>网上说可以通过安装<code>node</code>版本管理工具<code>n</code>来升级<code>node</code></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">sudo npm cache chean</span><br><span class="line">sudo npm install n -g</span><br><span class="line">sudo n stable or sudo n x.x.x</span><br></pre></td></tr></tbody></table></figure>

<p>可惜<code>windows</code>不支持<code>n</code>, 所以只能去<a href="https://nodejs.org/zh-cn/">官网</a>下载并覆盖。我干脆删完了<code>node</code>重新安装最新版<code>14.15.1</code>。</p>
<p><code>npm</code>分为全局安装和本地安装，区别就在于安装的时候是否加了<code>-g</code>。我们一般会把一些希望在命令行中直接使用的包，进行全局安装，比如<code>hexo</code>、<code>vue</code>等。全局安装的包在<code>win10</code>中会默认放到<code>%user%\AppData\Roaming\npm\node_global</code>，如果你像我一样很讨厌它默认放到C盘，推荐通过以下方法修改默认路径，注意<code>cache</code>也最好一起修改。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">"D:\node\node_global"</span></span><br><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">"D:\node\node_cache"</span></span><br></pre></td></tr></tbody></table></figure>

<p>更多<code>node</code>和<code>npm</code>的命令<a href="https://www.runoob.com/nodejs/nodejs-tutorial.html">参考</a></p>
<h2 id="更新Hexo"><a href="#更新Hexo" class="headerlink" title="更新Hexo"></a>更新Hexo</h2><p>我是从<a href="https://hexo.io/zh-cn/docs/">hexo</a>3点几的版本升级到<code>5.2</code>的，虽然跨度很大但是<code>hexo</code>的升级并不麻烦。</p>
<p>可以通过<code>npm-check</code>,<code>npm-upgrade</code>,<code>npm update</code>这三个命令来升级</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo -g //首先保证全局的hexo最新</span><br><span class="line">hexo version //确认hexo全局最新</span><br><span class="line">npm install -g npm-check</span><br><span class="line">npm install -g npm-upgrade</span><br><span class="line">npm-check //这句在项目内部执行,查看有哪些包可以更新</span><br><span class="line">npm-upgrade //这句在项目内部执行,可以更新的包写入package.json</span><br><span class="line">npm update --save //根据package.json,正式更新项目中的包</span><br></pre></td></tr></tbody></table></figure>

<p>其实<a href="https://www.npmjs.com/package/npm-check">npm-check</a>足以完成包管理和升级的工作了，方法千千万，选一种自己喜欢的即可。</p>
<div class="note info"><p>在查资料的时候发现了一个看起来还不错的包管理工具<a href="https://www.npmjs.com/package/npm-check-updates">npm-check-updates</a>，它与<code>npm-check</code>类似，通过更新<code>package.json</code>以及使用<code>npm install</code>来更新项目中的包。</p>
</div>

<p>但因为原先的<code>Hexo</code>版本太旧了，站点配置文件<code>_config.yml</code>需要做一定的调整。我的做法是去用<code>hexo init</code>命令在另一个文件夹中重新生成了一份，然后对比两份站点配置文件<code>_config.yml</code>进行修改。具体可以参考这位博主给出的<a href="https://www.imczw.com/post/tech/hexo5-next8-updated.html#%E8%B0%83%E6%95%B4%E9%85%8D%E7%BD%AE">Hexo-5.x 与 NexT-8.x 跨版本升级</a>调整配置。更详细的配置文件描述请参考官方文档<a href="https://hexo.io/zh-cn/docs/configuration">配置</a></p>
<h2 id="升级Next"><a href="#升级Next" class="headerlink" title="升级Next"></a>升级Next</h2><div class="note info"><p>一定要关注<a href="https://theme-next.js.org/docs/">Next的官网</a>啊！里面有配置文件字段的说明。还有<a href="https://github.com/next-theme/hexo-theme-next/issues/4">更新说明及常见问题</a>，可以减少很多很多坑。</p>
<p>比如版本的不同对应Next的三个仓库….、<strong>V8.1.0移除了Valine</strong>….</p>
</div>

<p><code>Next</code>的更新较大，连配置文件的目录都改了，于是我做了旧主题的备份后，删除了旧主题的<code>themes/next</code>文件夹，用了新的安装方式<code>npm install hexo-theme-next</code>安装后，对照旧主题的配置文件进行修改。注意，将 Next 主题配置文件 <code>node_modules/hexo-theme-next/_config.yml </code>改名为 <code>_config.next.yml</code> 复制到根目录（与 Hexo 站点配置文件_config.yml 在同一目录），这个文件优先级最高。这样做的好处是以后可以通过 npm 顺滑升级 Next 版本，不用担心配置文件被覆盖。可以参考<a href="https://www.imczw.com/post/tech/hexo5-next8-updated.html#NexT-8-x%E8%B7%A8%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7"> NexT-8.x 跨版本升级</a></p>
<blockquote><p><code>NexT </code>支持在不修改主题仓库内文件的情况下进行配置和自定义，因此无论是使用 <code>Git </code>还是<code>npm</code>都能顺利更新。如果你见到要求直接修改主题文件的「教程」文章，请谨慎甄别，因为其内容可能过时。</p>
<p>请留意配置方式上的改变，使用 <code>_config.next.yml</code> 代替 <code>source/_data/next.yml</code>。</p>
<footer><strong>Next</strong><cite><a href="https://github.com/next-theme/hexo-theme-next/issues/4">github.com/next-theme/hexo-theme-next/issues/4</a></cite></footer></blockquote>

<h2 id="博客美化"><a href="#博客美化" class="headerlink" title="博客美化"></a>博客美化</h2><ul>
<li><p>主题：<code>Netx.Gemini</code></p>
</li>
<li><p>配置: <a href="https://github.com/TD21forever/TD21forever.github.io/tree/source">详见源码</a></p>
</li>
<li><p>分类</p>
<ul>
<li><a href="/categories/%E4%B8%89%E5%88%86%E6%8A%80%E6%9C%AF/">七分热爱</a></li>
<li><a href="/categories/%E4%B8%89%E5%88%86%E6%8A%80%E6%9C%AF/">三分技术</a></li>
<li><a href="/categories/%E5%8D%81%E5%88%86%E4%BA%BA%E7%94%9F/">十分人生</a></li>
</ul>
</li>
<li><p>样式</p>
<ul>
<li>参考（😂抄袭）<a href="https://blog.dlzhang.com/">班班</a>，谢谢博主开源！我实在太喜欢这样的布局和排版。</li>
</ul>
</li>
<li><p>字体</p>
<p>参考这篇博客<a href="https://guanqr.com/tech/website/web-font-guide/#">网站字体优化方案</a>，<code>Next</code><a href="https://theme-next.js.org/docs/theme-settings/miscellaneous.html">官网</a>关于字体的配置在这里</p>
<ul>
<li>global：EB Garamond,  Noto Serif SC</li>
<li>code: JetBrains Mono</li>
</ul>
</li>
<li><p>插件</p>
<ul>
<li>评论系统:   <del>Valine 最新版Hexo需自行<a href="https://github.com/next-theme/hexo-next-valine">安装</a></del> 已改为更安全的<a href="https://waline.js.org/quick-start.html">Waline </a></li>
<li>字数统计：<code>hexo-word-counter</code> 自带</li>
<li>代码高亮：<code>highlight.js</code> 可以在这个<a href="https://theme-next.js.org/highlight/">网站</a>进行预览和挑选</li>
<li>站点分析:  <code>baidu_analytics</code></li>
<li>背景动画:  <code>canvas_nest</code> 详见<a href="https://github.com/theme-next/theme-next-canvas-nest">这里</a></li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li><p>SSL证书与Https：阿里云免费证书</p>
<ol>
<li><p>在阿里云控制台为<a href="http://www.dcts.top添加证书./">www.dcts.top添加证书。</a></p>
</li>
<li><p>在github page仓库中设置强制开启Https</p>
</li>
<li><p>在站点配置文件中更改<a href="http://www.dcts.top为/">http://www.dcts.top为</a> <a href="https://www.dcts.top/">https://www.dcts.top</a></p>
</li>
</ol>
</li>
<li><p>图床：<a href="https://portal.qiniu.com/create">七牛</a></p>
<ol>
<li>七牛的Https流量是付费的，但是不贵</li>
<li>如果原先就有仓库以及绑定了非<code>Https</code>的域名，不需要新建域名，开启<code>Https</code>即可。</li>
<li>在阿里云控制台为该域名添加证书</li>
</ol>
</li>
<li><p>Tag Plugins: <a href="https://theme-next.js.org/docs/tag-plugins/">Next</a>以及<a href="https://hexo.io/docs/tag-plugins">Hexo提供的教程</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="待办事项"><a href="#待办事项" class="headerlink" title="待办事项"></a>待办事项</h2><ul>
<li>书单和观影： 📅 2020/12/20  <a href="https://michael728.github.io/books/">参考1</a>、<a href="https://blog.dlzhang.com/posts/51/">参考2</a> ✔</li>
<li>Webstack网址导航：  📅 2020/12/25  <a href="https://github.com/WebStackPage/WebStackPage.github.io">参考</a></li>
<li>一言 ：📅 2020/12/30 <a href="https://leaferx.online/sentence/">参考</a>、 <a href="https://alvarotrigo.com/fullPage/zh/#page2">fullpage.js</a></li>
<li>说说：📅 2020/12/30 <a href="https://cndrew.cn/2020/05/11/artitalk/">Artitalk.js</a>  ✔</li>
</ul>
<h2 id="近期更新"><a href="#近期更新" class="headerlink" title="近期更新"></a>近期更新</h2><ul>
<li><p><a href="https://www.dcts.top/post/d8d5597/">博客页面更新介绍</a>📅 2020/12/12 ✔</p>
</li>
<li><p>关于博客的一些想法与思考📅 2020/12/28</p>
<blockquote>
<p>我写博客的初心是什么，未来怎么运营和坚持？我浏览了很多人的博客，也产生了很多的想法与感慨。</p>
</blockquote>
</li>
<li><p>关于博客的写作规范📅 2020/12/28</p>
<blockquote>
<p>以及Hexo提供的特殊的写作语法记录</p>
</blockquote>
</li>
<li><p>数字货币投资心得📅 2020/12/22</p>
<blockquote>
<p>玩数字货币将近三个月了，发现人的理性总是无法战胜人的贪婪。杠杆是把双刃剑，有些东西是底线，决不能触碰，之后会写点自己的心得，警示自己。</p>
</blockquote>
</li>
<li><p>2020年末总结📅 2021/01/01</p>
<blockquote>
<p>可恶的2020年即将过去，这一年发生了太多太多事了</p>
</blockquote>
</li>
<li><p>力扣300题刷题笔记计划 📅 2021/12</p>
</li>
<li><p>Flask框架使用笔记📅 2021/01/10 </p>
<blockquote>
<p>想通过一个简单的CURD的例子，寻找一套既符合规范又符合自己习惯的后端搭建流程。</p>
</blockquote>
</li>
<li><p>耶鲁大学哲学-死亡笔记📅 2021/01/10 </p>
</li>
</ul>
]]></content>
      <categories>
        <category>七分热爱</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN&amp;Alexnet模型简单总结</title>
    <url>/post/c40e0394/</url>
    <content><![CDATA[<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ol>
<li><p>什么是全连接层</p>
<ul>
<li><p>  我们把所有神经元都会和下一层的所有神经元相连的这种连接，叫做 <strong>全连接(Fully-connected layer)</strong></p>
</li>
<li><p>  全连接一般会把卷积输出的二维特征图转化成一维的一个向量,把一张图高度浓缩成一个数了</p>
</li>
<li><p>  全连接的目的是什么呢？因为传统的网络我们的输出都是分类，也就是几个类别的概率甚至就是一个数–类别号，那么全连接层就是高度提纯的特征了，方便交给最后的分类器或者回归</p>
</li>
<li><p><a href="https://blog.csdn.net/u011021773/article/details/78121359">解释一下全连接层</a></p>
<p>  <img data-src="http://qiniu.dcts.top/%E5%85%A8%E8%BF%9E%E6%8E%A5.png"></p>
</li>
</ul>
</li>
<li><p>一些英文</p>
<ol>
<li> <strong>Stride</strong>-&gt;步长</li>
<li> <strong>Filter</strong>-&gt;卷积核</li>
<li> <strong>Padding</strong>-&gt;填充</li>
<li> <strong>Kernel size</strong>-&gt;卷积核的大小</li>
<li> <strong>Normalization layer</strong>-&gt;归一层</li>
<li> <strong>Convolutional layer</strong>-&gt;卷积层</li>
<li> <strong>Fully-Connected layer</strong>-&gt;全连接层</li>
</ol>
</li>
<li><p>一些解释</p>
<ol>
<li><p>为什么要用卷积运算</p>
<blockquote>
<p>卷积运算的目的是提取输入的不同特征，第一层卷积层可能只能提取一些低级的特征如边缘、线条和角等层级，更多层的网络能从低级特征中迭代提取更复杂的特征。</p>
</blockquote>
</li>
<li><p> 为什么要用激活函数</p>
</li>
<li><p>为什么要有池化层</p>
<blockquote>
<p>通常在卷积层之后会得到维度很大的特征，将特征切成几个区域，取其最大值或平均值，得到新的、维度较小的特征。</p>
</blockquote>
</li>
<li><p>为什么要用全连接层</p>
<blockquote>
<p>把所有局部特征结合变成全局特征，用来计算最后每一类的得分。</p>
</blockquote>
</li>
<li><p>数据预处理</p>
<ol>
<li> <a href="https://blog.csdn.net/elaine_bao/article/details/50889856">资料1</a></li>
</ol>
</li>
<li><p>训练速率</p>
<blockquote>
<p>如果设置的学习速率太小，你的模型可能需要几年才能收敛;如果学习速率太大，在开始训练几个样本之后，你的损失值(loss)可能会迅速增加。一般来说，0.01 的学习速率是安全的</p>
</blockquote>
</li>
</ol>
</li>
<li><p> 搭建一个神经网络一般的步骤<img data-src="http://qiniu.dcts.top/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9B%BE%E8%A7%A3.jpg"></p>
</li>
<li><p>典型神经网络训练过程</p>
<ul>
<li>  定义一个有着可学习的参数（或者权重）的神经网络</li>
<li>  对着一个输入的数据集进行迭代:<code>for step, (inputs,labels) in enumerate(train_loader)</code></li>
<li>  用神经网络对输入进行处理 <code>output = cnn(inputs)</code></li>
<li>  计算<strong>Loss</strong> (对输出值的修正到底有多少)<code>loss_func = nn.CrossEntropyLoss()</code></li>
<li>  梯度归零<code>optimizer.zero_grad()</code></li>
<li>  将梯度传播回神经网络的参数中 <code>loss.backward()</code></li>
<li>  更新网络中的权重 <code>optimizer.step()</code>通常使用简单的更新规则(SGD): <code>weight = weight + learning_rate * gradient</code></li>
</ul>
</li>
<li><p>如何计算卷积后图片大小(尺寸)</p>
<ol>
<li> <img data-src="http://qiniu.dcts.top/%E8%AE%A1%E7%AE%97%E5%8D%B7%E7%A7%AF%E5%90%8E%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F.jpg"></li>
<li> 图片的尺寸= (原来的尺寸-卷积核的尺寸+填充*2)/步长+1</li>
<li> 深度 = 卷积核的数量</li>
</ol>
</li>
<li><p>计算池化后图片的大小(尺寸)</p>
<ol>
<li> <img data-src="http://qiniu.dcts.top/%E8%AE%A1%E7%AE%97%E5%8D%B7%E7%A7%AF%E5%90%8E%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F.jpg"></li>
<li> 图片的尺寸 = （原来的尺寸-卷积核的尺寸）/步长+1</li>
<li> 深度不变</li>
<li> 为什么要把特征图摊平？</li>
</ol>
</li>
</ol>
<hr>
<h3 id="Alexnet"><a href="#Alexnet" class="headerlink" title="Alexnet"></a>Alexnet</h3><ol>
<li><p>图解</p>
<p> <img data-src="http://qiniu.dcts.top/Alexnet.jpg" alt="1561646029186"></p>
</li>
<li><p>各种图片尺寸的解读</p>
<ol>
<li> <code>CONV1</code>55 = (227-11+2*0)/4+1 = 55</li>
<li> <code>MAXPOOL1</code> 27 = (55-3)/2+1 = 27</li>
<li> <code>CONV2</code> 27 = (27-5+2*2)/1 +1= 27</li>
<li> <code>MAXPOOL2</code> 13 = (27-3)/2+1 = 13</li>
<li> <code>MAXPOOL3</code> 6 = (13-3)/2 +1 = 6</li>
</ol>
</li>
<li><p>Alexnet为啥取得比较好的效果</p>
<ol>
<li><p> 使用了<strong>Relu</strong>激活函数</p>
</li>
<li><p>Dropout</p>
<blockquote>
<p>Dropout也是经常说的一个概念，能够比较有效地防止神经网络的过拟合。 相对于一般如线性模型使用正则的方法来防止模型过拟合，而在神经网络中Dropout通过修改神经网络本身结构来实现。对于某一层神经元，通过定义的概率来<strong>随机删除一些神经元</strong>，同时保持输入层与输出层神经元的个人不变，然后按照神经网络的学习方法进行参数更新，下一次迭代中，重新随机删除一些神经元，直至训练结束。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h3 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h3><ol>
<li><p>为什么要用torch.nn.Sequential</p>
<ol>
<li> <code>torch.nn.Sequential</code>是一个<code>Sequential</code>容器，模块将按照构造函数中传递的顺序添加到模块中</li>
<li> <a href="https://ptorch.com/news/57.html">点击这里查看更多</a></li>
</ol>
</li>
<li><p>一些函数的参数介绍</p>
<ol>
<li><p>Conv2d</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"> nn.Conv2d(                 	<span class="comment"># input shape (1, 28, 28)	</span></span><br><span class="line">           in_channels=<span class="number">1</span>,              <span class="comment"># input height</span></span><br><span class="line">           out_channels=<span class="number">16</span>,            <span class="comment"># n_filters</span></span><br><span class="line">           kernel_size=<span class="number">5</span>,              <span class="comment"># filter size</span></span><br><span class="line">           stride=<span class="number">1</span>,                   <span class="comment"># filter movement/step</span></span><br><span class="line">           padding=<span class="number">2</span> ) <span class="comment"># if want same width and length of this image after con2d. </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Padding=(kernel_size-1)/2 if stride=1</span></span><br><span class="line"><span class="comment"># output shape (16, 28, 28)</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><a href="https://blog.csdn.net/Z_lbj/article/details/79766690">torch.max()</a></p>
</li>
</ol>
</li>
</ol>
<h3 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h3><ol>
<li> 如何使用已经保存了的神经网络</li>
<li> <code>res = conv5_out.view(conv5_out.size(0), -1) out = self.dense(res)</code> 这两行代码的意思</li>
<li> 为什么要用激活函数？</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li> <a href="https://blog.csdn.net/qq_33414271/article/details/79337141">卷积神经网络（CNN）的理解和实现</a></li>
<li> <a href="https://community.bigquant.com/t/%E4%B8%80%E6%97%A5%E6%90%9E%E6%87%82%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/126015">一日搞懂卷积神经网络</a></li>
<li> <a href="https://blog.csdn.net/jacke121/article/details/80595928">Pytorch view()、squeeze()、unsqueeze()、torch.max()</a></li>
</ol>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>Alexnet</tag>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>DCGAN学习笔记</title>
    <url>/post/5dc1b5fc/</url>
    <content><![CDATA[<h4 id="1-什么是GAN（Generative-Adversarial-Net）？"><a href="#1-什么是GAN（Generative-Adversarial-Net）？" class="headerlink" title="1. 什么是GAN（Generative Adversarial Net）？"></a>1. 什么是GAN（Generative Adversarial Net）？</h4><blockquote>
<p>假设有一个警察和一个造假币者，造假者按照真实钱币的样子来<strong>造假</strong>，警察来分辨遇到的钱币是真还是假。最初的时候，造假者的造假能力不高，所以警察可以很容易的分辨出来。当被识别出来的时候，造假者就会继续<strong>修炼自己的技艺</strong>。与此同时，警察的分辨能力也要相应<strong>提高</strong>。这样的过程就是一种生成<strong>对抗</strong>的过程。对抗到最后，造假者已经能够创造出可以以假乱真的钱币，警察难以区分真假。所以猜对的<strong>概率变成0.5</strong></p>
<p>来源：<a href="https://zhuanlan.zhihu.com/p/28853704">知乎</a></p>
</blockquote>
<h5 id="1-1-生成模型-Generator"><a href="#1-1-生成模型-Generator" class="headerlink" title="1.1 生成模型(Generator)"></a>1.1 生成模型(Generator)</h5><p>​    生成模型G的输入是随机噪声Z。</p>
<h5 id="1-2-判别模型-Discriminator"><a href="#1-2-判别模型-Discriminator" class="headerlink" title="1.2 判别模型(Discriminator)"></a>1.2 判别模型(Discriminator)</h5><p>​    判别模型D输入x，输出0-1范围内的一个实数，用来判断这个图片是真实图    片的概率有多大，相当于一个二分类器。</p>
<h5 id="1-3-工作原理"><a href="#1-3-工作原理" class="headerlink" title="1.3 工作原理"></a>1.3 工作原理</h5><p>​    <img data-src="https://pic4.zhimg.com/v2-eb171ce8dbd1f461d51c0611a71fdb0f_b.jpg" alt="img"></p>
<blockquote>
<p><strong>X是真实数据</strong>，真实数据<strong>符合Pdata(x)分布</strong>。<strong>z是噪声数据</strong>，噪声数据<strong>符合Pz(z)分布</strong>，比如高斯分布或者均匀分布。然后从噪声z进行抽样，通过G之后生成数据x=G(z)。然后真实数据与生成数据一起送入分类器D，后面接一个<strong>sigmoid</strong>函数，输出判定类别。</p>
</blockquote>
<h5 id="1-4-GAN目标优化函数"><a href="#1-4-GAN目标优化函数" class="headerlink" title="1.4 GAN目标优化函数"></a>1.4 GAN目标优化函数</h5><p><img data-src="https://pic3.zhimg.com/v2-c93b874f77316d54f01aa653f8c24a86_b.jpg" alt="img"></p>
<ol>
<li><p>固定G训练D时：</p>
<p><img data-src="https://pic3.zhimg.com/v2-474547ca59dd2737f0c4a8833f4ffcde_b.png" alt="img"></p>
<p>D是判断模型，真实的数据希望被D分成1，生成的数据希望被D分成0。</p>
<p>第一项表示真实数据，如果错认成了0，那么log(D(x))&lt;&lt;0,期望会变成负无穷大</p>
<p>第二项表示生成数据，如果错认成了1，那么log(D(x))&lt;&lt;0,期望会变成负无穷大</p>
<p>从而修正参数，使得V大起来，<strong>所以训练D的目的是希望这个式子的值越大越好</strong></p>
</li>
<li><p>固定D训练G时：</p>
<p>G是生成模型，希望D判断G生成的数据为1</p>
<p>目标函数第一项不包含G，是常数，直接忽略。</p>
<p>第二项只有当D为1时，V是最小的，<strong>所以训练G的目的是希望这个式子的值越小越好</strong></p>
</li>
<li><p><img data-src="https://pic2.zhimg.com/v2-dfa0c29336f15c4e9f047d8d1dae50f1_b.jpg" alt="img"></p>
<p>第二个式子和第一个式子等价。在训练的时候，第二个式子训练效果比较好 常用第二个式子的形式。</p>
</li>
</ol>
<h5 id="1-5-描述"><a href="#1-5-描述" class="headerlink" title="1.5 描述"></a>1.5 描述</h5><p><img data-src="https://pic3.zhimg.com/v2-aab535a56ee0fabaa3d52998d1baf616_b.png" alt="img"></p>
<blockquote>
<p>第一个图是一开始的情况，黑色的线表示数据x的实际分布，绿色的线表示数据的生成分布，我们希望绿色的线能够趋近于黑色的线，也就是让生成的数据分布与实际分布相同。然后蓝色的线表示生成的数据x对应于D的分布。在a图中，<strong>D还刚开始训练，本身分类的能力还有限，因此有波动</strong>，但是初步区分实际数据和生成数据还是可以的。到b图，D训练得比较好了，可以很明显的区分出生成数据，大家可以看到，随着绿色的线与黑色的线的偏移，蓝色的线下降了，也就是生成数据的概率下降了。那么，由于绿色的线的目标是提升概率，因此就<strong>会往蓝色线高的方向移动</strong>，也就是c图。那么随着训练的持续，由于G网络的提升，G也反过来影响D的分布。</p>
</blockquote>
<h4 id="2-什么是DCGAN（Deep-Convolutional-GAN）？"><a href="#2-什么是DCGAN（Deep-Convolutional-GAN）？" class="headerlink" title="2. 什么是DCGAN（Deep Convolutional GAN）？"></a>2. 什么是DCGAN（Deep Convolutional GAN）？</h4><h5 id="2-1-DCGAN对GAN的改造"><a href="#2-1-DCGAN对GAN的改造" class="headerlink" title="2.1 DCGAN对GAN的改造"></a>2.1 DCGAN对GAN的改造</h5><ol>
<li>去掉了G网络和D网络中的pooling layer</li>
<li>在G网络和D网络中都使用Batch Normalization</li>
<li>去掉全连接的隐藏层</li>
<li>在G网络中除最后一层使用RELU，最后一层使用Tanh</li>
<li>在D网络中每一层使用LeakyRELU。</li>
</ol>
<p><strong><em>ps:要这样做只是因为看起来效果好。就是纯粹工程调出来了一个不错的效果。</em></strong></p>
<h5 id="2-2-一些约定俗成的规矩"><a href="#2-2-一些约定俗成的规矩" class="headerlink" title="2.2 一些约定俗成的规矩"></a>2.2 一些约定俗成的规矩</h5><ul>
<li>在Discriminator和generator中大部分层都使用batch normalization，而在最后一层时通常不会使用batch normalizaiton，目的 是为了保证模型能够学习到数据的正确的均值和方差</li>
<li>因为会从random的分布生成图像，所以一般做需要增大图像的空间维度时如7<em>7-&gt;14</em>14， 一般会使用strdie为2的deconv（transposed convolution）</li>
<li>通常在DCGAN中会使用Adam优化算法而不是SGD。</li>
</ul>
<h4 id="3-用pytorch实现DCGAN"><a href="#3-用pytorch实现DCGAN" class="headerlink" title="3. 用pytorch实现DCGAN"></a>3. 用pytorch实现DCGAN</h4><p>计算尺寸大小的公式：<code>H_out=(H_in-1)*stride-2*padding+kernel_size</code></p>
<h5 id="3-1-生成器定义"><a href="#3-1-生成器定义" class="headerlink" title="3.1 生成器定义"></a>3.1 生成器定义</h5><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetG</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ngf, nz</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(NetG, self).__init__()</span><br><span class="line">        <span class="comment"># layer1输入的是一个100x1x1的随机噪声, 输出尺寸(ngf*8)x4x4</span></span><br><span class="line">        self.layer1 = nn.Sequential(</span><br><span class="line">            nn.ConvTranspose2d(nz, ngf * <span class="number">8</span>, kernel_size=<span class="number">4</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(ngf * <span class="number">8</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># layer2输出尺寸(ngf*4)x8x8</span></span><br><span class="line">        self.layer2 = nn.Sequential(</span><br><span class="line">            nn.ConvTranspose2d(ngf * <span class="number">8</span>, ngf * <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(ngf * <span class="number">4</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># layer3输出尺寸(ngf*2)x16x16</span></span><br><span class="line">        self.layer3 = nn.Sequential(</span><br><span class="line">            nn.ConvTranspose2d(ngf * <span class="number">4</span>, ngf * <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(ngf * <span class="number">2</span>),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># layer4输出尺寸(ngf)x32x32</span></span><br><span class="line">        self.layer4 = nn.Sequential(</span><br><span class="line">            nn.ConvTranspose2d(ngf * <span class="number">2</span>, ngf, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(ngf),</span><br><span class="line">            nn.ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># layer5输出尺寸 3x96x96</span></span><br><span class="line">        self.layer5 = nn.Sequential(</span><br><span class="line">            nn.ConvTranspose2d(ngf, <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.Tanh()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义NetG的前向传播</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        out = self.layer1(x)</span><br><span class="line">        out = self.layer2(out)</span><br><span class="line">        out = self.layer3(out)</span><br><span class="line">        out = self.layer4(out)</span><br><span class="line">        out = self.layer5(out)</span><br><span class="line">        <span class="comment"># print(out)</span></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>直接使用·<code>nn.Sequential</code> 将上卷积、激活、池化等操作拼接起来即可，这里需要注意上卷积 <code>ConvTransposed2d </code>的使用。当 kernel size 为 4、stride 为 2、padding 为 1 时，根据公式 <code>H_out=(H_in-1)*stride-2*padding+kernel_size</code>，输出尺寸刚好变成输入的两倍。最后一层采用 kernel size 为 5、stride 为 3、padding 为 1，是为了将 32×32 上采样到 96×96，这是本例中图片的尺寸，与论文中 64×64 的尺寸不一样。最后一层用 <code>Tanh </code>将输出图片的像素归一化至 -1<del>1，如果希望归一化至 0</del>1，则需使用 <code>Sigmoid</code>。</p>
<h5 id="3-2-判别器的定义"><a href="#3-2-判别器的定义" class="headerlink" title="3.2 判别器的定义"></a>3.2 判别器的定义</h5><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 定义鉴别器网络D</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetD</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ndf</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(NetD, self).__init__()</span><br><span class="line">        <span class="comment"># layer1 输入 3 x 96 x 96, 输出 (ndf) x 32 x 32</span></span><br><span class="line">        self.layer1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, ndf, kernel_size=<span class="number">5</span>, stride=<span class="number">3</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(ndf),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># layer2 输出 (ndf*2) x 16 x 16</span></span><br><span class="line">        self.layer2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(ndf, ndf * <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(ndf * <span class="number">2</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># layer3 输出 (ndf*4) x 8 x 8</span></span><br><span class="line">        self.layer3 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(ndf * <span class="number">2</span>, ndf * <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(ndf * <span class="number">4</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># layer4 输出 (ndf*8) x 4 x 4</span></span><br><span class="line">        self.layer4 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(ndf * <span class="number">4</span>, ndf * <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.BatchNorm2d(ndf * <span class="number">8</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># layer5 输出一个数(概率)</span></span><br><span class="line">        self.layer5 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(ndf * <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.Sigmoid()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义NetD的前向传播</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        out = self.layer1(x)</span><br><span class="line">        out = self.layer2(out)</span><br><span class="line">        out = self.layer3(out)</span><br><span class="line">        out = self.layer4(out)</span><br><span class="line">        out = self.layer5(out)</span><br><span class="line">        <span class="comment"># print(out)</span></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>可以看出判别器和生成器的网络结构几乎是对称的，从卷积核大小到 padding、stride 等设置，<strong>几乎一模一样</strong>。例如生成器的最后一个卷积层的尺度是（5，3，1），判别器的第一个卷积层的尺度也是（5，3，1）。另外，这里需要注意的是生成器的激活函数用的是 ReLU，而判别器使用的是 LeakyReLU，二者并无本质区别，这里的选择更多是<strong>经验总结</strong>。每一个样本经过判别器后，输出一个 0~1 的数，表示这个样本是真图片的概率。</p>
<h5 id="3-3-训练模型"><a href="#3-3-训练模型" class="headerlink" title="3.3 训练模型"></a>3.3 训练模型</h5><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.utils <span class="keyword">as</span> vutils</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> NetD, NetG</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        image, label = self.imgs[item]</span><br><span class="line">        image = Image.<span class="built_in">open</span>(image)</span><br><span class="line">        img = transform(image)</span><br><span class="line">        print(image, img.shape)</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--batchSize'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">64</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--imageSize'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">96</span>,<span class="built_in">help</span>=<span class="string">'size of image'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--nz'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">100</span>, <span class="built_in">help</span>=<span class="string">'size of the latent z vector'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--ngf'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">64</span>,<span class="built_in">help</span>=<span class="string">'num of G feature map'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--ndf'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">64</span>,<span class="built_in">help</span>=<span class="string">'num of D feature map'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--epoch'</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">400</span>, <span class="built_in">help</span>=<span class="string">'number of epochs to train for'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--lr'</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.0002</span>, <span class="built_in">help</span>=<span class="string">'learning rate, default=0.0002'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--beta1'</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.5</span>, <span class="built_in">help</span>=<span class="string">'beta1 for adam. default=0.5'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--data_path'</span>, default=<span class="string">'data/'</span>, <span class="built_in">help</span>=<span class="string">'folder to train data'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--outf'</span>, default=<span class="string">'imgs/'</span>, <span class="built_in">help</span>=<span class="string">'folder to output images and model checkpoints'</span>)</span><br><span class="line">opt = parser.parse_args()</span><br><span class="line"><span class="comment"># 定义是否使用GPU</span></span><br><span class="line">device = torch.device(<span class="string">"cuda"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">print(device)</span><br><span class="line"></span><br><span class="line"><span class="comment">#图像读入与预处理</span></span><br><span class="line">transforms = torchvision.transforms.Compose([</span><br><span class="line">    torchvision.transforms.Resize(opt.imageSize),</span><br><span class="line">    <span class="comment"># torchvision.transforms.ToPILImage(mode=None),</span></span><br><span class="line">    torchvision.transforms.ToTensor(),</span><br><span class="line">    torchvision.transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>)), ])</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.ImageFolder(opt.data_path, transform=transforms)</span><br><span class="line"></span><br><span class="line">dataloader = torch.utils.data.DataLoader(</span><br><span class="line">    dataset=dataset,</span><br><span class="line">    batch_size=opt.batchSize,</span><br><span class="line">    shuffle=<span class="literal">True</span>,</span><br><span class="line">    drop_last=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">netG = NetG(opt.ngf, opt.nz).to(device)</span><br><span class="line">netD = NetD(opt.ndf).to(device)</span><br><span class="line"><span class="comment">#是否要使用训练过的模型</span></span><br><span class="line"><span class="comment"># netD.load_state_dict(torch.load("D.pth"))</span></span><br><span class="line"><span class="comment"># netG.load_state_dict(torch.load("G.pth"))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">criterion = nn.BCELoss()</span><br><span class="line">optimizerG = torch.optim.Adam(netG.parameters(), lr=opt.lr, betas=(opt.beta1, <span class="number">0.999</span>))</span><br><span class="line">optimizerD = torch.optim.Adam(netD.parameters(), lr=opt.lr, betas=(opt.beta1, <span class="number">0.999</span>))</span><br><span class="line"></span><br><span class="line">label = torch.FloatTensor(opt.batchSize)</span><br><span class="line">real_label = <span class="number">1</span></span><br><span class="line">fake_label = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, opt.epoch + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> i, (imgs,_) <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataloader):</span><br><span class="line">        <span class="comment"># 固定生成器G，训练鉴别器D</span></span><br><span class="line">        optimizerD.zero_grad()</span><br><span class="line">        <span class="comment">## 让D尽可能的把真图片判别为1</span></span><br><span class="line">        imgs=imgs.to(device)</span><br><span class="line">        output = netD(imgs)</span><br><span class="line">        label.data.fill_(real_label)</span><br><span class="line">        label=label.to(device)</span><br><span class="line">        errD_real = criterion(output, label)</span><br><span class="line">        errD_real.backward()</span><br><span class="line">        <span class="comment">## 让D尽可能把假图片判别为0</span></span><br><span class="line">        label.data.fill_(fake_label)</span><br><span class="line">        noise = torch.randn(opt.batchSize, opt.nz, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        noise=noise.to(device)</span><br><span class="line">        fake = netG(noise)  <span class="comment"># 生成假图</span></span><br><span class="line">        output = netD(fake.detach()) <span class="comment">#避免梯度传到G，因为G不用更新</span></span><br><span class="line">        errD_fake = criterion(output, label)</span><br><span class="line">        errD_fake.backward()</span><br><span class="line">        errD = errD_fake + errD_real</span><br><span class="line">        optimizerD.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 固定鉴别器D，训练生成器G</span></span><br><span class="line">        optimizerG.zero_grad()</span><br><span class="line">        <span class="comment"># 让D尽可能把G生成的假图判别为1</span></span><br><span class="line">        label.data.fill_(real_label)</span><br><span class="line">        label = label.to(device)</span><br><span class="line">        output = netD(fake)</span><br><span class="line">        errG = criterion(output, label)</span><br><span class="line">        errG.backward()</span><br><span class="line">        optimizerG.step()</span><br><span class="line"></span><br><span class="line">        print(<span class="string">'[%d/%d][%d/%d] Loss_D: %.3f Loss_G %.3f'</span></span><br><span class="line">              % (epoch, opt.epoch, i, <span class="built_in">len</span>(dataloader), errD.item(), errG.item()))</span><br><span class="line"></span><br><span class="line">    vutils.save_image(fake.data,</span><br><span class="line">                      <span class="string">'%s/fake_samples_epoch_%03d.png'</span> % (opt.outf, epoch),</span><br><span class="line">                      normalize=<span class="literal">True</span>)</span><br><span class="line">    torch.save(netG.state_dict(), <span class="string">'%s/netG_%03d.pth'</span> % (opt.outf, epoch))</span><br><span class="line">    torch.save(netD.state_dict(), <span class="string">'%s/netD_%03d.pth'</span> % (opt.outf, epoch))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>（1）训练判别器。</p>
<ul>
<li>固定生成器</li>
<li>对于真图片，判别器的输出概率值尽可能接近 1</li>
<li>对于生成器生成的假图片，判别器尽可能输出 0</li>
</ul>
<p>（2）训练生成器。</p>
<ul>
<li>固定判别器</li>
<li>生成器生成图片，尽可能让判别器输出 1</li>
</ul>
<p>（3）返回第一步，循环交替训练</p>
<h5 id="3-4-实验结果分析"><a href="#3-4-实验结果分析" class="headerlink" title="3.4 实验结果分析"></a>3.4 实验结果分析</h5><p><img data-src="http://qiniu.dcts.top/fake_samples_epoch_051.png" alt="50 epoch"></p>
<p><img data-src="http://qiniu.dcts.top/fake_samples_epoch_200.png" alt="200 epoch"></p>
<p>​                                        </p>
<p><img data-src="http://qiniu.dcts.top/fake_samples_epoch_400.png" alt="400 epoch"></p>
<h4 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h4><ul>
<li><a href="https://mp.weixin.qq.com/s/vx0txFUf10QDBlldz0VJmg">如何用基于PyTorch的生成对抗网络生成动漫头像？</a></li>
<li><a href="https://blog.csdn.net/sunqiande88/article/details/80219842">Pytorch实战3：DCGAN深度卷积对抗生成网络生成动漫头像</a></li>
</ul>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>DCGAN</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker笔记</title>
    <url>/post/5c266b64/</url>
    <content><![CDATA[<h4 id="Docker-With-GPU"><a href="#Docker-With-GPU" class="headerlink" title="Docker With GPU"></a>Docker With GPU</h4><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 测试是否可以看到所有显卡，如果没有 nvidia/cuda:10.0-base，则会先下载该镜像</span></span><br><span class="line">docker run --gpus all nvidia/cuda:10.0-base nvidia-smi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在一个容器上使用两块GPU</span></span><br><span class="line">docker run --gpus 2 nvidia/cuda:10.0-base nvidia-smi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定使用的GPU</span></span><br><span class="line">docker run --gpus <span class="string">'"device=1,2"'</span> nvidia/cuda:10.0-base nvidia-smi</span><br><span class="line">docker run --gpus <span class="string">'"device=UUID-ABCDEF,1"'</span> nvidia/cuda:10.0-base nvidia-smi</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifying a capability (graphics, compute, ...) for my container</span></span><br><span class="line">docker run --gpus all,capabilities=utility nvidia/cuda:10.0-base nvidia-smi</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Docker-Run"><a href="#Docker-Run" class="headerlink" title="Docker Run"></a>Docker Run</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker run -it -p xxxx:xxxx-v [主机代码目录]:[容器内代码映射目录] --gpus all --name [创建的容器名称] [镜像名称]:[镜像tag] /bin/bash -c "sh trainer/train.sh"</span><br><span class="line"></span><br><span class="line">docker run -it -p 5555:22 -v "$PWD:/workspace" --gpus all --name xxx imagesName:tag /bin/bash</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>-it</code>：这是两个参数，一个是 <code>-i</code> 表示交互式操作，一个是 <code>-t</code> 为终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。</li>
<li><code>ubuntu:16.04</code>：这是指用 <code>ubuntu:16.04</code> 镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用 bash。</li>
<li><code>-v</code> : “[主机工作目录]:[容器内工作映射目录]” ： 指定容器内文件的挂载路径</li>
<li><code>-p</code> <code>5555</code>:<code>22</code>是将宿主机的<code>5555</code>端口映射到容器的<code>2333</code>端口  </li>
</ul>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><ul>
<li><p>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入<code>sudo</code>，可以把用户加入 Docker 用户组 </p>
 <figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo groupadd docker <span class="comment">#添加docker用户组</span></span><br><span class="line">sudo gpasswd -a <span class="variable">$USER</span> docker <span class="comment">#将登陆用户加入到docker用户组中</span></span><br><span class="line">newgrp docker <span class="comment">#更新用户组</span></span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<h4 id="Docker-Images"><a href="#Docker-Images" class="headerlink" title="Docker Images"></a>Docker Images</h4><p> Image 文件可以看作是容器的模板。Docker 根据 Image 文件生成容器的实例。同一个 Image 文件，可以生成多个同时运行的容器实例。 </p>
<ul>
<li><p><code>docker image ls  or  docker images</code></p>
</li>
<li><p><code>docker image rm [imageName] or [imageID]</code></p>
</li>
<li><p><code>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code><br> 例子：<code>docker pull ubuntu:16.04</code></p>
</li>
</ul>
<h4 id="Docker-Container"><a href="#Docker-Container" class="headerlink" title="Docker Container"></a>Docker Container</h4><ul>
<li><p><code>docker ps -a</code> 来查看当前系统的容器</p>
</li>
<li><p><code>docker start [-i] container-id</code><strong>启动</strong>某个容器，必须是已经创建的。 加上<code>-i</code> 参数之后，可以直接<strong>进入</strong>交互模式</p>
</li>
<li><p>除了通过<code>-i</code><strong>进入</strong>交互模式，还有一种方法，那就是通过<code>attach</code>: <code>docker attach container-id</code> </p>
</li>
<li><p>退出但是保持容器运行，按<code>CTRL+Q+P</code>三个键 - 退出 </p>
</li>
<li><p>使用<code>docker start/restart</code> 命令来启动/重启一个容器</p>
</li>
<li><p>使用<code>docker stop/rm</code>命令来停止/删除一个容器</p>
</li>
</ul>
<h4 id="使用阿里云的docker加速器。"><a href="#使用阿里云的docker加速器。" class="headerlink" title="使用阿里云的docker加速器。"></a>使用阿里云的docker加速器。</h4><p>在阿里云申请一个账号，<br>打开连接 <a href="https://cr.console.aliyun.com/#/accelerator">https://cr.console.aliyun.com/#/accelerator</a> 拷贝您的专属加速器地址。</p>
<p>修改修改daemon配置文件/etc/docker/daemon.json来使用加速器(下面是4个命令，分别单独执行)</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br><span class="line">{</span><br><span class="line">  "registry-mirrors": ["https://jxus37ad.mirror.aliyuncs.com"]</span><br><span class="line">}</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></tbody></table></figure>

<p>​    </p>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Faster-Rcnn学习资源整理</title>
    <url>/post/7c423b52/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在研究学习faster-rcnn，初次接触目标检测的我确实被其高效、快速的检测效果惊艳到了。但在学习和代码实现的过程中确实遇到了很多困难，寻找了很多资料，本文将整理我所阅读过的比较好的文章和代码，供自己回顾复习使用，也供和大家参考。</p>
<h2 id="原理篇"><a href="#原理篇" class="headerlink" title="原理篇"></a>原理篇</h2><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/32404424">从编程实现角度学习Faster R-CNN（附极简实现）</a></p>
<p>来自陈云大神，知乎上公认Faster-Rcnn写的最好的文章之一。其复现的代码仅2000行，跑出了比论文更好的效果！本文所提供的的代码非常值得学习。</p>
</li>
<li><p><a href="https://tryolabs.com/blog/2018/01/18/faster-r-cnn-down-the-rabbit-hole-of-modern-object-detection/">Faster R-CNN: Down the rabbit hole of modern object detection</a></p>
<p>虽然全篇是英文，但没有很晦涩难懂的单词，所以读起来还是很轻松的，而且由于英语的语言特色，各种概念理解起来就更加直白，推荐阅读。</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/64410344">一点一点理解faster-rcnn</a></p>
<p>我阅读的另一篇原理讲解，这其实是我看的第一篇关于Faster-Rcnn的文章，通读完后就对Faster-Rcnn有了比较清晰的认识。文中对Anchors和Bounding Box Regression的讲解我觉得很形象。</p>
</li>
</ul>
<p>综上，个人感觉读完上面三篇文章，并通过自己做笔记整理思路，对Faster-Rcnn的整体流程肯定会有个更加清晰的认识，但对其中一些细节又有些模糊，那这个时候我们就得看代码了。</p>
<h3 id="看代码篇"><a href="#看代码篇" class="headerlink" title="看代码篇"></a>看代码篇</h3><p>我看的代码是陈云大神复现的Pytorch版本，<a href="https://github.com/chenyuntc/simple-faster-rcnn-pytorch">simple-faster-rcnn-pytorch</a>。</p>
<p>这里推荐一篇对本代码讲解的文章，<a href="https://www.cnblogs.com/kerwins-AC/p/9734381.html">目标检测之Faster-RCNN的pytorch代码详解(数据预处理篇)</a>，这篇博客对我理解代码帮助特别大，讲的很详细！通过对代码的研读，进一步理解原理中的一些细节。</p>
<h3 id="代码实现篇"><a href="#代码实现篇" class="headerlink" title="代码实现篇"></a>代码实现篇</h3><p>我想大部分人学习Faster-Rcnn肯定是想要实现自己的一个目标检测的小项目吧，本文将提供两份代码，一份由Pytorch实现，一份由Keras实现，亲测可以跑通！</p>
<h3 id="Keras实现"><a href="#Keras实现" class="headerlink" title="Keras实现"></a>Keras实现</h3><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ul>
<li><a href="https://www.bilibili.com/video/av91598533">【视频】Keras 搭建自己的Faster-RCNN目标检测平台</a></li>
<li><a href="https://github.com/bubbliiiing/faster-rcnn-keras">【代码】faster-rcnn-keras</a> </li>
</ul>
<p>Keras的实现主要参考B站以为Up主的视频，讲解非常详细。up主在视频中讲解了Faster-Rcnn的原理，也介绍了<strong>如何使用Up的代码来训练自己的数据集以及如何使用Labelimg来制作训练集标签</strong>，基本上没什么坑，以下是一些注意事项：</p>
<ul>
<li>平台：Windows10（win10自测可行，Linux没测试过）</li>
<li>环境：tensorflow 1.13.1; keras 2.1.5 ; CUDA 10.0</li>
<li>特征提取网络：ResNet50</li>
</ul>
<p>遇到的问题：</p>
<ul>
<li>由于平时习惯使用tf2.0，装的也是CUDA10.1。发现CUDA10.1对tf1.13并不支持，所以在CUDA上花了很多时间</li>
<li>一直没搞明白 <code>训练所需的voc_weights.h5 </code> 指的到底是<strong>预训练的特征提取网络参数</strong>，还是<strong>Faster-Rcnn训练完以后的参数</strong>，个人估计是后者，因为实测<code>voc_weights.h5</code>可以直接用来做目标检测。</li>
</ul>
<p>这份代码还是很好跑的，只要依据UP主的流程一步一步做下去，没什么坑！</p>
<h3 id="Pytorch实现"><a href="#Pytorch实现" class="headerlink" title="Pytorch实现"></a>Pytorch实现</h3><h4 id="参考资料：-1"><a href="#参考资料：-1" class="headerlink" title="参考资料："></a>参考资料：</h4><ul>
<li><a href="https://www.codeleading.com/article/23341646679/">【博客】pytorch 1.0实现faster R-CNN</a></li>
<li><a href="https://github.com/jwyang/faster-rcnn.pytorch">【代码】faster-rcnn.pytorch</a> </li>
</ul>
<p>Pytorch的实现主要参考<strong>博客</strong>，由于Pytorch的代码年代有点久远了，有一些语法已经不支持，所以在实现的时候遇到了很多坑，<strong>博客</strong>中的讲解其实已经很详细了，但还是遗漏了一些，本文将强调实现过程中的一些注意事项，和我遇到的一些错误。</p>
<ul>
<li><p>平台：Ubantu<strong>（由于需要编译 win10下编译实在是太麻烦，建议Linux用于选择此份代码）</strong></p>
</li>
<li><p>环境：Pytorch1.2.0； torchvision==0.4.0; CUDA 9.2 或者 10.0（<strong>虽然博客说明是Pytorch1.0.0，但实测Pytorch1.2.0完全没问题，安装方法就按照官网，按如下指令安装）</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># CUDA 9.2</span></span><br><span class="line">conda install pytorch==1.2.0 torchvision==0.4.0 cudatoolkit=9.2 -c pytorch</span><br><span class="line"></span><br><span class="line"><span class="comment"># CUDA 10.0</span></span><br><span class="line">conda install pytorch==1.2.0 torchvision==0.4.0 cudatoolkit=10.0 -c pytorch</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU Only</span></span><br><span class="line">conda install pytorch==1.2.0 torchvision==0.4.0 cpuonly -c pytorch</span><br></pre></td></tr></tbody></table></figure>

<p>我安装的是CUDA10的版本。<strong>注意</strong>，官方例子中 -c 会使得无法使用清华的源，<strong>因此，实际操作时</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># CUDA 10.0</span></span><br><span class="line">conda install pytorch==1.2.0 torchvision==0.4.0 cudatoolkit=10.0</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<p>遇到的一些问题：</p>
<ul>
<li><p><strong>注意一定要切换分支！！！</strong> 博客中也提到了，如果使用Pytorch1.0以上，需要切换分支！</p>
<p><code>git checkout pytorch-1.0</code></p>
</li>
<li><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#进入faster-rcnn.pytorch文件，同时在内创建一个data文件夹</span><br><span class="line">cd faster-rcnn.pytorch &amp;&amp; mkdir data</span><br><span class="line">#安装依赖的pyhon包，这一步若是报错说没有权限访问安装就在开头加上 sudo</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line">#下载coco kit，并make</span><br><span class="line">git clone https://github.com/pdollar/coco.git</span><br><span class="line">cd coco/PythonAPI</span><br><span class="line">make</span><br></pre></td></tr></tbody></table></figure>

<p>这一步博客没讲清楚，对coco的PythonAPI编译以后（make了以后），将<code>/PythonAPI/pycocotools</code> 这个文件夹，复制到<code>faster-rcnn.pytorch\lib</code> 下，对<code>lib</code>下的<code>pycocotools</code> 的文件夹进行替换！ 原因就是lib下的pycocotools太老了，有一些功能用不了了！</p>
</li>
<li><p>然后继续按照博客的来</p>
</li>
<li><p>这份代码可以使用VGG16，也可以使用ResNet101，都需要预训练参数（<strong>应该是在ImageNet中训练的特征提取网络</strong>），博客中给了下载链接。我使用的是VGG16的预训练模型，下载好的文件名为<code>vgg16_caffe.pth</code> ，约有527MB大小。</p>
</li>
<li><p>对于数据的准备，博客中并没有说明如何制作数据，如何制作.txt后缀的文件，可以参考Keras版本的实现，使用keras版本中<code>voc2faster-rcnn.py</code>文件即可生成四个.txt。(但我在实现的时候，只设置了训练集也就是说只有trainval.txt里面是存在数据的)</p>
  <figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">├── test.txt    </span><br><span class="line">├── train.txt           </span><br><span class="line">├── trainval.txt         </span><br><span class="line">└── val.txt </span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>from scipy.misc import imread</code>出现错误,这点在博客中没有提及</p>
<p>这是因为scipy库中的imread要被弃用也就是不能用了，这时需要改成这样<code>from imageio import imread</code> </p>
</li>
<li><p>其余的问题可以看博客里的处理方式，本人在实验过程中基本都没有遇到。</p>
<p>这里再提供<a href="https://www.cnblogs.com/FZfangzheng/p/10852141.html">记pytorch版faster rcnn配置运行中的一些坑</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>Faster-Rcnn</tag>
        <tag>机器学习</tag>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title>Metaclass</title>
    <url>/post/a1399864/</url>
    <content><![CDATA[<p>翻译自</p>
<p><a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python?rq=1">What are metaclasses in Python?</a></p>
<h2 id="类也是对象"><a href="#类也是对象" class="headerlink" title="类也是对象"></a>类也是对象</h2><p>在大多数编程语言中，类只是一串用于描述如何生成一个对象的代码。但在python中，类不止如此，类也是对象（object）！</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ObjectCreator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">... </span>      <span class="keyword">pass</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<p>一旦使用关键字<code>class</code>，<code>python</code>便会执行它并且生成一个<strong>对象。</strong>这个对象的名字叫做<code>ObjectCreator</code>。</p>
<div class="note info"><p>💡 这个对象有创建其他对象的能力，所以我们也叫它，类。</p>
</div>

<p>上面的描述也许看的晕乎乎，简而言之，我们传统认知中类是用来实例化一个对象的，这当然没错，但在python中，类本身就是一个对象，既然是个对象，则有对象应该有的性质</p>
<ul>
<li>可以赋值给一个变量</li>
<li>可以copy它</li>
<li>可以为它添加属性</li>
<li>可以当作函数的参数</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreator) <span class="comment"># you can print a class because it's an object</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></span><br><span class="line">=================================</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo</span>(<span class="params">o</span>):</span></span><br><span class="line"><span class="meta">... </span>      print(o)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>echo(ObjectCreator) <span class="comment"># you can pass a class as a parameter</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></span><br><span class="line">=================================</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="built_in">hasattr</span>(ObjectCreator, <span class="string">'new_attribute'</span>))</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectCreator.new_attribute = <span class="string">'foo'</span> <span class="comment"># you can add attributes to a class</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="built_in">hasattr</span>(ObjectCreator, <span class="string">'new_attribute'</span>))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreator.new_attribute)</span><br><span class="line">foo</span><br><span class="line">=================================</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ObjectCreatorMirror = ObjectCreator <span class="comment"># you can assign a class to a variable</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreatorMirror.new_attribute)</span><br><span class="line">foo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ObjectCreatorMirror())</span><br><span class="line">&lt;__main__.ObjectCreator <span class="built_in">object</span> at <span class="number">0x8997b4c</span>&gt;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h2><p>因为类也是对象，所以和其他任何的对象一样，我们可以即时(on the fly)创建一个类。</p>
<p>比如，在函数中创建类</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">choose_class</span>(<span class="params">name</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> name == <span class="string">'foo'</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> Foo <span class="comment"># return the class, not an instance</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="class"><span class="keyword">class</span> <span class="title">Bar</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> Bar</span><br></pre></td></tr></tbody></table></figure>

<p>但它看起来没那么动态，因为我们仍然需要自己写完整个类的定义。既然类也是对象，那肯定有啥东西可以创建这个对象，这个东西是啥呢？是<code>type</code>！</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="built_in">type</span>(<span class="number">1</span>))</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">'int'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="built_in">type</span>(<span class="string">"1"</span>))</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="built_in">type</span>(ObjectCreator))</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="built_in">type</span>(ObjectCreator()))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">ObjectCreator</span>'&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>type</code>不仅可以告诉你一个对象的类型，也可以动态地创建一个类。type可以将一个类的描述当作参数传入并返回一个类。（为了向后兼容，type通过改变参数实现了两种完全不同的功能）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">type</span>(name, bases, attrs)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong><code>name</code></strong>: 类名</li>
<li><strong><code>bases</code></strong>: 父类元祖 (继承，可以为空)</li>
<li><strong><code>attrs</code></strong>: 字典</li>
</ul>
<p>比如以下两种创建类的方式就是等价的</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"><span class="meta">... </span>      bar = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">&lt;=&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo = <span class="built_in">type</span>(<span class="string">'Foo'</span>, (), {<span class="string">'bar'</span>:<span class="literal">True</span>})</span><br></pre></td></tr></tbody></table></figure>

<p>也可以使用继承</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>  <span class="class"><span class="keyword">class</span> <span class="title">FooChild</span>(<span class="params">Foo</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">&lt;=&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = <span class="built_in">type</span>(<span class="string">'FooChild'</span>, (Foo,), {})</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(FooChild)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">FooChild</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span>(<span class="params">FooChild.bar</span>) # <span class="title">bar</span> <span class="title">is</span> <span class="title">inherited</span> <span class="title">from</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>可以添加方法</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo_bar</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>      print(self.bar)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>FooChild = <span class="built_in">type</span>(<span class="string">'FooChild'</span>, (Foo,), {<span class="string">'echo_bar'</span>: echo_bar})</span><br></pre></td></tr></tbody></table></figure>

<p>这就是当我们使用<code>class</code>关键字时python做的事，这一切都是通过metaclass实现的。</p>
<h2 id="Metaclasses"><a href="#Metaclasses" class="headerlink" title="Metaclasses"></a>Metaclasses</h2><div class="note info"><p>👉🏿 metaclasses 是一些用来创建class的东西</p>
</div>


<p>我们定义class目的是创建对象，而class本身又是对象，metaclasses就是来创建class这个对象的，所以他们是class的类。</p>
<p>我们可以用下面的代码表示</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">MyClass = MetaClass()</span><br><span class="line">my_object = MyClass()</span><br></pre></td></tr></tbody></table></figure>

<p>还记得type可以创建一个类吗</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">MyClass = <span class="built_in">type</span>(<span class="string">'MyClass'</span>, (), {})</span><br></pre></td></tr></tbody></table></figure>

<p>这是因为实际上，type本身就是一个metaclass。</p>
<div class="note info"><p>👉🏿 <code>type</code>&nbsp;is the metaclass Python uses to create all classes behind the scenes.</p>
</div>

<p>就如同<code>str</code>创建string 对象，<code>int</code>创建integer对象，<code>type</code>就用来创建class对象</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>age = <span class="number">35</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">'int'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'bob'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">'function'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>(<span class="params"><span class="built_in">object</span></span>):</span> <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Bar()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Bar</span>'&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>那<code>__class__</code>的<code>__class__</code>是什么呢？</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>age.__class__.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.__class__.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__class__.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">'type'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.__class__.__class__</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">'type'</span>&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>因此，metaclass就是一个用来创建class对象的东西。而<code>type</code>是内置的metaclass，言外之意，我们还可以创建自己的metaclass</p>
<h2 id="metaclass"><a href="#metaclass" class="headerlink" title="__metaclass__"></a><code>__metaclass__</code></h2><p>在python2中，当我们写下一个类，我们可以加入<code>__metaclass__</code> 属性</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    __metaclass__ = something...</span><br><span class="line">    [...]</span><br></pre></td></tr></tbody></table></figure>

<p>首先我们敲下<code>class Foo(object)</code>,但此时<code>Foo</code>这个类对象没有立刻在内存中创建。</p>
<p>python会在类的定义中寻找<code>__metaclass__</code> 属性，如果有，就用<code>__metaclass__</code> 来创建<code>Foo</code>对象，否则就用<code>type</code>创建。</p>
<p>如果我们的类是这样的</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params">Bar</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果有<code>__metaclass__</code> ，就用它创建一个类对象Foo，如果找不到，python会在MODULE层找，并做同样的事情。（但要保证这个类对象没有继承任何东西）。如果还是找不到，就从<code>Bar</code>类中去寻找。</p>
<p>在python3中，设置metaclass的方式变了</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span>, metaclass=something</span>):</span></span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure>

<p>依然可以像这种方式给metaclass增加属性</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span>, metaclass=something, kwarg1=value1, kwarg2=value2</span>):</span></span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure>

<h2 id="自定义的metaclasses"><a href="#自定义的metaclasses" class="headerlink" title="自定义的metaclasses"></a>自定义的metaclasses</h2><p>假设我希望所有我定义的类中，所有的属性都要大写，这时就可以通过设置<code>__metaclass__</code>来实现。<code>__metaclass__</code> 形式上可以是任何可以被调用的东西。比如函数</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># the metaclass will automatically get passed the same argument</span></span><br><span class="line"><span class="comment"># that you usually pass to `type`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upper_attr</span>(<span class="params">future_class_name, future_class_parents, future_class_attrs</span>):</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">      Return a class object, with the list of its attribute turned</span></span><br><span class="line"><span class="string">      into uppercase.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># pick up any attribute that doesn't start with '__' and uppercase it</span></span><br><span class="line">    uppercase_attrs = {</span><br><span class="line">        attr <span class="keyword">if</span> attr.startswith(<span class="string">"__"</span>) <span class="keyword">else</span> attr.upper(): v</span><br><span class="line">        <span class="keyword">for</span> attr, v <span class="keyword">in</span> future_class_attrs.items()</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment"># let `type` do the class creation</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type</span>(future_class_name, future_class_parents, uppercase_attrs)</span><br><span class="line"></span><br><span class="line">__metaclass__ = upper_attr <span class="comment"># this will affect all classes in the module</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>():</span> <span class="comment"># global __metaclass__ won't work with "object" though</span></span><br><span class="line">    <span class="comment"># but we can define __metaclass__ here instead to affect only this class</span></span><br><span class="line">    <span class="comment"># and this will work with "object" children</span></span><br><span class="line">    bar = <span class="string">'bip'</span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(Foo, <span class="string">'bar'</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(Foo, <span class="string">'BAR'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Foo.BAR</span><br><span class="line"><span class="string">'bip'</span></span><br></pre></td></tr></tbody></table></figure>

<p>用类也可以完成同样的事情,这里<code>type</code> 就如同<code>int</code> 、<code>str</code> 当作父类被继承。<code>__new__</code> 在<code>__init__</code> 之前被调用，用于控制如何创建一个对象。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="comment"># remember that `type` is actually a class like `str` and `int`</span></span><br><span class="line"><span class="comment"># so you can inherit from it</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="comment"># __new__ is the method called before __init__</span></span><br><span class="line">    <span class="comment"># it's the method that creates the object and returns it</span></span><br><span class="line">    <span class="comment"># while __init__ just initializes the object passed as parameter</span></span><br><span class="line">    <span class="comment"># you rarely use __new__, except when you want to control how the object</span></span><br><span class="line">    <span class="comment"># is created.</span></span><br><span class="line">    <span class="comment"># here the created object is the class, and we want to customize it</span></span><br><span class="line">    <span class="comment"># so we override __new__</span></span><br><span class="line">    <span class="comment"># you can do some stuff in __init__ too if you wish</span></span><br><span class="line">    <span class="comment"># some advanced use involves overriding __call__ as well, but we won't</span></span><br><span class="line">    <span class="comment"># see this</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">upperattr_metaclass, future_class_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                future_class_parents, future_class_attrs</span>):</span></span><br><span class="line">        uppercase_attrs = {</span><br><span class="line">            attr <span class="keyword">if</span> attr.startswith(<span class="string">"__"</span>) <span class="keyword">else</span> attr.upper(): v</span><br><span class="line">            <span class="keyword">for</span> attr, v <span class="keyword">in</span> future_class_attrs.items()</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(future_class_name, future_class_parents, uppercase_attrs)</span><br></pre></td></tr></tbody></table></figure>

<p>接下来，然我们用更规范、更简短的方式重新写一下上面这个类</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, clsname, bases, attrs</span>):</span></span><br><span class="line">        uppercase_attrs = {</span><br><span class="line">            attr <span class="keyword">if</span> attr.startswith(<span class="string">"__"</span>) <span class="keyword">else</span> attr.upper(): v</span><br><span class="line">            <span class="keyword">for</span> attr, v <span class="keyword">in</span> attrs.items()</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(clsname, bases, uppercase_attrs)</span><br></pre></td></tr></tbody></table></figure>

<p>但这不是这正确的OOP，因为我们直接调用了<code>type</code> 没有重写或是调用父类的<code>__new__</code> ，让我们来修改一下</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, clsname, bases, attrs</span>):</span></span><br><span class="line">        uppercase_attrs = {</span><br><span class="line">            attr <span class="keyword">if</span> attr.startswith(<span class="string">"__"</span>) <span class="keyword">else</span> attr.upper(): v</span><br><span class="line">            <span class="keyword">for</span> attr, v <span class="keyword">in</span> attrs.items()</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, clsname, bases, uppercase_attrs)</span><br></pre></td></tr></tbody></table></figure>

<p>还可以用super，这样更加简洁，也更加容易继承。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpperAttrMetaclass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, clsname, bases, attrs</span>):</span></span><br><span class="line">        uppercase_attrs = {</span><br><span class="line">            attr <span class="keyword">if</span> attr.startswith(<span class="string">"__"</span>) <span class="keyword">else</span> attr.upper(): v</span><br><span class="line">            <span class="keyword">for</span> attr, v <span class="keyword">in</span> attrs.items()</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(UpperAttrMetaclass, cls).__new__(</span><br><span class="line">            cls, clsname, bases, uppercase_attrs)</span><br></pre></td></tr></tbody></table></figure>

<p>对了，还有一点，如果python3中这样定义metaclass</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span>, metaclass=MyMetaclass, kwarg1=value1</span>):</span></span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure>

<p><code>kwarg1</code> 参数会被传入到<code>Mymetaclass</code> 中</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMetaclass</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, clsname, bases, dct, kwargs1=default</span>):</span></span><br><span class="line">        ...</span><br></pre></td></tr></tbody></table></figure>

<p>以上就是对metaclass的所有介绍了。其实metaclass本身并不复杂，由于metaclass经常被用于完成一些复杂、黑魔法的工作，所以让人觉得很晦涩难懂。但metaclass本身其实很简单</p>
<ul>
<li>拦截类的创建</li>
<li>修改一个类</li>
<li>返回修改后的类</li>
</ul>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>OC高级编程|内存管理和自动引用计数器</title>
    <url>/post/1238a258/</url>
    <content><![CDATA[<h1 id="自动引用计数器"><a href="#自动引用计数器" class="headerlink" title="自动引用计数器"></a>自动引用计数器</h1><blockquote>
<p>在LLVM编译器中设置ARC为有效状态，就无需再次键入retain或者是release代码了</p>
</blockquote>
<h2 id="内存管理和引用计数"><a href="#内存管理和引用计数" class="headerlink" title="内存管理和引用计数"></a>内存管理和引用计数</h2><p>这里用开灯和关灯与解释对象的引用</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317792.png" alt="Untitled"></p>
<p>没有人进入的时候，会议室关灯，引用数为0。反过来，所有的人都离开后，引用数为0，会议室关灯。</p>
<p>这里强调了内存管理的思考方式</p>
<ul>
<li>自己生成的对象，自己所持有<ul>
<li>生成并持有：alloc、new、copy、mutableCopy</li>
</ul>
</li>
<li>非自己生成的对象，自己也能持有<ul>
<li>持有：retain</li>
</ul>
</li>
<li>不再需要自己持有的对象时释放<ul>
<li>释放：release</li>
<li>废弃：dealloc</li>
</ul>
</li>
<li>非自己持有的对象无法释放</li>
</ul>
<p>这些方法不包括在OC这门语言中，而是包含在Cocoa框架中。Foundation框架类库的NSObject类担任内存管理的职责</p>
<p>上述的alloc、retain等方法分别指代NSObject类的 alloc类方法、retain实例方法、release实例方法、dealloc实例方法</p>
<h3 id="自己生成的对象，自己所持有"><a href="#自己生成的对象，自己所持有" class="headerlink" title="自己生成的对象，自己所持有"></a>自己生成的对象，自己所持有</h3><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">id obj = [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">id obj = [<span class="type">NSObject</span> new];</span><br><span class="line">copy 和 mutableCopy</span><br></pre></td></tr></tbody></table></figure>

<h3 id="非自己生成的对象，自己也能持有"><a href="#非自己生成的对象，自己也能持有" class="headerlink" title="非自己生成的对象，自己也能持有"></a>非自己生成的对象，自己也能持有</h3><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// NSMutableArray类对象被赋给变量obj，但变量obj自己并不持有该对象。</span></span><br><span class="line">id obj = [<span class="type">NSMutableArray</span> array];</span><br></pre></td></tr></tbody></table></figure>

<p>注意，上面这个对象非自己生成，可以获取这个对象，但不持有这个对象</p>
<p>使用retain方法可以持有对象</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">[obj retain];</span><br></pre></td></tr></tbody></table></figure>

<p>使用retain方法，非自己生成的对象跟用alloc或者new等方法生成并持有的对象一样，成为了自己所持有的。</p>
<h3 id="持有者有义务释放持有的对象"><a href="#持有者有义务释放持有的对象" class="headerlink" title="持有者有义务释放持有的对象"></a>持有者有义务释放持有的对象</h3><p>自己持有的对象，一旦不再需要，就需要使用release释放。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">id obj = [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>]; <span class="comment">// 自己生成，自己持有</span></span><br><span class="line">[obj release]; <span class="comment">// 释放自己持有的对象</span></span><br><span class="line"></span><br><span class="line">id obj = [<span class="type">NSMutableArray</span> array]; <span class="comment">// 非自己生成</span></span><br><span class="line">[obj retain]; <span class="comment">// 但是可以持有</span></span><br><span class="line">[obj release]; <span class="comment">// 释放自己持有的对象</span></span><br></pre></td></tr></tbody></table></figure>

<p>总之，用alloc方法由自己生成并持有的对象可以通过release方法释放。自己生成而非自己所持有用retain后可以持有，用release方法释放。</p>
<h3 id="如果对象是通过一个函数生成的怎么办"><a href="#如果对象是通过一个函数生成的怎么办" class="headerlink" title="如果对象是通过一个函数生成的怎么办"></a>如果对象是通过一个函数生成的怎么办</h3><p>首先要规定命名规则</p>
<ul>
<li><p>自己生成并持有</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317837.png" alt="Untitled"></p>
</li>
<li><p>非自己生成，不持有</p>
<ul>
<li>allocate</li>
<li>newer</li>
<li>copying</li>
<li>mutableCopy</li>
</ul>
</li>
</ul>
<p>比如下面这个函数</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 自己生成并持有</span></span><br><span class="line">- （id) allocObject</span><br><span class="line">{</span><br><span class="line">	id obj = [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">}</span><br><span class="line">id obj1 = [obj0 allocObject];</span><br></pre></td></tr></tbody></table></figure>

<p>[NSMutableArray array] 是生成对象但是自己不持有，这是怎么实现的呢？</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">- (id)object</span><br><span class="line">{</span><br><span class="line">	id obj = [[<span class="type">NSObject</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">	[obj autorelease];</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">id obj1 = [obj0 object]; <span class="comment">// 生成一个对象，但自己不持有</span></span><br><span class="line">[obj1 retain]; <span class="comment">// 持有这个对象</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>autorelease方法可以使得取得的对象存在，但自己不持有对象。</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317853.png" alt="Untitled"></p>
<p>[NSMutableArray array] 可以获得谁都不持有的对象，这是通过autorelease实现的。</p>
<h3 id="释放自己不持有的对象会怎么样"><a href="#释放自己不持有的对象会怎么样" class="headerlink" title="释放自己不持有的对象会怎么样"></a>释放自己不持有的对象会怎么样</h3><p>会崩溃！</p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>对于引用计数的思考方式，主要就是考虑两点</p>
<ul>
<li>自己生成，自己持有，这是由四个函数做到的</li>
<li>非自己生成，可以获取，但自己不持有，用reatain可以持有</li>
</ul>
<p>用完了要用release释放，如果没有持有直接释放，会崩溃！</p>
<p>这里用两个例子再加深下印象。在没有ARC的大前提下，首先obj先去引用一个非自己生成对象，在没有使用retain的情况下引用计数显示的是1，这个很好理解因为默认会+1，但如果尝试去release就会报错，因为obj这个对象并没有被持有。此外array方法返回的对象会被放入autoreleasepool中。</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317868.png" alt="Untitled"></p>
<p>但如果使用的是new，obj引用了一个自已生成自己持有的对象，虽然引用计数器也是1，但它是可以释放的。</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317883.png" alt="Untitled"></p>
<h2 id="alloc、retain、release、dealloc是怎么实现的"><a href="#alloc、retain、release、dealloc是怎么实现的" class="headerlink" title="alloc、retain、release、dealloc是怎么实现的"></a>alloc、retain、release、dealloc是怎么实现的</h2><p>说明：NSObject类的源码并没有公开，文章这里使用GNUstep开源软件来说明。它是Cocoa框架的互换框架</p>
<aside>
🤔 能不能补充下Cocoa、GNUstep、Core Foundation等的区别呢


</aside>

<h3 id="alloc"><a href="#alloc" class="headerlink" title="alloc"></a>alloc</h3><p>alloc总体看来就是给对象的实例分配内存空间，然后返回指向这片空间的指针。</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocates a new instance of the receiver from the default</span></span><br><span class="line"><span class="comment"> * zone, by invoking +allocWithZone: with</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;NSDefaultMallocZone()&lt;/code&gt; as the zone argument.&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> * Returns the created instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">id</span>) alloc</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> allocWithZone: <span class="built_in">NSDefaultMallocZone</span>()];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is the basic method to create a new instance.  It</span></span><br><span class="line"><span class="comment"> * allocates a new instance of the receiver from the specified</span></span><br><span class="line"><span class="comment"> * memory zone.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *   Memory for an instance of the receiver is allocated; a</span></span><br><span class="line"><span class="comment"> *   pointer to this newly created instance is returned.  All</span></span><br><span class="line"><span class="comment"> *   instance variables are set to 0.  No initialization of the</span></span><br><span class="line"><span class="comment"> *   instance is performed apart from setup to be an instance of</span></span><br><span class="line"><span class="comment"> *   the correct class: it is your responsibility to initialize the</span></span><br><span class="line"><span class="comment"> *   instance by calling an appropriate &lt;code&gt;init&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> *   method.  If you are not using ARC, it is</span></span><br><span class="line"><span class="comment"> *   also your responsibility to make sure the returned</span></span><br><span class="line"><span class="comment"> *   instance is destroyed when you finish using it, by calling</span></span><br><span class="line"><span class="comment"> *   the &lt;code&gt;release&lt;/code&gt; method to destroy the instance</span></span><br><span class="line"><span class="comment"> *   directly, or by using &lt;code&gt;autorelease&lt;/code&gt; and</span></span><br><span class="line"><span class="comment"> *   autorelease pools.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *  You do not normally need to override this method in</span></span><br><span class="line"><span class="comment"> *  subclasses, unless you are implementing a class which for</span></span><br><span class="line"><span class="comment"> *  some reasons silently allocates instances of another class</span></span><br><span class="line"><span class="comment"> *  (this is typically needed to implement class clusters and</span></span><br><span class="line"><span class="comment"> *  similar design schemes).</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *   If you have turned on debugging of object allocation (by</span></span><br><span class="line"><span class="comment"> *   calling the &lt;code&gt;GSDebugAllocationActive&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> *   function), this method will also update the various</span></span><br><span class="line"><span class="comment"> *   debugging counts and monitors of allocated objects, which</span></span><br><span class="line"><span class="comment"> *   you can access using the &lt;code&gt;GSDebugAllocation...&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> *   functions.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">id</span>) allocWithZone: (<span class="built_in">NSZone</span>*)z</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NSAllocateObject</span>(<span class="keyword">self</span>, <span class="number">0</span>, z);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Now do the REAL version - using the other version to determine</span></span><br><span class="line"><span class="comment"> *	what padding (if any) is required to get the alignment of the</span></span><br><span class="line"><span class="comment"> *	structure correct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> obj_layout {</span><br><span class="line">    <span class="built_in">NSUInteger</span>	retained;</span><br><span class="line">    <span class="built_in">NSZone</span>	*zone;</span><br><span class="line">    <span class="keyword">char</span>	padding[ALIGN - ((UNP % ALIGN) ? (UNP % ALIGN) : ALIGN)];</span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span>	<span class="keyword">struct</span> obj_layout *obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Now do conditional compilation of memory allocation functions</span></span><br><span class="line"><span class="comment"> *	depending on what information (if any) we are storing before</span></span><br><span class="line"><span class="comment"> *	the start of each object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FIXME rewrite object allocation to use class_createInstance when we</span></span><br><span class="line"><span class="comment">// are using libobjc2.</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">id</span></span><br><span class="line"><span class="built_in">NSAllocateObject</span>(Class aClass, <span class="built_in">NSUInteger</span> extraBytes, <span class="built_in">NSZone</span> *zone)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">id</span>	new;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OBJC_CAP_ARC</span></span><br><span class="line">  <span class="keyword">if</span> ((new = class_createInstance(aClass, extraBytes)) != <span class="literal">nil</span>)</span><br><span class="line">    {</span><br><span class="line">      AADD(aClass, new);</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span>	size; <span class="comment">// 容纳对象所需要的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSCAssert</span>((!class_isMetaClass(aClass)), <span class="string">@"Bad class for new object"</span>);</span><br><span class="line">	<span class="comment">// 计算容纳对象所需要的大小</span></span><br><span class="line">  <span class="comment">// 实例的大小由三部分构成，类本身的大小、额外的大小、保存引用计数结构体的大小  </span></span><br><span class="line">  size = class_getInstanceSize(aClass) + extraBytes + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> obj_layout);</span><br><span class="line">  <span class="keyword">if</span> (zone == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      zone = <span class="built_in">NSDefaultMallocZone</span>();</span><br><span class="line">    }</span><br><span class="line">  <span class="comment">// 调用函数，分配存放对象所需的空间</span></span><br><span class="line">  new = <span class="built_in">NSZoneMalloc</span>(zone, size);</span><br><span class="line">  <span class="keyword">if</span> (new != <span class="literal">nil</span>)</span><br><span class="line">    {</span><br><span class="line">			<span class="comment">// 将该内存空间全部置为0</span></span><br><span class="line">      memset (new, <span class="number">0</span>, size);</span><br><span class="line">      new = (<span class="keyword">id</span>)&amp;((obj)new)[<span class="number">1</span>];</span><br><span class="line">      object_setClass(new, aClass);</span><br><span class="line">      AADD(aClass, new);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don't bother doing this in a thread-safe way, because the cost of locking</span></span><br><span class="line"><span class="comment">   * will be a lot more than the cost of doing the same call in two threads.</span></span><br><span class="line"><span class="comment">   * The returned selector will persist and the runtime will ensure that both</span></span><br><span class="line"><span class="comment">   * calls return the same selector, so we don't need to bother doing it</span></span><br><span class="line"><span class="comment">   * ourselves.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == cxx_construct)</span><br><span class="line">    {</span><br><span class="line">      cxx_construct = sel_registerName(<span class="string">".cxx_construct"</span>);</span><br><span class="line">      cxx_destruct = sel_registerName(<span class="string">".cxx_destruct"</span>);</span><br><span class="line">    }</span><br><span class="line">  callCXXConstructors(aClass, new);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> new;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>源码中出现了很多Zone的字眼，这是为了防止内存碎片化引入的结构。下图把内存分为两个区域，小容量分配到左侧区域，大容量分配到右侧区域。</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317896.png" alt="Untitled"></p>
<p>obj_layout中的retained用来保存引用计数，会写入对象内存的头部。</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317910.png" alt="Untitled"></p>
<p>如何获得当前对象的引用计数呢？</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">[obj retainCount];</span><br></pre></td></tr></tbody></table></figure>

<p>在源码中提到如果一个对象永远不会被废弃，会返回一个最大值。提到每个实例都会有一个隐式的调用，即使用retainCount会在retained值的基础上+1</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the reference count for the receiver.  Each instance has an</span></span><br><span class="line"><span class="comment"> * implicit reference count of 1, and has an 'extra reference count'</span></span><br><span class="line"><span class="comment"> * returned by the NSExtraRefCount() function, so the value returned by</span></span><br><span class="line"><span class="comment"> * this method is always greater than zero.&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> * By convention, objects which should (or can) never be deallocated</span></span><br><span class="line"><span class="comment"> * return the maximum unsigned integer value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>) retainCount</span><br><span class="line">{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>	GS_WITH_GC</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">UINT_MAX</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NSExtraRefCount</span>(<span class="keyword">self</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the extra reference count of anObject (a value in the range</span></span><br><span class="line"><span class="comment"> * from 0 to the maximum unsigned integer value minus one).&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> * The retain count for an object is this value plus one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">NSUInteger</span></span><br><span class="line"><span class="built_in">NSExtraRefCount</span>(<span class="keyword">id</span> anObject)</span><br><span class="line">{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>	GS_WITH_GC</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">UINT_MAX</span> - <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>	<span class="comment">/* GS_WITH_GC */</span></span></span><br><span class="line">  <span class="keyword">return</span> ((obj)anObject)[<span class="number">-1</span>].retained;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GS_WITH_GC */</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img data-src="https://qiniu.dcts.top/typora/202303140317925.png" alt="Untitled"></p>
<p>retain实例方法可以使得retained变量+1。源码中提到了如果持有的引用太大了，超过16777214这么多，会报错。但核心代码就一句话<code>((obj)anObject)[-1].retained++;</code></p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increments the reference count and returns the receiver.&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> * The default implementation does this by calling NSIncrementExtraRefCount()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">id</span>) <span class="keyword">retain</span></span><br><span class="line">{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>	GS_WITH_GC == 0</span></span><br><span class="line">  <span class="built_in">NSIncrementExtraRefCount</span>(<span class="keyword">self</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increments the extra reference count for anObject.&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> * The GNUstep version raises an exception if the reference count</span></span><br><span class="line"><span class="comment"> * would be incremented to too large a value.&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> * This is used by the [NSObject-retain] method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line"><span class="built_in">NSIncrementExtraRefCount</span>(<span class="keyword">id</span> anObject)</span><br><span class="line">{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>	GS_WITH_GC</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>	<span class="comment">/* GS_WITH_GC */</span></span></span><br><span class="line">  <span class="keyword">if</span> (allocationLock != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>	defined(GSATOMICREAD)</span></span><br><span class="line">      <span class="comment">/* I've seen comments saying that some platforms only support up to</span></span><br><span class="line"><span class="comment">       * 24 bits in atomic locking, so raise an exception if we try to</span></span><br><span class="line"><span class="comment">       * go beyond 0xfffffe.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (GSAtomicIncrement((gsatomic_t)&amp;(((obj)anObject)[<span class="number">-1</span>].retained))</span><br><span class="line">        &gt; <span class="number">0xfffffe</span>)</span><br><span class="line">	{</span><br><span class="line">	  [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">	    format: <span class="string">@"NSIncrementExtraRefCount() asked to increment too far"</span>];</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>	<span class="comment">/* GSATOMICREAD */</span></span></span><br><span class="line">      <span class="built_in">NSLock</span> *theLock = GSAllocationLockForObject(anObject);</span><br><span class="line"></span><br><span class="line">      [theLock lock];</span><br><span class="line">      <span class="keyword">if</span> (((obj)anObject)[<span class="number">-1</span>].retained == <span class="built_in">UINT_MAX</span> - <span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">	  [theLock unlock];</span><br><span class="line">	  [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">	    format: <span class="string">@"NSIncrementExtraRefCount() asked to increment too far"</span>];</span><br><span class="line">	}</span><br><span class="line">      ((obj)anObject)[<span class="number">-1</span>].retained++;</span><br><span class="line">      [theLock unlock];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	<span class="comment">/* GSATOMICREAD */</span></span></span><br><span class="line">    }</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span> (((obj)anObject)[<span class="number">-1</span>].retained == <span class="built_in">UINT_MAX</span> - <span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">	  [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">	    format: <span class="string">@"NSIncrementExtraRefCount() asked to increment too far"</span>];</span><br><span class="line">	}</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decrements the retain count for the receiver if greater than zero,</span></span><br><span class="line"><span class="comment"> * otherwise calls the dealloc method instead.&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> * The default implementation calls the NSDecrementExtraRefCountWasZero()</span></span><br><span class="line"><span class="comment"> * function to test the extra reference count for the receiver (and</span></span><br><span class="line"><span class="comment"> * decrement it if non-zero) - if the extra reference count is zero then</span></span><br><span class="line"><span class="comment"> * the retain count is one, and the dealloc method is called.&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> * In GNUstep, the [NSObject+enableDoubleReleaseCheck:] method may be used</span></span><br><span class="line"><span class="comment"> * to turn on checking for ratain/release errors in this method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>) release</span><br><span class="line">{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>	GS_WITH_GC == 0</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">self</span>))</span><br><span class="line">    {</span><br><span class="line">      [<span class="keyword">self</span> dealloc];</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">}</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	<span class="comment">/* GS_WITH_GC */</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>release实例方法可以使得retained变量-1。当retained变量大于0时减1，等于0时调用的dealloc实例方法，废弃对象</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decrements the retain count for the receiver if greater than zero,</span></span><br><span class="line"><span class="comment"> * otherwise calls the dealloc method instead.&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> * The default implementation calls the NSDecrementExtraRefCountWasZero()</span></span><br><span class="line"><span class="comment"> * function to test the extra reference count for the receiver (and</span></span><br><span class="line"><span class="comment"> * decrement it if non-zero) - if the extra reference count is zero then</span></span><br><span class="line"><span class="comment"> * the retain count is one, and the dealloc method is called.&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> * In GNUstep, the [NSObject+enableDoubleReleaseCheck:] method may be used</span></span><br><span class="line"><span class="comment"> * to turn on checking for ratain/release errors in this method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>) release</span><br><span class="line">{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>	GS_WITH_GC == 0</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">self</span>))</span><br><span class="line">    {</span><br><span class="line">      [<span class="keyword">self</span> dealloc];</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Examines the extra reference count for the object and, if non-zero</span></span><br><span class="line"><span class="comment"> * decrements it, otherwise leaves it unchanged.&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> * Returns a flag to say whether the count was zero</span></span><br><span class="line"><span class="comment"> * (and hence whether the extra reference count was decremented).&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> * This function is used by the [NSObject-release] method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">BOOL</span></span><br><span class="line"><span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">id</span> anObject)</span><br><span class="line">{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>	!GS_WITH_GC</span></span><br><span class="line">  <span class="keyword">if</span> (double_release_check_enabled)</span><br><span class="line">    {</span><br><span class="line">      <span class="built_in">NSUInteger</span> release_count;</span><br><span class="line">      <span class="built_in">NSUInteger</span> retain_count = [anObject retainCount];</span><br><span class="line">      release_count = [autorelease_class autoreleaseCountForObject: anObject];</span><br><span class="line">      <span class="keyword">if</span> (release_count &gt;= retain_count)</span><br><span class="line">        [<span class="built_in">NSException</span> raise: <span class="built_in">NSGenericException</span></span><br><span class="line">		    format: <span class="string">@"Release would release object too many times."</span>];</span><br><span class="line">    }</span><br><span class="line">  <span class="keyword">if</span> (allocationLock != <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>	defined(GSATOMICREAD)</span></span><br><span class="line">      <span class="keyword">int</span>	result;</span><br><span class="line"></span><br><span class="line">      result = GSAtomicDecrement((gsatomic_t)&amp;(((obj)anObject)[<span class="number">-1</span>].retained));</span><br><span class="line">      <span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">	  <span class="keyword">if</span> (result != <span class="number">-1</span>)</span><br><span class="line">	    {</span><br><span class="line">	      [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">		format: <span class="string">@"NSDecrementExtraRefCount() decremented too far"</span>];</span><br><span class="line">	    }</span><br><span class="line">	  <span class="comment">/* The counter has become negative so it must have been zero.</span></span><br><span class="line"><span class="comment">	   * We reset it and return YES ... in a correctly operating</span></span><br><span class="line"><span class="comment">	   * process we know we can safely reset back to zero without</span></span><br><span class="line"><span class="comment">	   * worrying about atomicity, since there can be no other</span></span><br><span class="line"><span class="comment">	   * thread accessing the object (or its reference count would</span></span><br><span class="line"><span class="comment">	   * have been greater than zero)</span></span><br><span class="line"><span class="comment">	   */</span></span><br><span class="line">	  (((obj)anObject)[<span class="number">-1</span>].retained) = <span class="number">0</span>;</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>	<span class="comment">/* GSATOMICREAD */</span></span></span><br><span class="line">      <span class="built_in">NSLock</span> *theLock = GSAllocationLockForObject(anObject);</span><br><span class="line"></span><br><span class="line">      [theLock lock];</span><br><span class="line"><span class="comment">// 这里其实有点巧妙的，并不是先--，而是先判断是不是为0</span></span><br><span class="line">      <span class="keyword">if</span> (((obj)anObject)[<span class="number">-1</span>].retained == <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">	  [theLock unlock];</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">	}</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">	  ((obj)anObject)[<span class="number">-1</span>].retained--;</span><br><span class="line">	  [theLock unlock];</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	<span class="comment">/* GSATOMICREAD */</span></span></span><br><span class="line">    }</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span> (((obj)anObject)[<span class="number">-1</span>].retained == <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">	}</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">	  ((obj)anObject)[<span class="number">-1</span>].retained--;</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">	}</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !GS_WITH_GC */</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>看下如何废弃对象</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Deallocates the receiver by calling NSDeallocateObject() with self</span></span><br><span class="line"><span class="comment"> * as the argument.&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *   You should normally call the superclass implementation of this method</span></span><br><span class="line"><span class="comment"> *   when you override it in a subclass, or the memory occupied by your</span></span><br><span class="line"><span class="comment"> *   object will not be released.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;code&gt;NSObject&lt;/code&gt;'s implementation of this method</span></span><br><span class="line"><span class="comment"> *   destroys the receiver, by returning the memory allocated</span></span><br><span class="line"><span class="comment"> *   to the receiver to the system.  After this method has been</span></span><br><span class="line"><span class="comment"> *   called on an instance, you must not refer the instance in</span></span><br><span class="line"><span class="comment"> *   any way, because it does not exist any longer.  If you do,</span></span><br><span class="line"><span class="comment"> *   it is a bug and your program might even crash with a</span></span><br><span class="line"><span class="comment"> *   segmentation fault.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *   Normally you are supposed to manage the memory taken by</span></span><br><span class="line"><span class="comment"> *   objects by using the high level interface provided by the</span></span><br><span class="line"><span class="comment"> *   &lt;code&gt;retain&lt;/code&gt;, &lt;code&gt;release&lt;/code&gt; and</span></span><br><span class="line"><span class="comment"> *   &lt;code&gt;autorelease&lt;/code&gt; methods (or better by the</span></span><br><span class="line"><span class="comment"> *   corresponding macros &lt;code&gt;RETAIN&lt;/code&gt;,</span></span><br><span class="line"><span class="comment"> *   &lt;code&gt;RELEASE&lt;/code&gt; and &lt;code&gt;AUTORELEASE&lt;/code&gt;), and by</span></span><br><span class="line"><span class="comment"> *   autorelease pools and such; whenever the</span></span><br><span class="line"><span class="comment"> *   release/autorelease mechanism determines that an object is</span></span><br><span class="line"><span class="comment"> *   no longer needed (which happens when its retain count</span></span><br><span class="line"><span class="comment"> *   reaches 0), it will call the &lt;code&gt;dealloc&lt;/code&gt; method</span></span><br><span class="line"><span class="comment"> *   to actually deallocate the object.  This means that normally,</span></span><br><span class="line"><span class="comment"> *   you should not need to call &lt;code&gt;dealloc&lt;/code&gt; directly as</span></span><br><span class="line"><span class="comment"> *   the gnustep base library automatically calls it for you when</span></span><br><span class="line"><span class="comment"> *   the retain count of an object reaches 0.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *   Because the &lt;code&gt;dealloc&lt;/code&gt; method will be called</span></span><br><span class="line"><span class="comment"> *   when an instance is being destroyed, if instances of your</span></span><br><span class="line"><span class="comment"> *   subclass use objects or resources (as it happens for most</span></span><br><span class="line"><span class="comment"> *   useful classes), you must override &lt;code&gt;dealloc&lt;/code&gt; in</span></span><br><span class="line"><span class="comment"> *   subclasses to release all objects and resources which are</span></span><br><span class="line"><span class="comment"> *   used by the instance, otherwise these objects and</span></span><br><span class="line"><span class="comment"> *   resources would be leaked.  In the subclass</span></span><br><span class="line"><span class="comment"> *   implementation, you should first release all your subclass</span></span><br><span class="line"><span class="comment"> *   specific objects and resources, and then invoke super's</span></span><br><span class="line"><span class="comment"> *   implementation (which will do the same, and so on up in</span></span><br><span class="line"><span class="comment"> *   the class hierarchy to &lt;code&gt;NSObject&lt;/code&gt;'s</span></span><br><span class="line"><span class="comment"> *   implementation, which finally destroys the object).  Here</span></span><br><span class="line"><span class="comment"> *   is an example of the implementation of</span></span><br><span class="line"><span class="comment"> *   &lt;code&gt;dealloc&lt;/code&gt; for a subclass whose instances have a</span></span><br><span class="line"><span class="comment"> *   single instance variable &lt;code&gt;name&lt;/code&gt; which needs to</span></span><br><span class="line"><span class="comment"> *   be released when an instance is deallocated:</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;code&gt;</span></span><br><span class="line"><span class="comment"> *   - (void) dealloc</span></span><br><span class="line"><span class="comment"> *   {</span></span><br><span class="line"><span class="comment"> *     RELEASE (name);</span></span><br><span class="line"><span class="comment"> *     [super dealloc];</span></span><br><span class="line"><span class="comment"> *   }</span></span><br><span class="line"><span class="comment"> *   &lt;/code&gt;</span></span><br><span class="line"><span class="comment"> *  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *  &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *    &lt;code&gt;dealloc&lt;/code&gt; might contain code to release not</span></span><br><span class="line"><span class="comment"> *    only objects, but also other resources, such as open</span></span><br><span class="line"><span class="comment"> *    files, network connections, raw memory allocated in other</span></span><br><span class="line"><span class="comment"> *    ways, etc.</span></span><br><span class="line"><span class="comment"> *  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *   If you have allocated the memory using a non-standard mechanism, you</span></span><br><span class="line"><span class="comment"> *   will not call the superclass (NSObject) implementation of the method</span></span><br><span class="line"><span class="comment"> *   as you will need to handle the deallocation specially.&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> *   In some circumstances, an object may wish to prevent itself from</span></span><br><span class="line"><span class="comment"> *   being deallocated, it can do this simply be refraining from calling</span></span><br><span class="line"><span class="comment"> *   the superclass implementation.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>) dealloc</span><br><span class="line">{</span><br><span class="line">  <span class="built_in">NSDeallocateObject</span>(<span class="keyword">self</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line"><span class="built_in">NSDeallocateObject</span>(<span class="keyword">id</span> anObject)</span><br><span class="line">{</span><br><span class="line">		<span class="comment">// 核心代码</span></span><br><span class="line">		obj	o = &amp;((obj)anObject)[<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">NSZone</span>	*z = <span class="built_in">NSZoneFromPointer</span>(o);</span><br><span class="line">		<span class="built_in">NSZoneFree</span>(z, o);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>GNUstep是如何实现这四个函数的</p>
<ul>
<li>alloc：计算对象的size，包括三个部分。memset分配内存，全部置为0;</li>
<li>retain：引用计数+1<ul>
<li>retainCount 的值是引用计数器的值 + 1，因此alloc后 retainCount的值为1</li>
</ul>
</li>
<li>release：引用计数器的值减一<ul>
<li>如果在retained值为0的时候调用了release，说明retainCount的值变为零了，说明要废弃这个对象</li>
</ul>
</li>
<li>dealloc：引用计数器为0时，废弃对象，释放内存。</li>
</ul>
<h3 id="苹果的实现"><a href="#苹果的实现" class="headerlink" title="苹果的实现"></a>苹果的实现</h3><ul>
<li>alloc<ul>
<li>allocWithZone</li>
<li>class_createInstance</li>
<li>calloc</li>
</ul>
</li>
</ul>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317938.png" alt="Untitled"></p>
<p>GNUstep是把引用计数放在对象占用内存块的头部，苹果则保存在一个哈希表中。</p>
<p>这个哈希表叫做引用计数表，记录着某个对象的所有引用记录，此外还存有内存块地址，可以追溯引用者的内存块。</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317949.png" alt="Untitled"></p>
<h3 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h3><p>c语言的自动变量：</p>
<p><a href="https://zh.m.wikipedia.org/zh-hans/%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F">自动变量 - 维基百科，自由的百科全书</a></p>
<p>具体来说即是在<a href="https://zh.m.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E6%B5%81">控制流</a>进入变量作用域时系统自动为其<a href="https://zh.m.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">分配存储空间</a>，并在离开作用域时释放空间的一类变量</p>
<p>autorelease会像C语言的自动变量那样来对待对象实例。当超出作用域时，对象实例的release实例方法被调用。下图展示了autorelease的使用方法</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317960.png" alt="Untitled"></p>
<p>把NSAutoreleasePool对象的生存周期当做C语言的作用域去理解。当obj调用autorelease方法时，就好像是在这个作用域里声明了一个变量。pool 调用drain方法，好像是变量离开了作用域范围，废弃了NSAutoreleasePool这个对象，这时obj的release方法会被自动调用</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317974.png" alt="Untitled"></p>
<p>NSRunLoop内部处理了NSAutoreleasePool的生成、持有和废弃</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317994.png" alt="Untitled"></p>
<p>Cocoa框架中很多类方法会返回autorelease对象。下面两行代码等价。</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> array = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">1</span>];</span><br><span class="line"><span class="keyword">id</span> array2 = [[[<span class="built_in">NSMutableArray</span> alloc]initWithCapacity:<span class="number">1</span>]autorelease];</span><br></pre></td></tr></tbody></table></figure>

<h3 id="autorelease的实现"><a href="#autorelease的实现" class="headerlink" title="autorelease的实现"></a>autorelease的实现</h3><p>当一个对象obj调用autorelease： [obj autorelease]; 可以看到首先会调用NSAutoreleasePool的类方法addObject，去找到当前正在使用的pool对象，然后add这个obj，GNUstep用的是链表。</p>
<p>总之，[obj autorelease]会把obj放到一个链表里。</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds the receiver to the current autorelease pool, so that it will be</span></span><br><span class="line"><span class="comment"> * sent a -release message when the pool is destroyed.&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> * Returns the receiver.&lt;br /&gt;</span></span><br><span class="line"><span class="comment"> * In GNUstep, the [NSObject+enableDoubleReleaseCheck:] method may be used</span></span><br><span class="line"><span class="comment"> * to turn on checking for retain/release errors in this method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">id</span>) autorelease</span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 下面这行代码等价于 [NSAutoreleasePool addObject:self];</span></span><br><span class="line">	<span class="comment">// GNUstep为了提高频繁调用autorelease方法的效率，对一些结果值进行了缓存</span></span><br><span class="line">	<span class="comment">// 这里的调用直接使用的是缓存的结果，总之提高了2倍的运行速度</span></span><br><span class="line">  (*autorelease_imp)(autorelease_class, autorelease_sel, <span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>关于[NSAutoreleasePool addObject:self]</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 类方法</span></span><br><span class="line">+ (<span class="keyword">void</span>) addObject: (<span class="keyword">id</span>)anObj</span><br><span class="line">{</span><br><span class="line">  <span class="built_in">NSThread</span>		*t = GSCurrentThread();</span><br><span class="line">  <span class="built_in">NSAutoreleasePool</span>	*pool;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取得正在使用的NSAutoreleasePool</span></span><br><span class="line">	<span class="comment">// NSAutoreleasePool对象可以嵌套生成，这里会理所当然地获取最里面一层的对象</span></span><br><span class="line">  pool = t-&gt;_autorelease_vars.current_pool;</span><br><span class="line">  <span class="keyword">if</span> (pool == <span class="literal">nil</span> &amp;&amp; t-&gt;_active == <span class="literal">NO</span>)</span><br><span class="line">    {</span><br><span class="line">      <span class="comment">// Don't leak while exiting thread.</span></span><br><span class="line">      pool = t-&gt;_autorelease_vars.current_pool = [<span class="keyword">self</span> new];</span><br><span class="line">    }</span><br><span class="line">  <span class="keyword">if</span> (pool != <span class="literal">nil</span>)</span><br><span class="line">    {</span><br><span class="line">			<span class="comment">// 调用正在使用的NSAutoreleasePool对象的addObject方法</span></span><br><span class="line">      (*pool-&gt;_addImp)(pool, <span class="keyword">@selector</span>(addObject:), anObj);</span><br><span class="line">    }</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      <span class="built_in">NSAutoreleasePool</span>	*arp = [<span class="built_in">NSAutoreleasePool</span> new];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (anObj != <span class="literal">nil</span>)</span><br><span class="line">	{</span><br><span class="line">	  <span class="built_in">NSLog</span>(<span class="string">@"autorelease called without pool for object (%p) "</span></span><br><span class="line">	    <span class="string">@"of class %@ in thread %@"</span>, anObj,</span><br><span class="line">	    <span class="built_in">NSStringFromClass</span>([anObj <span class="keyword">class</span>]), [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">	}</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">	  <span class="built_in">NSLog</span>(<span class="string">@"autorelease called without pool for nil object."</span>);</span><br><span class="line">	}</span><br><span class="line">      [arp release];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>关于drain</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) drain</span><br><span class="line">{</span><br><span class="line">  [<span class="keyword">self</span> release];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>) release</span><br><span class="line">{</span><br><span class="line">  [<span class="keyword">self</span> dealloc];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) dealloc</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">struct</span> autorelease_thread_vars *tv = ARP_THREAD_VARS;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个函数会释放每个child</span></span><br><span class="line">  [<span class="keyword">self</span> emptyPool];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Remove self from the linked list of pools in use.</span></span><br><span class="line"><span class="comment">   * We already know that we have deallocated any child (in -emptyPool),</span></span><br><span class="line"><span class="comment">   * but we may have a parent which needs to know we have gone.</span></span><br><span class="line"><span class="comment">   * The only other place where the parent/child linked list is modified</span></span><br><span class="line"><span class="comment">   * should be in -init</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="comment">// 但是我们还要通知父节点</span></span><br><span class="line">  <span class="keyword">if</span> (tv-&gt;current_pool == <span class="keyword">self</span>)</span><br><span class="line">    {</span><br><span class="line">      tv-&gt;current_pool = _parent;</span><br><span class="line">    }</span><br><span class="line">  <span class="keyword">if</span> (_parent != <span class="literal">nil</span>)</span><br><span class="line">    {</span><br><span class="line">      _parent-&gt;_child = <span class="literal">nil</span>;</span><br><span class="line">      _parent = <span class="literal">nil</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don't deallocate ourself, just save us for later use. */</span></span><br><span class="line">  push_pool_to_cache (tv, <span class="keyword">self</span>);</span><br><span class="line">  GSNOSUPERDEALLOC;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="苹果的实现-1"><a href="#苹果的实现-1" class="headerlink" title="苹果的实现"></a>苹果的实现</h3><p>AutoReleasePoolPage类中有几个方法</p>
<ul>
<li>push<ul>
<li>生成或持有NSAutoreleasePool类对象</li>
</ul>
</li>
<li>pop<ul>
<li>废弃NSAutoreleasePool类对象</li>
<li>调用 releaseAll();</li>
</ul>
</li>
<li>autorelease<ul>
<li>获取正在使用的pool实例</li>
<li>调用这个实例的add方法</li>
</ul>
</li>
<li>add<ul>
<li>追加对象到内部数组中</li>
</ul>
</li>
<li>releaseAll<ul>
<li>调用内部数组中元素的release方法</li>
</ul>
</li>
</ul>
<p>showPool方法展示了当前pool中存持有的对象</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317013.png" alt="Untitled"></p>
<p>最后，NSAutoreleasePool pool对象调用autorelease时会出错</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317029.png" alt="Untitled"></p>
<h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><p>NSAutoreleasePool可以当做是一个数组，[obj autorelease]的时候就把obj放进去，当pool废弃时，数组中的所有元素都会调用release方法</p>
<h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><p>ARC只是自动地帮助处理引用计数相关的问题。其思考方式和引用计数时的思考方式一样，从自己生成的对象和非自己生成的对象、自己能否持有两方面考虑。</p>
<h3 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h3><p>一共有四种所有权修饰符</p>
<ul>
<li>__strong</li>
<li>__weak</li>
<li>__unsafe_unretained</li>
<li>__autoreleasing</li>
</ul>
<hr>
<ul>
<li>__strong</li>
</ul>
<p>id类型和对象类型默认的所有权修饰符。</p>
<p>我们说引用计数内存管理的思考方式有四条，其中两条是</p>
<ul>
<li>自己生成的对象，自己所持有</li>
<li>非自己生成的对象，自己也能持有</li>
</ul>
<p>在没有ARC的时候我们需要手动的retain来达成，但现在只需要通过对带__strong修饰符的变量赋值便可达成。</p>
<ul>
<li>不在需要自己持有的对象时释放</li>
</ul>
<p>在没有ARC的时候需要手动release来达成，现在对于__strong修饰的变量，如果变量作用域结束或成员变量所属对象废弃或者对变量赋值，都可以做到</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 下面两行代码相同</span></span><br><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br></pre></td></tr></tbody></table></figure>

<p>持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象会随之释放。</p>
<p>首先，__strong修饰的变量在超出作用域时被废弃，即在ARC无效的时候，等价的工作是</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">	<span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">	[obj release];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>也就是说，当变量离开作用域范围时，会自动调用release</p>
<p>那变量赋值呢，下面是没有ARC的情况。当obj赋值给obj1时，他俩所指向地址的引用通过retain，医用计数加一，在离开作用域的时候分别release。这些工作ARC有效时会自动处理。</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317043.png" alt="Untitled"></p>
<p>所以总结一下，__strong修饰的变量可以自动处理对象的持有和释放，主要体现在三个方面</p>
<ul>
<li>离开变量作用域自动释放</li>
<li>成员变量引用了一个对象，而当这个成员变量所属的对象被废弃时，它引用的对象也会被释放</li>
<li>变量的赋值</li>
</ul>
<hr>
<ul>
<li>__weak</li>
</ul>
<p>__strong会带来循环引用的问题。</p>
<p>比如有testa变量引用对象A，testb变量引用对象B。当testa和testb超出了其作用域时，强引用失效，自动释放对象A和对象B，这个时候obj_b还引用着对象A，obj_a还引用着对象B，于是发生了内存泄露，即应当废弃的对象在超出其生存周期后继续存在。</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317055.png" alt="Untitled"></p>
<p>自引用也会发生循环引用</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317067.png" alt="Untitled"></p>
<p>被__weak修饰的变量不会持有实例对象。这意味着如果将自己生成并持有的对象赋给__weak修饰的变量obj，这个对象会被立刻释放</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317085.png" alt="Untitled"></p>
<aside>
🤔 所以__weak修饰的变量obj一定要引用一个已经被强引用了的对象。这样我能保证那块地址上的对象不会被立即释放，obj可以读取到。此外，如果这个强引用被释放了，这个弱引用也会被释放。


</aside>

<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">	<span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">	<span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述代码obj1持有了obj0对象的弱引用，如果obj0被废弃，则此弱引用将自动失效且处于nil被赋值的状态。但在早期iOS版本中，需要使用<code>__unsafe_unretained</code> 修饰符代替 <code>__weak</code>，他俩的区别在于<code>__unsafe_unretained</code> </p>
<hr>
<ul>
<li>__autoreleasing 修饰符</li>
</ul>
<p>ARC有效时，不能使用autorelease方法，也不能使用NSAutoreleasePool类。当尝试使用时，编译器会给出一堆报错</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317101.png" alt="Untitled"></p>
<p>在ARC有效时，需要做一些改变</p>
<ul>
<li>@autoreleasepool块来代替NSAutoreleasePool类对象生成、持有以及废弃这一范围</li>
<li>通过__autoreleasing修饰变量来代替调用autorelease方法，将对象注册到autoreleasepool</li>
</ul>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317119.png" alt="Untitled"></p>
<p>但很少有显示使用__autoreleasing修饰符的，这是因为编译器帮忙注册了。</p>
<aside>
🤔 以下的内容很重要也不太好理解  这边单独开了一篇


<p><a href="https://www.notion.so/AutoReleasePool-ARC-a009d6099a634565a92b8b569d6d844f"><strong>关于AutoReleasePool和ARC的一些研究</strong></a></p>
</aside>

<p>首先，之前提到过alloc/new/copy/mutableCopy以外的方法可以获得「非自己生成并持有」的对象，这到底是什么意思呢？</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>) array</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">id</span> obj = [[<span class="built_in">NSMutabaleArray</span> alloc] init];</span><br><span class="line">	[obj autorelease];</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ARC失效的时候要手动持有</span></span><br><span class="line"><span class="keyword">id</span> array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">[array <span class="keyword">retain</span>];</span><br></pre></td></tr></tbody></table></figure>

<p>由于return，使得对象变量超出其作用域，所以obj持有的对象会自动释放。所以在没有ARC的时候要手动retain去持有这个对象。</p>
<aside>
🤔 两个问题，1. 为什么一些对象要自动注册到autoreleaspool 2. 为什么有一些对象不需要自动注册


</aside>

<p>池子的作用是延迟释放，上述代码中obj作为函数的返回值，编译器会检查方法名是否以alloc/new/copy/mutableCopy以外的方法来取得对象，如果不是则将这个对象自动将其注册到autoreleasepool中。</p>
<p>这里提到访问__weak修饰的变量的时候必定会访问注册到autoreleasepool的对象</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317134.png" alt="Untitled"></p>
<p><a href="https://choujiji.github.io/2019/08/20/%E4%BD%BF%E7%94%A8__weak%E5%8F%98%E9%87%8F%EF%BC%8C%E6%8C%87%E5%90%91%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%B1%E4%BC%9A%E8%A2%AB%E5%8A%A0%E5%88%B0autoreleasepool%E4%B8%AD%EF%BC%9F/">使用__weak变量，指向的对象就会被加到autoreleasepool中？</a></p>
<blockquote>
<p>每使用一次weak对象，运行时系统都会将其指向的原始对象先retain，之后保存到自动释放池中（&nbsp;<em>AutoReleasePoolPage的add()</em>&nbsp;函数）。因此如果大量调用weak对象，则会重复进行此工作。不仅耗费无意义的性能（重复存储同一对象），还会使内存在短时间内大量增长</p>
</blockquote>
<p>最后，对于id指针的指针会有些不同。</p>
<p>id的指针(id*)或对象的指针(NSObject **)在没有显示指定时会被附上__autoreleasing修饰符</p>
<p>将对象赋值给附有__autoreleasing修饰符的变量，对象会被注册到autoreleasepool</p>
<p><code>（NSError ** ）error</code> 等同于 <code>(NSError * __autoreleasing * )error</code></p>
<p>使用__autoreleasing 修饰符的变量作为对象取得参数，与除alloc、new、copy、mutableCopy外其他方法返回值取得对象完全一样，都会注册到autoreleasepool，并取得非自己生成并持有的对象。</p>
<h3 id="小总结-2"><a href="#小总结-2" class="headerlink" title="小总结"></a>小总结</h3><p><img data-src="https://qiniu.dcts.top/typora/202303140317149.png" alt="Untitled"></p>
<p>这一小结信息量挺大的，主要通过四个访问修饰符，开始介绍ARC的作用。对于__strong修饰的变量，ARC能自动处理变量作用域结束后的对象的release、变量的赋值等，__weak是弱引用，主要提供两个特性：对象被废弃时赋值为nil、引用的对象在MRC下会被注册到autoreleasepool中。__autoreleaseing在ARC有效时不太会显示调用，而是换了实现的形式。如果对象是四个方法以外的方式创建的，ARC会把这个对象加入到池子里。</p>
<p>后续的章节还会更加详细地介绍ARC的实现细节，如果这里看着很累也不要紧！</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>让ARC正常运作，需要遵守一定规则。</p>
<ul>
<li>不能使用reatain、release、retainCount、autorelease</li>
</ul>
<p>在ARC下使用这些方法，编译不会通过</p>
<ul>
<li>不能使用NSAllocateObject、NSDeallocateObject</li>
<li>遵守内存管理的方法命名规则</li>
</ul>
<p>以init开始的方法和alloc、new、copy、mutableCopy规则一样，甚至更加严格。该方法必须是实例方法，必须要返回对象。该返回对象不会注册到autoreleasepool上</p>
<ul>
<li>不要显示调用dealloc</li>
<li>使用@autoreleasepool块代替NSAutoreleasePool</li>
<li>不能使用区域NSZone</li>
<li>对象型变量不能作为C语言结构体的成员</li>
<li>显示转换id和Void*</li>
</ul>
<aside>
🤔 这一块儿不做扩展了，用到的时候再来看吧


</aside>

<p>在ARC情况下要用__bridge，但其安全性类似<code>__unsafe_unretained</code> </p>
<aside>
🤔 一直搞不懂Objective-C、Core Foundation他们的关系，需要单独开一章


</aside>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>这一节解释了为什么属性的修饰符是这些，解释了它们和ARC之间的关系</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317175.png" alt="Untitled"></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><aside>
🤔 总感觉这一块很少用到


</aside>

<p>这一节指的是</p>
<ul>
<li>用__strong,__weak,__auatoreleasing修饰符变量的数组也保证其初始化为nil</li>
<li>超出作用域后，强引用消失，赋值的对象也随之释放</li>
<li>这一节说明了如何使用__strong修饰动态数组</li>
</ul>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> *array = <span class="literal">nil</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">NSObject</span> * __<span class="keyword">strong</span> *array = <span class="literal">nil</span>;</span><br><span class="line"><span class="comment">// 使用分配区域初始化为0的calloc函数分配内存</span></span><br><span class="line">array = (<span class="keyword">id</span> __<span class="keyword">strong</span> *)calloc(entries,<span class="keyword">sizeof</span>(<span class="keyword">id</span>));</span><br><span class="line"></span><br><span class="line">array[<span class="number">0</span>] = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>注意的是，动态数组操作附有__strong修饰的变量，需要手动释放所有元素</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 必须将nil赋值给所有数组元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">NSUinteger</span> i = <span class="number">9</span>; i &lt; entries; ++i){</span><br><span class="line"></span><br><span class="line">	array[i] = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">free(array);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="ARC原理"><a href="#ARC原理" class="headerlink" title="ARC原理"></a>ARC原理</h2><p>之前学了ARC的基本原理和用法，总感觉一知半解。下面会深入源代码去理解ARC的运行机制，希望可以清晰一些。</p>
<p>首先ARC的实现需要两个东西：</p>
<ul>
<li>clang LLVM 编译器</li>
<li>objc4 Objective-C 运行时库</li>
</ul>
<h3 id="strong-修饰符"><a href="#strong-修饰符" class="headerlink" title="__strong 修饰符"></a>__strong 修饰符</h3><p>使用alloc、new、copy、mutableCopy的方法创建对象时，ARC会自动插入release</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">	<span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器的模拟代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</span><br><span class="line">objc_msgSend(obj,<span class="keyword">@selector</span>(init));</span><br><span class="line">objc_release(obj);</span><br></pre></td></tr></tbody></table></figure>

<p>那用这四个以外的方式创建对象呢？</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">	<span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSMutableArray</span>,<span class="keyword">@selector</span>(array))</span><br><span class="line">objc_retainAutoreleaseReturnValue(obj)</span><br><span class="line">objc_release(obj)</span><br></pre></td></tr></tbody></table></figure>

<p>首先，在作用域结束时还是会插入release释放对象，那<code>obj.objc_retainAutoreleaseReturnValue</code> 是干嘛的呢？</p>
<ul>
<li>它是成对的，与之对应的是<code>objc_autoreleaseReturnValue</code> ,体现在哪里呢？</li>
</ul>
<p>看一下array这个类方法，在ARC下会有什么变化</p>
<aside>
🤔 array的特点是因为返回的这个对象，超过了作用域会被释放，这个对象会被注册到pool里面


</aside>

<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>) array </span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>) array</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSMutableArray</span>, <span class="keyword">@selector</span>(alloc));</span><br><span class="line">	objc_msgSend(obj,<span class="keyword">@selector</span>(init));</span><br><span class="line">	<span class="keyword">return</span> objc_autoreleaseReturnValue(obj);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>objc_autoreleaseReturnValue</code> 返回注册到autoreleasepool中的对象，但这个方法和objc_autorelease函数还不一样，不仅限于只注册到了池子中。</p>
<p>具体来说，<code>objc_autoreleaseReturnValue</code> 这个函数会看下调用方，这里指的是NSMutableArray这个类，如果之后有<code>objc_retainAutoreleaseReturnValue</code> 这个方法，那obj这个对象是不会被注册到pool中的。</p>
<p>而就算obj对象没有被注册到autoreleasepool中，<code>objc_retainAutoreleaseReturnValue</code> ，这个方法依然可以获得对象。</p>
<p>总之，上述的两个函数对这一过程做了优化，现在对象不需要注册到autoreleasepool中了。</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317190.png" alt="Untitled"></p>
<h3 id="weak-修饰符"><a href="#weak-修饰符" class="headerlink" title="__weak 修饰符"></a>__weak 修饰符</h3><p>weak修饰符的两个作用</p>
<ul>
<li>修饰的变量被废弃，将nil赋值给这个变量</li>
<li>修饰的变量使用的是注册到autoreleasepool中的对象</li>
</ul>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">	<span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 编译器处理后</span></span><br><span class="line"><span class="keyword">id</span> obj1;</span><br><span class="line">objc_initWeak(&amp;obj1,obj);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br></pre></td></tr></tbody></table></figure>

<p>首先，objc_initWeak用来赋值，它分为两步</p>
<ul>
<li>将附有__weak修饰符的变量初始化为0</li>
<li>赋值的对象作为参数调用objc_storeWeak</li>
</ul>
<p>objc_storeWeak第二参数的赋值对象的地址作为键值，作为键值，将第一参数的附有__weak修饰符的变量的地址注册到weak表中</p>
<aside>
🤔 解答下评论的问题：weak表中将废弃对象的地址作为键值进行检索，value是weak修饰符变量的地址。这里明确提到了，对于一个键值，可注册多个变量的地址！！！


</aside>

<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line">obj1 = <span class="number">0</span>;</span><br><span class="line">objc_storeWeak(&amp;obj1,obj);</span><br></pre></td></tr></tbody></table></figure>

<p>其次，还是一样的，作用域结束后会释放资源，用的是<code>objc_destroyWeak</code></p>
<p>本质还是objc_storeWeak，第二个参数传0，本来是传键值。传0会把变量的地址从weak表中删除。</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line">objc_storeWeak(&amp;obj1,<span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>具体动作如下</p>
<ul>
<li>引用计数器如果为0，会执行dealloc</li>
<li>……. 跳过一些步骤</li>
<li>从weak表中获取废弃对象的地址为键值的记录</li>
<li>将包含在记录中的所有附有__weak修饰符变量的地址，赋值为nil</li>
<li>从weak表中删除该记录</li>
<li>从引用计数表中删除废弃对象的地址为键值的记录</li>
</ul>
<p>以下的代码会发生什么呢？</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">	<span class="keyword">id</span> __<span class="keyword">weak</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> obj;</span><br><span class="line"><span class="keyword">id</span> temp = objc_msgSend(<span class="built_in">NSObject</span>,<span class="keyword">@selector</span>(alloc));</span><br><span class="line">objc_msgSend(tmp,<span class="keyword">@selector</span>(init));</span><br><span class="line">objc_initWeak(&amp;obj,temp);</span><br><span class="line"><span class="comment">// 编译器判断temp对象没有持有者</span></span><br><span class="line"><span class="comment">// 通过objc_release 函数被释放和废弃</span></span><br><span class="line">objc_release(temp);</span><br><span class="line"><span class="comment">// obj 变量会被赋值为nil</span></span><br><span class="line">objc_destroyWeak(&amp;object);</span><br></pre></td></tr></tbody></table></figure>

<p>垂悬指针是怎么造成的？</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">unsafe_unretained</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器处理后的代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</span><br><span class="line">objc_msgSend(obj,<span class="keyword">@selector</span>(init));</span><br><span class="line"><span class="comment">// 立刻释放了</span></span><br><span class="line">objc_release(obj);</span><br><span class="line"><span class="comment">// 但是没有后续操作了 obj指针变成了悬垂指针</span></span><br></pre></td></tr></tbody></table></figure>

<p>下面介绍weak的第二个功能，weak变量指向的对象都是注册到autoreleasepool中的对象</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> obj1;</span><br><span class="line">objc_initWeak($obj1,obj);</span><br><span class="line"><span class="comment">// 取出__weak修饰符变量所引用的对象并retain</span></span><br><span class="line"><span class="keyword">id</span> tmp = objc_loadWeakRetained(&amp;obj1);</span><br><span class="line"><span class="comment">// 将对象注册到autoreleasepool中</span></span><br><span class="line">objc_autorelease(tmp);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br></pre></td></tr></tbody></table></figure>

<p>下面这段话解释了为什么之前看到有些代码里面，先用__weak修饰了一个变量之后，又用__strong 修饰回去。这是因为大量使用附有__weak修饰符的变量，注册到<code>autoreleasepool</code>中的对象也会大量增加</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140317206.png" alt="Untitled"></p>
<p>最好的做法是</p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">	<span class="keyword">id</span> __<span class="keyword">weak</span> o = obj;</span><br><span class="line">	<span class="keyword">id</span> temp = o;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,temp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="autoreleasing"><a href="#autoreleasing" class="headerlink" title="__autoreleasing"></a>__autoreleasing</h3><p>下面的代码的作用是将NSObject对象注册到autoreleasepool中</p>
<p><a href="https://www.notion.so/ef8e36c11e3b4069b9b83f478783cc69">苹果的实现</a> </p>
<figure class="highlight objectivec"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> {</span><br><span class="line">	<span class="keyword">id</span> __autoreleasing obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> pool = objc_autoreleasePoolPush();</span><br><span class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSObject</span>,<span class="keyword">@selector</span>(alloc));</span><br><span class="line">objc_msgSend(obj,<span class="keyword">@selector</span>(init));</span><br><span class="line">objc_autorelease(obj);</span><br><span class="line">objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@autoreleasepool</span> {</span><br><span class="line">	<span class="keyword">id</span> __autoreleasing obj = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">id</span> pool = objc_autoreleasePoolPush();</span><br><span class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSObject</span>,<span class="keyword">@selector</span>(array));</span><br><span class="line"><span class="comment">// 持有对象的方法发生了改变</span></span><br><span class="line">objc_retainAutoreleaseReturnValue(obj);</span><br><span class="line">objc_autorelease(obj);</span><br><span class="line">objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="引用计数器的数值"><a href="#引用计数器的数值" class="headerlink" title="引用计数器的数值"></a>引用计数器的数值</h3><p>可以使用_objc_rootRetainCount这个函数来获得对象的引用计数</p>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>内存管理</tag>
        <tag>ARC</tag>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Python正则</title>
    <url>/post/ca4e4d5f/</url>
    <content><![CDATA[<h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><ul>
<li><p>  在带有 <code>'r'</code> 前缀的字符串字面值中，反斜杠不必做任何特殊处理。反斜重复两次将导致理解障碍，所以高度推荐，就算是最简单的表达式，也要使用原始字符串。</p>
</li>
<li><p>  <code>'*'</code>, <code>'+'</code>，和 <code>'?'</code> 修饰符都是 _贪婪的_；它们在字符串进行尽可能多的匹配。有时候并不需要这种行为。如果正则式 <code>&lt;.*&gt;</code> 希望找到 <code>'&lt;a&gt; b &lt;c&gt;'</code>，它将会匹配整个字符串，而不仅是 <code>'&lt;a&gt;'</code>。在修饰符之后添加 <code>?</code> 将使样式以 <strong>非贪婪</strong>即最小方式进行匹配；尽量 少 的字符将会被匹配。 使用正则式 <code>&lt;.*?&gt;</code> 将会仅仅匹配 <code>'&lt;a&gt;'</code>。</p>
</li>
<li><p>  特殊字符在集合中，失去它的特殊含义。比如 <code>[(+*)]</code> 只会匹配这几个文法字符 <code>'('</code>, <code>'+'</code>, <code>'*'</code>, or <code>')'</code></p>
</li>
<li><p>  <code>\B</code>匹配空字符串，但 不 能在词的开头或者结尾。意思就是 <code>r'py\B'</code> 匹配 <code>'python'</code>, <code>'py3'</code>, <code>'py2'</code>, 但不匹配 <code>'py'</code>, <code>'py.'</code>, 或者 <code>'py!'</code>. <code>\B</code> 是 <code>\b</code> 的取非。(说人话就是后边必须有点东西)</p>
</li>
</ul>
<h4 id="模块内容"><a href="#模块内容" class="headerlink" title="模块内容"></a>模块内容</h4><ul>
<li>  <code>re.compile(pattern, flags=0)</code> 可以让正则多次使用</li>
<li>  <code>re.search(pattern, string, flags=0)</code>扫描整个字符串，找到匹配样式的第一个位置，并返回一个相应的<strong>匹配对象</strong>如果没有匹配，就返回一个 <code>None</code></li>
<li>  <code>re.match(pattern, string, flags=0)</code>注意<strong>即便是 <code>MULTILINE</code> 多行模式,<code>re.match()</code> 也只匹配字符串的开始位置</strong>，而不匹配每行开始。如果你想定位 string 的任何位置，使用 <code>search()</code>来替代</li>
<li>  <code>re.split(pattern, string, maxsplit=0, flags=0)</code> 用 <code>pattern</code>分开 <code>string</code> 。 如果在 <code>pattern</code> 中捕获到括号，那么所有的组里的文字也会包含在列表里。如果 <code>maxsplit</code> 非零， 最多进行 <code>maxsplit</code>次分隔， 剩下的字符全部返回到列表的最后一个元素。</li>
<li>  <code>re.findall(pattern, string, flags=0)</code> 对 <code>string</code> 返回一个不重复的<code>pattern</code> 的<strong>匹配列表</strong>， <code>string</code> 从左到右进行扫描，匹配按找到的顺序返回。如果样式里存在一到多个组，就返回一个组合列表；就是一个元组的列表（如果样式里有超过一个组合的话）。空匹配也会包含在结果里。</li>
<li>  <code>re.finditer(pattern, string, flags=0)</code> <code>pattern</code> 在 <code>string</code> 里所有的非重复匹配，返回为一个<code>迭代器 iterator</code>保存了<strong>匹配对象</strong> 。<code>string</code>从左到右扫描，匹配按顺序排列。空匹配也包含在结果里。(用迭代器保存返回的<strong>匹配对象</strong>)</li>
</ul>
<h3 id="正则对象"><a href="#正则对象" class="headerlink" title="正则对象"></a>正则对象</h3><p>编译后的正则表达式对象支持的方法和属性</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">"d"</span>)</span><br><span class="line">pattern.search()</span><br><span class="line">pattern.match()</span><br><span class="line">pattern.findall()</span><br><span class="line">pattern.finditer()</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>

<h3 id="匹配对象"><a href="#匹配对象" class="headerlink" title="匹配对象"></a>匹配对象</h3><p>匹配对象总是有一个布尔值 True。如果没有匹配的话<code>match()</code> 和<code>search()</code>返回 None 所以你可以简单的用 if 语句来判断是否匹配</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">match = re.search(pattern, string)</span><br><span class="line"><span class="keyword">if</span> match:</span><br><span class="line">    process(match)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="组的概念"><a href="#组的概念" class="headerlink" title="组的概念"></a>组的概念</h3><p>正则式中的每个组都有一个序号，它是按定义时从左到右的顺序<strong>从1开始编号</strong>的。其实，re的正则式还有一个0号组，<strong>它就是整个正则式本身。</strong></p>
<ul>
<li><p><code>match.group()</code></p>
</li>
<li><p><code>group(0)</code> 与 <code>group()</code> 等价，其结果为整个正则式匹配到的内容，包括没有包到组里面的内容</p>
</li>
<li><p><code>match.groups()</code></p>
<ul>
<li>匹配组里面的内容，把他们都列出来放到元组里</li>
</ul>
</li>
<li><p><code>match.__getitem__()</code></p>
</li>
<li><p><code>match.lastgroup</code></p>
<ul>
<li>最后一个匹配到的组的组名,如果没有产生匹配的话返回<code>None</code>。</li>
</ul>
</li>
<li><p><code>match.start()</code></p>
<ul>
<li>返回给定的组开始的位置</li>
</ul>
</li>
<li><p><code>match.end()</code></p>
<ul>
<li>返回给定的组结束的位置+1</li>
</ul>
</li>
<li><p><code>match.span()</code></p>
<ul>
<li>返回（start,end）的形式</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt; p=re.compile( r’(?P&lt;name&gt;[a-z]+)/s+(?P&lt;age&gt;/d+)/s+(?P&lt;tel&gt;/d+).*’ , re.I )</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.groupindex</span><br><span class="line"></span><br><span class="line">{<span class="string">'age'</span>: <span class="number">2</span>, <span class="string">'tel'</span>: <span class="number">3</span>, <span class="string">'name'</span>: <span class="number">1</span>}</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=’Tom <span class="number">24</span> <span class="number">88888888</span>  &lt;=’</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m=p.search(s)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.groups()                           <span class="comment"># 看看匹配的各组的情况</span></span><br><span class="line"></span><br><span class="line">(<span class="string">'Tom'</span>, <span class="string">'24'</span>, <span class="string">'8888888'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(‘name’)                   <span class="comment"># 使用组名获取匹配的字符串</span></span><br><span class="line"></span><br><span class="line">‘Tom’</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group( <span class="number">1</span> )                         <span class="comment"># 使用组序号获取匹配的字符串，同使用组名的效果一样</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)                           <span class="comment"># 0 组里面是什么呢？</span></span><br><span class="line"></span><br><span class="line"><span class="string">'Tom 24 88888888  &lt;='</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>正则</tag>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>Screen命令笔记</title>
    <url>/post/d07d5346/</url>
    <content><![CDATA[<h2 id="使用Screen在后台运行程序"><a href="#使用Screen在后台运行程序" class="headerlink" title="使用Screen在后台运行程序"></a>使用Screen在后台运行程序</h2><ul>
<li><p>安装</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ sudo apt-get install screen</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>创建窗口</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ screen -S xxx //创建一个名叫xxx的窗口</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>退出</p>
<p>方法一：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Ctrl a +d</span><br></pre></td></tr></tbody></table></figure>

<p>方法二：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ screen -d name //首先要退出窗口</span><br></pre></td></tr></tbody></table></figure>


</li>
</ul>
<ul>
<li><p>查看窗口列表</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ screen -ls</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>重新进入窗口</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ screen -r 窗口号</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>杀死窗口并清除</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -9 窗口号//首先杀死进程</span><br><span class="line">$ screen -wipe //自动清理死掉的窗口</span><br></pre></td></tr></tbody></table></figure>





</li>
</ul>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim常用操作整理(Vimtutor)</title>
    <url>/post/d852f757/</url>
    <content><![CDATA[<h4 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h4><ul>
<li>  <code>k</code> 上</li>
<li>  <code>j</code> 下</li>
<li>  <code>h</code> 左</li>
<li>  <code>l</code> 右</li>
<li>  <code>0</code> 回到首行</li>
<li>  <code>CTRL+G</code> 显示当前阅读进度、光标行号</li>
<li>  <code>gg</code> 回到文件第一行</li>
<li>  <code>G</code> 跳转到文件最后一行</li>
<li>  <code>CTRL+o</code> 返回旧的光标位置</li>
<li>  <code>CTRL+i</code> 返回新的光标位置</li>
</ul>
<p>​    <em>operator [number] motion</em></p>
<ul>
<li>  <code>w</code> 到下一个单词前</li>
<li>  <code>e</code> 到下一个单词结束</li>
<li>  <code>$</code> 从光标到当前末尾</li>
</ul>
<h4 id="更改文本内容"><a href="#更改文本内容" class="headerlink" title="更改文本内容"></a>更改文本内容</h4><ul>
<li>  <code>x</code> 删除当前字符</li>
<li><code>d</code> 删除操作符<ul>
<li>  <code>dd</code> 删除整行</li>
<li>  <code>d$</code> 删除从光标到末尾</li>
</ul>
</li>
<li><code>p</code> 另起一行放入删除的内容<ul>
<li>  <code>y</code> 用于复制文本</li>
</ul>
</li>
<li><code>r</code> 替换单个字符<ul>
<li>  <code>R</code> 进入替换模式 一直可以替换</li>
</ul>
</li>
<li><code>c</code> 更改操作符<ul>
<li>  <code>c$</code> 更改从光标到行末尾</li>
<li>  <code>ce</code> 更改光标到单词末尾</li>
</ul>
</li>
<li><code>:s/old/new</code> 用新字符串替换旧字符串<ul>
<li>  <code>:s/old/new/gc</code> g表示行内所有 c表示询问是否替换</li>
<li>  <code>:%s/old/new/g</code> 全文替换</li>
</ul>
</li>
</ul>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ul>
<li>  <code>i</code> 光标前插入</li>
<li>  <code>a</code> 光标自动后移一位</li>
<li>  <code>A</code> 光标移到一行的末尾</li>
<li>  <code>o</code> 光标移到新的一行</li>
<li>  <code>O</code> 光标移到上面一行</li>
</ul>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ul>
<li>  <code>/</code> 往下查找字符串</li>
<li>  <code>？</code> 往上查找字符串</li>
<li>  <code>n</code> 下一个匹配项</li>
<li>  <code>N</code> 上一个匹配项</li>
<li><code>set xxx</code> 如果要关闭 <code>set noxxx</code><ul>
<li>  <code>ic</code> 查找时忽略大小写</li>
<li>  <code>is</code> 查找短语时显示部分匹配</li>
<li>  <code>hls</code> 高亮显示所有匹配</li>
</ul>
</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>  <code>u</code> 撤销</li>
<li>  <code>U</code> 撤销一行</li>
<li>  <code>CTRL+R</code> 重做</li>
<li>  <code>%</code> 匹配括号</li>
<li><code>:!command</code> 用于在vim中执行外部命令<ul>
<li>  <code>:r FILENAME</code> 提取磁盘文件并插入到光标后面</li>
<li>  <code>:r !dir</code> 读取dir命令放到光标后面</li>
</ul>
</li>
<li><code>v</code> 选中某些内容<ul>
<li>  <code>v :w FILENAME</code> 将选中的内容保存在FILENAME中</li>
</ul>
</li>
<li>  <code>CTRL + w</code> 在窗口之间跳转</li>
</ul>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask入门（一）——在阿里云部署Flask环境</title>
    <url>/post/6f15ec4d/</url>
    <content><![CDATA[<h3 id="阿里云部署flask"><a href="#阿里云部署flask" class="headerlink" title="阿里云部署flask"></a>阿里云部署flask</h3><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ul>
<li>  <a href="https://juejin.im/post/5a5a1408518825733060e232#heading-6">通过Gunicorn部署flask应用（阿里云服务器：Ubuntu 16.04）</a></li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p><code>app.run(host='0.0.0.0',port=5000)   # 设置外部访问限制，本例表示所有ip均可访问，端口为5000</code></p>
</li>
<li><p>导出的<code>requirements.txt</code></p>
<ul>
<li><p>  导出方法 <code>pip freeze &gt; requirements.txt</code></p>
</li>
<li><p>安装方法 <code>pip install -r requirement.txt</code></p>
  <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">alembic==<span class="number">1.0</span><span class="number">.9</span></span><br><span class="line">Babel==<span class="number">2.6</span><span class="number">.0</span></span><br><span class="line">blinker==<span class="number">1.4</span></span><br><span class="line">Click==<span class="number">7.0</span></span><br><span class="line">coverage==<span class="number">4.5</span><span class="number">.3</span></span><br><span class="line">decorator==<span class="number">4.4</span><span class="number">.0</span></span><br><span class="line">defusedxml==<span class="number">0.6</span><span class="number">.0</span></span><br><span class="line">dominate==<span class="number">2.3</span><span class="number">.5</span></span><br><span class="line">Flask==<span class="number">1.0</span><span class="number">.2</span></span><br><span class="line">Flask-Babel==<span class="number">0.12</span><span class="number">.2</span></span><br><span class="line">Flask-Bootstrap==<span class="number">3.3</span><span class="number">.7</span><span class="number">.1</span></span><br><span class="line">Flask-Login==<span class="number">0.4</span><span class="number">.1</span></span><br><span class="line">Flask-Mail==<span class="number">0.9</span><span class="number">.1</span></span><br><span class="line">Flask-Migrate==<span class="number">2.4</span><span class="number">.0</span></span><br><span class="line">Flask-OpenID==<span class="number">1.2</span><span class="number">.5</span></span><br><span class="line">Flask-SQLAlchemy==<span class="number">2.3</span><span class="number">.2</span></span><br><span class="line">Flask-WhooshAlchemy==<span class="number">0.56</span></span><br><span class="line">Flask-WTF==<span class="number">0.14</span><span class="number">.2</span></span><br><span class="line">flipflop==<span class="number">1.0</span></span><br><span class="line">guess-language==<span class="number">0.2</span></span><br><span class="line">itsdangerous==<span class="number">1.1</span><span class="number">.0</span></span><br><span class="line">Jinja2==<span class="number">2.10</span><span class="number">.1</span></span><br><span class="line">Mako==<span class="number">1.0</span><span class="number">.9</span></span><br><span class="line">MarkupSafe==<span class="number">1.1</span><span class="number">.1</span></span><br><span class="line">pbr==<span class="number">5.1</span><span class="number">.3</span></span><br><span class="line">python-dateutil==<span class="number">2.8</span><span class="number">.0</span></span><br><span class="line">python-editor==<span class="number">1.0</span><span class="number">.4</span></span><br><span class="line">python3-openid==<span class="number">3.1</span><span class="number">.0</span></span><br><span class="line">pytz==<span class="number">2019.1</span></span><br><span class="line">six==<span class="number">1.12</span><span class="number">.0</span></span><br><span class="line">SQLAlchemy==<span class="number">1.3</span><span class="number">.3</span></span><br><span class="line">sqlalchemy-migrate==<span class="number">0.12</span><span class="number">.0</span></span><br><span class="line">sqlparse==<span class="number">0.3</span><span class="number">.0</span></span><br><span class="line">Tempita==<span class="number">0.5</span><span class="number">.2</span></span><br><span class="line">visitor==<span class="number">0.1</span><span class="number">.3</span></span><br><span class="line">Werkzeug==<span class="number">0.15</span><span class="number">.2</span></span><br><span class="line">Whoosh==<span class="number">2.7</span><span class="number">.4</span></span><br><span class="line">WTForms==<span class="number">2.2</span><span class="number">.1</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p><code>gunicorn</code> 设置启动参数 部署到服务器上时 <strong>‘127.0.0.1’ 改为你的服务器的私有IP</strong>，<strong>并在服务器上设置相关端口（如5000）的安全组 test改为项目运行入口 如run</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">gunicorn -w 4 -b 172.xxx.xxx.207:5000 run:app</span><br><span class="line">nohup gunicorn -w 4 -b xx.xx.xx.xx:xxxx <span class="built_in">test</span>:app&amp;  <span class="comment">#后台启动</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>安装和配置Nginx</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># file_name=default</span></span><br><span class="line">server {</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.org; <span class="comment"># 这是HOST机器的外部域名，用地址也行</span></span><br><span class="line"></span><br><span class="line">    location / {</span><br><span class="line">        proxy_pass http://your.私有IP:5000; <span class="comment"># 指向 gunicorn host 的服务地址，注意，这里填我们服务器的私有IP</span></span><br><span class="line">        proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<p>用xshell将项目的文件传到服务器上（不用传在本地建的虚拟环境中使用的包） 至此，理论上在浏览器中输入公有的ip地址，就可以访问项目</p>
</li>
<li><p>有关<code>gunicorn</code>的相关操作</p>
<ul>
<li><pre><code>  pkill gunicorn  //关闭gunicorn</code></pre>
</li>
<li><pre><code>  pstree -ap|grep gunicorn</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="阿里云配置MongoDB"><a href="#阿里云配置MongoDB" class="headerlink" title="阿里云配置MongoDB"></a>阿里云配置MongoDB</h3><h4 id="参考文档-1"><a href="#参考文档-1" class="headerlink" title="参考文档"></a>参考文档</h4><ul>
<li>  <a href="https://www.cnblogs.com/pfnie/articles/6759105.html">Linux下MongoDB安装和配置详解</a></li>
</ul>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p>先开启服务器Mongod，在使用Mongo操作数据库</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">#必须在mongod的目录下</span></span><br><span class="line">./mongod --config /usr/<span class="built_in">local</span>/mongoDB/mongodbserver/etc/mongodb.conf</span><br><span class="line"><span class="comment">#如果已经添加到了系统路径，可以直接</span></span><br><span class="line">mongod --config /usr/<span class="built_in">local</span>/mongoDB/mongodbserver/etc/mongodb.conf</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>  错误<code>./mongod: error while loading shared libraries: libcurl.so.4: cannot open shared object file: No such file or directory</code> 解决办法：<code>apt-get install libcurl4-openssl-dev</code></p>
</li>
<li><p>将mongod路径添加到系统路径中，方便随处执行mongod命令</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/mongoDB/mongodbserver/bin</span><br><span class="line"><span class="built_in">source</span> /etc/profil  使系统环境变量立即生效</span><br></pre></td></tr></tbody></table></figure>






</li>
</ul>
<h3 id="上传MongoDB数据到服务器"><a href="#上传MongoDB数据到服务器" class="headerlink" title="上传MongoDB数据到服务器"></a>上传MongoDB数据到服务器</h3><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>  <a href="https://www.cnblogs.com/kevingrace/p/8184087.html">MongoDB日常运维操作命令小结</a> &nbsp;</li>
</ul>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ol>
<li> MongoDB没有添加访问权限</li>
<li> MongoDB没有开机自启</li>
<li> 配置原理不熟悉</li>
</ol>
<h3 id="相关参考资料"><a href="#相关参考资料" class="headerlink" title="相关参考资料"></a>相关参考资料</h3><ol>
<li> <a href="https://www.jianshu.com/p/5b73444eb47d?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">新手的Flask+uwsgi+Nginx+Ubuntu部署过程 - 简书</a></li>
<li> <a href="https://www.jianshu.com/p/9293cc21a571">阿里云部署Flask+WSGI+Nginx 详解 - 简书</a></li>
<li> <a href="https://blog.csdn.net/wojiaopanpan/article/details/7286430">Linux如何查看进程、杀死进程、启动进程等常用命令 - wojiaopanpan - CSDN博客</a></li>
<li> <a href="https://www.cnblogs.com/kevingrace/p/8184087.html">MongoDB日常运维操作命令小结 - 散尽浮华 - 博客园</a></li>
<li> <a href="https://www.cnblogs.com/pfnie/articles/6759105.html">Linux下MongoDB安装和配置详解 - pfnie - 博客园</a></li>
<li> <a href="https://www.jianshu.com/p/00bd136b4165">Ubuntu 16.04 mongodb enterprise 3.4 安装中遇到的错误 - 简书</a></li>
<li> <a href="https://juejin.im/post/5a5a1408518825733060e232">通过Gunicorn部署flask应用（阿里云服务器：Ubuntu 16.04） - 掘金</a></li>
</ol>
<p>&nbsp; &nbsp;</p>
<h3 id="扫描二维码查看网站"><a href="#扫描二维码查看网站" class="headerlink" title="扫描二维码查看网站"></a>扫描二维码查看网站</h3><p><a href=""><img data-src="http://www.dcts.xyz/wordpress/wp-content/uploads/2019/05/%E5%9B%BE%E7%89%871.png" alt="网站暂时关闭"></a></p>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>入门</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Tutorial</title>
    <url>/post/9dac317c/</url>
    <content><![CDATA[<h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><ol>
<li>基础学习教程<ol>
<li> <a href="https://link.zhihu.com/?target=http://www.runoob.com/python3/python3-tutorial.html">Python3 教程 | 菜鸟教程</a></li>
<li> <a href="https://link.zhihu.com/?target=http://www.pythondoc.com/pythontutorial3/">Python tutorial 3.5.2 documentation</a></li>
<li> <a href="http://codingpy.com/books/thinkpython2/">《Think Python》</a></li>
<li> 如果你不喜欢看文档,<a href="https://morvanzhou.github.io/">莫烦Python</a>视频教程</li>
</ol>
</li>
<li>练练手<ol>
<li> github上的一些项目</li>
<li> <a href="https://github.com/TD21forever/Mini-Python-Project">别人的一些项目</a></li>
</ol>
</li>
</ol>
<h3 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h3><p>Python3 中有六个标准的数据类型：</p>
<ul>
<li>  String（字符串）</li>
<li>  Number（数字）</li>
<li>  List（列表）</li>
<li>  Tuple（元组）</li>
<li>  Set（集合）</li>
<li>  Dictionary（字典）</li>
</ul>
<h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><ol>
<li><p>字符串的基本操作</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">name = <span class="string">"自动化科协"</span></span><br><span class="line">department = <span class="string">"软件部"</span></span><br><span class="line">print(name+department)<span class="comment">#字符串做加法</span></span><br><span class="line">print(name*<span class="number">10</span>)<span class="comment">#字符串做乘法</span></span><br><span class="line">print(name[<span class="number">0</span>])<span class="comment">#取字符串的第一位</span></span><br><span class="line">print(name[-<span class="number">1</span>])<span class="comment">#取字符串的最后一位</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>格式化字符串</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">date_1 = <span class="string">"%d年%d月%d日是%s的生日"</span> %(<span class="number">1964</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="string">'马云'</span>)</span><br><span class="line">print(date_1)<span class="comment">#%d代表数字，%s代表字符串</span></span><br><span class="line">date_2 = <span class="string">"{}年{}月{}日是{}的生日"</span>.<span class="built_in">format</span>(<span class="number">1964</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="string">'马云'</span>)</span><br><span class="line">print(date_2)<span class="comment">#这样就不用%了</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>切片（slice）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">string = <span class="string">'自动化科协软件部'</span></span><br><span class="line">new_string = string[<span class="number">3</span>:<span class="number">5</span>]<span class="comment">#3包括5不包括</span></span><br><span class="line">print(new_string)</span><br><span class="line">a = <span class="string">'大家好这是我的联系电话110120119,大家有空请别联系我'</span></span><br><span class="line">new_a = a[<span class="number">11</span>:<span class="number">20</span>]<span class="comment">#11包括20不包括</span></span><br><span class="line">print(new_a)</span><br></pre></td></tr></tbody></table></figure>


</li>
</ol>
<h3 id="Number（数字）"><a href="#Number（数字）" class="headerlink" title="Number（数字）"></a>Number（数字）</h3><blockquote>
<p>Python3 支持 <strong>int、float、bool、complex（复数）</strong>。 在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a,b,c,d = <span class="number">20</span>, <span class="number">5.5</span>, <span class="literal">True</span>, <span class="number">4</span>+<span class="number">3j</span></span><br><span class="line"><span class="built_in">print</span> (a,b,c,d)</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">type</span>(a),<span class="built_in">type</span>(b),<span class="built_in">type</span>(c)，<span class="built_in">type</span>(d))<span class="comment">#这里用到了type这个函数</span></span><br></pre></td></tr></tbody></table></figure>


<h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><ol>
<li><p>列表的建立</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">list_1 = [<span class="number">1111</span>,<span class="string">'2222'</span>,<span class="number">3.333</span>,<span class="literal">True</span>,[<span class="string">'This is a list'</span>],<span class="literal">None</span>] <span class="comment">#列表的建立用[]</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>列表的遍历（迭代）</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> one <span class="keyword">in</span> list_1:<span class="comment">#用这种方式遍历</span></span><br><span class="line">	print(one)</span><br><span class="line">```</span><br><span class="line"><span class="keyword">for</span> one <span class="keyword">in</span> list_1:</span><br><span class="line">	print(<span class="built_in">type</span>(one))</span><br><span class="line">```</span><br></pre></td></tr></tbody></table></figure>



</li>
</ol>
<ol start="3">
<li><p>列表的一些操作</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">list_1.reverse()</span><br><span class="line">print(list_1)</span><br><span class="line">list_1.append(<span class="string">'我添加了一个元素'</span>)</span><br><span class="line">print(list_1)</span><br><span class="line">list_1.remove(<span class="literal">None</span>)</span><br><span class="line">print(list_1)</span><br></pre></td></tr></tbody></table></figure>




</li>
</ol>
<h3 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h3><ol>
<li><p>元组的建立</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">tuple_1 = (<span class="number">1111</span>,<span class="string">'2222'</span>,<span class="number">3.333</span>,<span class="literal">True</span>,[<span class="string">'This is a list'</span>],<span class="literal">None</span>,(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))<span class="comment">#元组的建立用()</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>元组和列表不同之处</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">List = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">Tuple = (<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">List[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">print(List)</span><br></pre></td></tr></tbody></table></figure>




</li>
</ol>
<h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><ol>
<li><p>集合的建立</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">set_1 = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>}</span><br><span class="line">print(set_1)</span><br></pre></td></tr></tbody></table></figure>


</li>
</ol>
<h3 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h3><ol>
<li><p>字典的建立</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">slogan= {</span><br><span class="line">	<span class="string">'Adidas'</span>:<span class="string">'没有不可能（impossible is nothing)'</span>,</span><br><span class="line">	<span class="string">'Nike'</span> :<span class="string">'Just do it'</span>,</span><br><span class="line">	<span class="string">'Lining'</span>:<span class="string">'一切皆有可能'</span>,</span><br><span class="line">	<span class="string">'4399'</span>	:<span class="string">'一切皆有可能'</span>,</span><br><span class="line">	<span class="comment"># '4399'	:"4399v587"</span></span><br><span class="line">}</span><br><span class="line">print(slogan[<span class="string">'Lining'</span>])</span><br><span class="line">print(slogan[<span class="string">'4399'</span>])</span><br></pre></td></tr></tbody></table></figure>




</li>
</ol>
<hr>
<h3 id="其他的一些操作"><a href="#其他的一些操作" class="headerlink" title="其他的一些操作"></a>其他的一些操作</h3><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_boyfriend</span>(<span class="params">face,height,money</span>):</span></span><br><span class="line">	<span class="keyword">if</span> face &gt; <span class="number">85</span>:</span><br><span class="line">		print(<span class="string">"oh he is my boyfriend"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">elif</span> height &gt; <span class="number">185</span>:</span><br><span class="line">		print(<span class="string">"oh he is my boyfriend"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">elif</span> money &gt; <span class="number">100000000000000</span>:</span><br><span class="line">		print(<span class="string">"OH God! He must be the one!!!!"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		print(<span class="string">"Who are you?"</span>)</span><br><span class="line"></span><br><span class="line">find_boyfriend(<span class="number">12</span>,<span class="number">170</span>,<span class="number">11</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="骚操作"><a href="#骚操作" class="headerlink" title="骚操作"></a>骚操作</h3><ol>
<li><p>语义化</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">List = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">print(<span class="number">1</span> <span class="keyword">in</span> List)</span><br><span class="line">wo = <span class="string">"帅"</span></span><br><span class="line"><span class="keyword">if</span> wo <span class="keyword">is</span> <span class="keyword">not</span> <span class="string">"丑"</span>:</span><br><span class="line">	print(<span class="string">"我很帅"</span>)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>列表解析</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">b = [i <span class="keyword">for</span> i <span class="keyword">in</span> List]</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">b = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> List:</span><br><span class="line">    b.append(i)</span><br><span class="line">print(b)</span><br><span class="line">```</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>值交换</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a,b = <span class="number">5</span>,<span class="number">10</span></span><br><span class="line">temp = b</span><br><span class="line">b = a</span><br><span class="line">a= temp</span><br><span class="line">print(a,b)</span><br><span class="line">a,b = b,a</span><br><span class="line">print(a,b)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>join函数</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a=[<span class="string">"这是一堂"</span>,<span class="string">'严肃的'</span>,<span class="string">"python课程"</span>]</span><br><span class="line">print(<span class="string">"哈哈哈哈啊哈哈"</span>.join(a))</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>列表或者字符串逆序</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">b = <span class="string">'123456789'</span></span><br><span class="line">print(b[<span class="number">2</span>::<span class="number">3</span>])</span><br><span class="line">print(b[::-<span class="number">1</span>])<span class="comment">#从头到尾 如果第三个参数是负数 默认从尾部开始算</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>比大小</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">b = <span class="number">10</span></span><br><span class="line"><span class="number">3</span> &lt; b <span class="keyword">and</span> b &lt; <span class="number">12</span> </span><br><span class="line">print(<span class="number">3</span>&lt;<span class="number">10</span>&lt;<span class="number">12</span>)</span><br><span class="line">print(<span class="number">4</span>&lt;<span class="number">10</span>&lt;<span class="number">9</span>)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>列表和集合互用，消除重复元素</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">list_1 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">print(<span class="built_in">list</span>(<span class="built_in">set</span>(list_1)))</span><br></pre></td></tr></tbody></table></figure>




</li>
</ol>
<h3 id="同样重要的题外话"><a href="#同样重要的题外话" class="headerlink" title="同样重要的题外话"></a>同样重要的题外话</h3><ol>
<li> 大一少打游戏 晚自习多看点课外书</li>
<li> 英语很重要 四六级大一总得过了吧</li>
<li>如果有机会之后会讲什么<ol>
<li>Markdown<ol>
<li> Typora…</li>
<li> <a href="https://www.zybuluo.com/mdeditor">作业部落</a></li>
<li> <a href="https://ouweiya.gitbooks.io/markdown/">常用语法笔记</a></li>
</ol>
</li>
<li>Git<ol>
<li> <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001373962845513aefd77a99f4145f0a2c7a7ca057e7570000">廖雪峰</a></li>
<li> <a href="https://morvanzhou.github.io/tutorials/others/git/5-1-github/">莫烦</a></li>
</ol>
</li>
<li> Linux</li>
<li>正则表达式<ol>
<li> <a href="https://regex101.com/">正则表达式</a></li>
</ol>
</li>
</ol>
</li>
<li>关于问问题<ol>
<li> 百度谷歌能解决最好</li>
<li> 如果要问别人，请把代码贴在<a href="https://paste.ubuntu.com/">这里</a></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>入门</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python装饰器</title>
    <url>/post/7939eb34/</url>
    <content><![CDATA[<h3 id="一个需求"><a href="#一个需求" class="headerlink" title="一个需求"></a>一个需求</h3><p>这里有两个已经写好的函数，但我需要在不显性地改变这些函数的基础上，获取函数运行的时间</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span>():</span></span><br><span class="line">    lis = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9999999</span>):</span><br><span class="line">        lis.append(i)</span><br><span class="line">    <span class="keyword">return</span> lis</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func2</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9999999</span>)]</span><br></pre></td></tr></tbody></table></figure>

<h4 id="方法一、"><a href="#方法一、" class="headerlink" title="方法一、"></a>方法一、</h4><p>最直接的，但这样改变了函数调用的方式，也不够优雅</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span>(<span class="params">func</span>):</span></span><br><span class="line">    s = time.time()</span><br><span class="line">    res = func()</span><br><span class="line">    e = time.time()</span><br><span class="line">    print(<span class="string">f"Finished <span class="subst">{func.__name__!r}</span> in <span class="subst">{e-s:<span class="number">.4</span>f}</span> secs"</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">res = timeit(my_func)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="方法二、"><a href="#方法二、" class="headerlink" title="方法二、"></a>方法二、</h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">        s = time.time()</span><br><span class="line">        res = func()</span><br><span class="line">        e = time.time()</span><br><span class="line">        print(<span class="string">f"Finished <span class="subst">{func.__name__!r}</span> in <span class="subst">{e-s:<span class="number">.4</span>f}</span> secs"</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">my_func = timeit(my_func)</span><br><span class="line">res = my_func()</span><br></pre></td></tr></tbody></table></figure>

<p>这样写很奇怪很啰嗦，但其实它等价于</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@timeit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span>():</span></span><br><span class="line">    lis = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9999999</span>):</span><br><span class="line">        lis.append(i)</span><br><span class="line">    <span class="keyword">return</span> lis</span><br><span class="line">res = my_func()</span><br></pre></td></tr></tbody></table></figure>

<p>在这个例子中，需要注意几个事情：</p>
<ol>
<li>timeit的返回值是什么？-&gt; 是一个函数</li>
<li>wrapper的返回值是什么？ -&gt; 是一个值</li>
</ol>
<p>因此，<code>@timeit</code>实际上是<code>my_func = timeit(my_func)</code>的一种省略，此时的<code>my_func</code>其实是里面的<code>wrapper</code></p>
<h3 id="一些写法"><a href="#一些写法" class="headerlink" title="一些写法"></a>一些写法</h3><h4 id="初始的函数有参数怎么办"><a href="#初始的函数有参数怎么办" class="headerlink" title="初始的函数有参数怎么办"></a>初始的函数有参数怎么办</h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        <span class="comment">#do something</span></span><br><span class="line">        res = func(*args,**kwargs)</span><br><span class="line">        <span class="comment">#do something</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">    </span><br><span class="line"><span class="meta">@timeit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"My name is <span class="subst">{name}</span>"</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="functools-wrapper的使用"><a href="#functools-wrapper的使用" class="headerlink" title="@functools.wrapper的使用"></a>@functools.wrapper的使用</h4><p>在上面这份代码中，<code>my_func.__name__</code>的输出是<code>wrapper</code>，也就是说<code>my_func</code>失去了原始函数的信息，可以使用@functools.wrapper来解决这个问题</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        <span class="comment">#do something</span></span><br><span class="line">        res = func(*args,**kwargs)</span><br><span class="line">        <span class="comment">#do something</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timeit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"My name is <span class="subst">{name}</span>"</span></span><br></pre></td></tr></tbody></table></figure>

<p>此时<code>my_func.__name__</code>的输出是<code>wrapper</code></p>
<blockquote>
<p><code>@functools.wrapper</code> 装饰器使用函数<code>functions.update_wrapper()</code>来更新内省中使用的<code>__name__</code>和<code>__doc__</code>等特殊属性。</p>
</blockquote>
<h4 id="装饰器的嵌套"><a href="#装饰器的嵌套" class="headerlink" title="装饰器的嵌套"></a>装饰器的嵌套</h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@timeit</span></span><br><span class="line"><span class="meta">@do_twice</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"This is my function"</span></span><br></pre></td></tr></tbody></table></figure>

<p>等价于<code>timeit(do_twice(my_func))</code></p>
<h4 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h4><p>希望使用装饰器的方式控制一个函数执行的次数，且次数可作为参数配置</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeat</span>(<span class="params">repeat_nums</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(repeat_nums):</span><br><span class="line">                res = func()</span><br><span class="line">                print(res)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="meta">@repeat(<span class="params">repeat_nums=<span class="number">10</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"This is my func"</span></span><br></pre></td></tr></tbody></table></figure>

<p>其实只是在原来装饰器的模板上，加了一个<code>def repeat(repeat_nums)</code> ，注意</p>
<ul>
<li><code>@repeat(``repeat_nums=10``)</code>实际上会调用内部的<code>decorator</code>函数，这就和之前使用装饰器的原理一样了。因此不要忘了需要加括号。</li>
</ul>
<h3 id="装饰器类"><a href="#装饰器类" class="headerlink" title="装饰器类"></a>装饰器类</h3><p>还记得装饰器语法<code>@``decorator</code> 等价于<code>my_func = decorator(my_func)</code>，如果decorator需要是一个类：</p>
<ul>
<li><code>__init__</code>中需要将func作为参数传入</li>
<li>该类需要可调用，因此需要实现<code>__call__()</code></li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,func</span>):</span></span><br><span class="line">        functools.update_wrapper(self, func) <span class="comment">#不是@functools.wrapper</span></span><br><span class="line">        self.func = func</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self,*args,**kwargs</span>):</span></span><br><span class="line">        <span class="comment"># do sth before</span></span><br><span class="line">        res = self.func(*args,**kwargs)</span><br><span class="line">        <span class="comment"># do sth after</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="meta">@Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span>():</span></span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure>

<h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        <span class="comment"># do sth</span></span><br><span class="line">        res = func()</span><br><span class="line">        <span class="comment"># do sth</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></tbody></table></figure>

<h4 id="轻量级的插件架构"><a href="#轻量级的插件架构" class="headerlink" title="轻量级的插件架构"></a>轻量级的插件架构</h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">PLUGINS = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">func</span>):</span></span><br><span class="line">    PLUGINS[func.__name__] = func</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"My name is <span class="subst">{name}</span>"</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="使用装饰器实现单例"><a href="#使用装饰器实现单例" class="headerlink" title="使用装饰器实现单例"></a>使用装饰器实现单例</h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span>(<span class="params">cls</span>):</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">cls</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> wrapper.ins:</span><br><span class="line">            wrapper.ins = cls(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper.ins</span><br><span class="line">    wrapper.ins = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure>

<h4 id="缓存中间信息"><a href="#缓存中间信息" class="headerlink" title="缓存中间信息"></a>缓存中间信息</h4><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cache</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        functools.wraps(func)</span><br><span class="line">        keys = args + <span class="built_in">tuple</span>(kwargs.values())</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> wrapper.cache:</span><br><span class="line">                wrapper.cache[key] = func(*args,**kwargs)</span><br><span class="line">            <span class="keyword">return</span> wrapper.cache[key]</span><br><span class="line">    wrapper.cache = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@cache</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    <span class="keyword">return</span> fibonacci(num - <span class="number">1</span>) + fibonacci(num - <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="阅读更多"><a href="#阅读更多" class="headerlink" title="阅读更多"></a>阅读更多</h3><p><a href="https://sikasjc.github.io/2018/09/17/pythondecorator/">https://sikasjc.github.io/2018/09/17/pythondecorator/</a></p>
<p><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p01_put_wrapper_around_function.html">https://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p01_put_wrapper_around_function.html</a></p>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Wordpress使用心得</title>
    <url>/post/de09af32/</url>
    <content><![CDATA[<h2 id="1-关于wordpress建站过程中遇到的一些问题及解决方案"><a href="#1-关于wordpress建站过程中遇到的一些问题及解决方案" class="headerlink" title="1. 关于wordpress建站过程中遇到的一些问题及解决方案"></a>1. 关于wordpress建站过程中遇到的一些问题及解决方案</h2><ul>
<li><p>  Filezilla 连接超时LNMP1.5默认是不安装FTP服务的。需要上下传文件时，设置FTP软件（如FlashFXP）连接类型为 “<strong>SFTP over SSH</strong>”即可。</p>
</li>
<li><p>  希望站点主页与WordPress安装目录不同(希望xxx.com打开xxx.com\wordpress)<a href="https://jingyan.baidu.com/article/22fe7ced2f6d1c3002617f38.html?qq-pf-to=pcqq.group">这里可以解决</a></p>
</li>
<li><p>关于301重定向通过修改htaccess实现301重定向，htaccess文件要放在<strong>根目录</strong> ，要删除$1，否则默认定向到/default</p>
<pre><code>  RewriteEngine On
  RewriteCond %{HTTP_HOST} ^laozuo.org [NC]
  RewriteRule ^(.*)$ http://www.laozuo.org/$1 [L,R=301]</code></pre>
</li>
</ul>
<h2 id="2-建站参考教程"><a href="#2-建站参考教程" class="headerlink" title="2. 建站参考教程"></a>2. 建站参考教程</h2><ol>
<li> <a href="https://www.seoimo.com/wordpress-vps/">WordPress建站: 便宜VPS+LAMP搭建+博客安装/优化教程【Vultr &amp; 搬瓦工VPS亲测】</a></li>
<li> <a href="https://www.jianshu.com/p/d7b208efe04c">VPS搭建LAMP安装WordPress建站教程 (搬瓦工VPS亲测 Mac OS环境操作)</a></li>
<li> <a href="https://www.banwagong.com/625.html">搬瓦工VPS安装WordPress详细图文教程</a></li>
</ol>
<h2 id="3-目前网站存在问题"><a href="#3-目前网站存在问题" class="headerlink" title="3. 目前网站存在问题"></a>3. 目前网站存在问题</h2><ol>
<li> vps配置优化</li>
<li> <a href="https://www.seoimo.com/lamp-ssl/#ssl-chain-hsts">开启 HSTS</a>；<a href="https://www.seoimo.com/lamp-ssl/#ssl-sni-setup">关闭 SNI</a>； <a href="https://www.seoimo.com/lamp-ssl/#http-301-https">HTTP全部301重定向到HTTPS</a></li>
</ol>
<h2 id="4-建站大致流程"><a href="#4-建站大致流程" class="headerlink" title="4. 建站大致流程"></a>4. 建站大致流程</h2><ol>
<li> 购买服务器和域名</li>
<li> 域名解析(域名绑定服务器ip)</li>
<li> vps中搭建LAMP环境</li>
<li> 添加域名<code>lnmp vhost add</code></li>
<li> 安装wordpress</li>
</ol>
]]></content>
      <categories>
        <category>七分热爱</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>《小王子》</title>
    <url>/post/40267188/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>“有一天，”你说，“我看了四十四次日落！”</p>
<p>过了片刻你又说：</p>
<p>“你知道吗，人在难过的时候就会爱上日落”</p>
<p>“在你看了四十四次日落那天，你很难过吗”</p>
<p>但小王子没有回答。</p>

</blockquote>

<br>



<blockquote class="blockquote-center">
<p>“可惜从前我什么都不懂！我应该看她的行动，而不是听她的言语！她为我散发芬芳，点亮我的生活。我不应该离开她的，我应该看出藏在她那些小把戏后面的柔情。花儿的心事好难捉摸的！当时我太小了，不懂得爱是什么” </p>

</blockquote>

<br>

<blockquote class="blockquote-center">
<p>“我的生活很单调。我猎杀鸡，人猎杀我。所有的鸡都是相同的，所有的人也是相同的。所以，我感到有点无聊。我已经有点厌倦。但如果你驯化我，我的生活将会充满阳光。我将能够辨别一种与众不同的脚步声。别人的脚步声会让我躲到地下。而你的脚步声就像音乐般美好，会让我走出洞穴。还有，你看。你看到那片麦田吗？我不吃面包。小麦对我来说没有用。麦田不会让我想起什么。这是很悲哀的！但你的头发是金色的。所以你来驯化我是很美好的事情！小麦也是金色的，到时它将会让我想起你。我喜欢风吹过麦穗的声音…..” </p>

</blockquote>

<br>

<blockquote class="blockquote-center">
<p>“你每天最好在相同的时间来，”狐狸说，“比如说你定在下午四点来，那么到了三点我就会开始很高兴。时间越是接近，我就越高兴。等到四点，我会很焦躁，坐立不安；我已经发现了幸福的代价。但如果你每天在不同的时间来，我就不知道该在什么时候期待你的到来…..我们需要仪式。” </p>

</blockquote>

<br>

<blockquote class="blockquote-center">
<p>但我很担心，我想起了狐狸：如果让自己被驯化，就难免会流泪….. </p>

</blockquote>

<br>

<blockquote class="blockquote-center">
<p>“当你抬头看着夜空时，因为我住在某颗星星上面，因为我会在某颗星星上面笑，所以对你来说，就好像所有的星星都在笑。到时你将会拥有会笑的星星。” </p>

</blockquote>

<br>

<blockquote class="blockquote-center">
<p>这真是个伟大的谜题。因为在某个我们不知道的地方，有只我们从来没遇到过的绵羊，它有没有把一朵玫瑰花吃掉，会影响到同样热爱小王子的你和我对整个宇宙的看法….. </p>

</blockquote>]]></content>
      <categories>
        <category>十分人生</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Jupyter遇到的一些问题</title>
    <url>/post/9c79ba11/</url>
    <content><![CDATA[<h2 id="一个报错"><a href="#一个报错" class="headerlink" title="一个报错"></a>一个报错</h2><p><code>import win32api; ImportError: DLL load failed: 找不到指定的程序</code></p>
<h4 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h4><p>224、225新版本发布的有问题，回退到223版本即可</p>
<p><code>pip\conda install pywin32==223</code></p>
<h2 id="一个注意点"><a href="#一个注意点" class="headerlink" title="一个注意点"></a>一个注意点</h2><blockquote>
<p><strong>环境嵌套</strong></p>
<p>当已经激活某个环境时，再次 conda activate <strong>envname</strong> <strong>将发生环境嵌套，而不是切换</strong>。</p>
<p>多个环境嵌套时，软件包可能产生异常行为。</p>
<p>Python 需格外小心！若最内层环境没有安装 Python，所有与 Python 有关的程序（尤其是 pip ）将逐层向外 fallback 直至 base，很容易造成污染。</p>
<p>可通过 conda info 的 shell level 来检查嵌套情况。</p>
<p>如非特别必要，不建议使用环境嵌套。</p>
</blockquote>
<h2 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h2><p>​    通常在<code>conda</code>环境中使用<code>jupyter notebook</code>的步骤是1. <code>activate</code> 进入某个环境 2. 输入 <code>jupyter notebook</code> 开始编辑<code>python</code>文件，此时对应的<code>python</code>版本为<strong>jupyter notebook</strong>内核的 <code>kernel.josn</code>文件中<code>python</code>路径，可使用<br>        </p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br><span class="line">sys.executable </span><br></pre></td></tr></tbody></table></figure><p></p>
<p>查看当前使用的是哪个python解释器。如果PC上除了Anaconda外还装了python官网下载的python，且这个python带有jupyter notebook，注意jupyter会优先使用这个python在<code>kernel.json</code>文件中对应的python解释器。</p>
<p>如果想在A环境下使用B环境的解释器，有如下两种操作</p>
<ul>
<li><p><code>conda install nb_conda</code></p>
<p>直接安装这个包</p>
</li>
<li><p><code>python -m ipykernel install --user --name xxx --display-name "xxx"</code></p>
</li>
</ul>
<p>或者在某个环境中把python加入jupyter 的内核</p>
<p>如果想查看当前jupyter notebook的kernal情况</p>
<ul>
<li><p><code>jupyter kernelspec list</code> 可以列出所有的kernel</p>
</li>
<li><p><code>jupyter kernelspec remove xxx</code> 可以删除名为xxx的kernel</p>
</li>
</ul>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>jupyter notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>写在20岁生日</title>
    <url>/post/d122b347/</url>
    <content><![CDATA[<p>在大学忙了快整整两年</p>
<p>第一年忙着转专业,忙着澳洲的签证.</p>
<p>这一年,熬过了高三般的大二上.也体验了最丰富的大二下,一周三天的假期,完成了好多一直想去试试的事情.</p>
<p>第一场演唱会,第一次志愿者,第一 次撸猫,第一次逃课….</p>
<p>8月11号在王力宏演唱会检票</p>
<p>我坐在检票口一旁的空地上</p>
<p>听着从20米开外会里场传来的伤情的歌</p>
<p>还有几万观众此起彼伏的尖叫</p>
<p>陷入了沉思</p>
<p>脑中浮现出无数个类似的场景</p>
<p>每次都会带着些许遗憾结束一个学期</p>
<p>知道了结果以后 总想如果当初再做那么一点点改变</p>
<p>现在会不会变得更好</p>
<p>会不会就不会那么孤独</p>
<p>还是不习惯</p>
<p>半夜难过睡不着 起来翻通讯录</p>
<p>找不到一个适合的人留言</p>
<p>有时候朋友之间太熟了</p>
<p>反而害怕打搅他们</p>
<p>害怕他们厌烦这个一开口就”我好难过啊”的人</p>
<p>20岁是第三个十年的开始</p>
<p>好像很多大人才聊起的事情 也都会在这十年内被提上日程</p>
<p>琐事和麻烦会一个接一个到来</p>
<p>高中的时候看一些在上大学的UP主,就像小屁孩仰望大人.现在我上大学,他们大学毕业,明明年龄差距没变,却更像是同龄人.</p>
<p>小时候看新闻里播放的故事都觉得离自己很遥远</p>
<p>现在再看好似就发生在身边,或发生在不远的将来</p>
<p>想想去年这个时候,还满脑子都是Luke的生日聚会,Glenelg Beach的沙滩海风,Rundle Mall的路人匆匆.</p>
<p>大学的时间过得太快了</p>
<p>看着周围优秀的人渐渐年少有为</p>
<p>而自己还是普通的不能再普通</p>
<p>那就想办法做个快乐的普通人吧</p>
<p>这几天把整个寝室打扫了一遍</p>
<p>重新布局了书桌</p>
<p>扔了一堆以前舍不得扔小物件</p>
<p>删了一堆舍不得删的照片</p>
<p>别再留念了 </p>
<p>和20岁以前的日子告别吧</p>
<p>全部都 重新开始</p>
<p>20岁 不算太糟 大学里还有一群有趣朋友</p>
<p>20岁 成了班助 还有一群小朋友要照顾</p>
<p>20岁 还有好多不理解的事情 不会处理的问题</p>
<p>20岁 还请多指教</p>
]]></content>
      <categories>
        <category>十分人生</category>
      </categories>
      <tags>
        <tag>生日</tag>
      </tags>
  </entry>
  <entry>
    <title>写在22岁生日</title>
    <url>/post/d5d7637a/</url>
    <content><![CDATA[<h1 id="写在22岁生日"><a href="#写在22岁生日" class="headerlink" title="写在22岁生日"></a>写在22岁生日</h1><p>故事应当在2021年一月份就讲完的，那时下半年的工作也有了着落，和敦敦吃了告别的饭，凯丽和济淙把我送到了余杭，我总算逃离了学校，想着前几个月的心酸与无奈终于可以翻过去。</p>
<p>再不济，三月份讲完也未尝不可。我喜爱这一个多月经历的一切，甚至在担心字节把我对工作的阈值拉得过高，如果下一份达不到这样的标准我会很失望这样幼稚的事情，总之一切都出乎意料般的在往好的方向发展。</p>
<p>那几乎是这一年来数一数二的快乐时光，没有一点学业的压力，白天在工作，中午趁着午休跑到住处改代码，晚上下班继续另一个没做完的项目，我不会觉得累，我只觉得孤独而充实。如果能重来，我多希望我这四年的大学生涯，就在那时能画上句号。</p>
<p><img data-src="https://qiniu.dcts.top/8BAFE4C6-9CA2-4CF3-81B8-C716897A87D6_1_105_c.jpeg" alt="8BAFE4C6-9CA2-4CF3-81B8-C716897A87D6_1_105_c.jpeg"></p>
<p>正如所有随机性的成功，都会有回归平均的那一天。这一年我已经被命运加持了太多我所不配的东西，我知道迟早会坠落的，尽管我尽可能谨小慎微，现实还是不出意外地给了我最猛烈的当头一棒。</p>
<p>在EFC生活的第63天，我开始害怕孤独和独处。纵使我信以为然孤独和独处是我与身俱来的属性，害怕独处这件事还是让我感到吃惊。这不仅仅是字面意义的恐惧，更是推开房门后铺天盖地席来的压抑感。</p>
<p><img data-src="https://qiniu.dcts.top/D6380C62-FCA5-4F7D-8F21-00D30FE68656_1_105_c.jpeg" alt="D6380C62-FCA5-4F7D-8F21-00D30FE68656_1_105_c.jpeg"></p>
<p>我能做的是进门扔下包后就开始逃离，于是在夜色里，在四下无人的街道上，多了具疲惫到不知方向的躯壳。不过相较于中关村的夜晚，EFC对我这样的流离之人倒显得更加包容，住处对面有家凌晨三点才打烊的粥铺，我是那里的常客，它是我深夜里唯一的物质慰藉。</p>
<p><img data-src="https://qiniu.dcts.top/4B25D9F5-AE8E-4086-90C5-B4738B87F011_1_105_c.jpeg" alt="4B25D9F5-AE8E-4086-90C5-B4738B87F011_1_105_c.jpeg"></p>
<p><img data-src="https://qiniu.dcts.top/52C73A53-5208-4B1F-BBFA-AC584B54B413_1_105_c.jpeg" alt="52C73A53-5208-4B1F-BBFA-AC584B54B413_1_105_c.jpeg"></p>
<p><img data-src="https://qiniu.dcts.top/B09EDC2D-9884-430D-BEDC-0D3EC8017C17_1_105_c.jpeg" alt="B09EDC2D-9884-430D-BEDC-0D3EC8017C17_1_105_c.jpeg"></p>
<p><img data-src="https://qiniu.dcts.top/3A1E5C68-BA27-40A9-AFBA-A7641AC158AB_1_105_c.jpeg" alt="3A1E5C68-BA27-40A9-AFBA-A7641AC158AB_1_105_c.jpeg"></p>
<p>从那以后，每当我独处，总会被一种莫名的空虚感包围。但奇怪的是，即使是在和朋友觥筹交错，孤独感也总能趁虚而入，心头就像是有个缺口一般。恍惚间在酒杯碰撞的喧闹中出了神，好似不再属于任何一个群体。</p>
<p><img data-src="https://qiniu.dcts.top/Untitled.png" alt="Untitled"></p>
<p>在这小半年里，余杭下沙来回奔波，时空的不断切换，都是在帮助我学会脱离主体，更加客观地去审视自己。深夜里的散心，也让我对自己越发坦诚，但当我确信这一切皆是我性格上的过错，即使再来一次，我也会落入现在这种地步，就像是给自己判了十恶不赦的罪行。我远比自己想象地更幼稚、虚伪和懦弱。曾经我被告知「你以后回想起这些事情，一定会羞愧到无地自容」时我还不以为然，结果在几个月后，因为这些无意间涌上来的回忆彻夜辗转冷汗直流，我才意识到这句话得到了灵验。这令人毛骨悚然的巨大反差，第一次让我对与人相处感到绝望。可想到自己身为人的一份子，在善良的遮羞布后面也藏着动物本性，曾经爆发过亦或是会在未来的某时某刻再次爆发出来，不禁让我对自身也感到绝望。</p>
<p><img data-src="https://qiniu.dcts.top/Untitled%201.png" alt="Untitled"></p>
<p>我就任由内心的虚无感蔓延，纵使我学琴、阅读、写字也只能眼睁睁看着这个人日渐坠落。回想起那时忙着虚伪的自我救赎，全然不顾工作和学习的忙碌，可身边的人依然给予着我远配不上的评价，我内心的虚无之感多了一层切实的惭愧。</p>
<blockquote>
<p>真正的救赎，并不是厮杀后的胜利，而是能在苦难中找到生的力量和心的安宁。</p>
</blockquote>
<p>望两年后，我的内心能有一种笃定，平静地接受这一年来发生的一切，不再听到内心的抱怨与自责。我愿意为了那一天，准备好把一切再过一遍，这次我攥紧了拳头。</p>
<hr>
<p>这大概就是半年来真实内心的感受，至于何以至此，我已经质问了自己太多次，也实在是疲于找一个合理的解释来麻痹自己。工作的琐碎渐渐让我丧失了作为学生时对一切新事物持有的热情，我急于扭转这种情况却被两件我最抱有期望的事情反噬，陷入了自我怀疑。</p>
<p>只希望若干年后再翻到这里，我能有一种由衷的释然，就像我现在看几年前的文字一般。</p>
]]></content>
      <categories>
        <category>十分人生</category>
      </categories>
      <tags>
        <tag>生日</tag>
      </tags>
  </entry>
  <entry>
    <title>写在23岁生日</title>
    <url>/post/3a150844/</url>
    <content><![CDATA[<h1 id="写在23岁生日"><a href="#写在23岁生日" class="headerlink" title="写在23岁生日"></a>写在23岁生日</h1><p>今年以来的多数日子，美其名曰要目标驱动，实则生活、学习、工作杂糅在一起，工作无法推进于是开始学习，学习累了才记得要生活，生活久了又带着满心的惭愧与自责，开始新一轮循环。像是款敏捷开发的产品，快速地上线、试错、迭代，没有尽头。日夜颠倒的作息，日渐消沉的意志，被一股无形的力量牵着跑，实际上超出了独立奔跑所能到达的速度极限，直到狠狠摔倒了才意识到这一点。</p>
<p>与人相处时产生的荒谬、命运面前的渺小与无力，事与愿违的无可奈何，如同脖颈上的缰绳不断被收紧带来刺痛感，迫使我停下来。当我脱离主体审视自己的时候，忍不住质问这个碌碌无为的个体到底在忙什么，他的存在有任何意义么，荒诞由此产生。</p>
<p>即使深知「一切都毫无意义」的观点在逻辑上就不自洽，可这种虚无缥缈的感觉却又无比真实。如同从高空下坠，伸手想抓着什么可着手之处空无一物。如同木筏漂荡在一望无际的汪洋，随着洋流浮浮沉沉。</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140313418.png" alt="Untitled"></p>
<p>唯有痛苦保留着最初的真实，总是先于虚无，折磨心灵，令人后悔不已。可是用不了多久痛苦被解构，虚无又占了上风。一切都毫无意义，痛苦也好快乐也罢，终归是瞬间的感觉罢了，它的存在只在那一刻。</p>
<p>我询问鱼，人生的意义是什么呢</p>
<p>它说：你别想这么多没用的，你又不是哲学家</p>
<p>我询问巷燕，人生的终极目标是什么呢</p>
<p>它留下了一份标准答案</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140313445.png" alt="Untitled"></p>
<p>我询问海鸥，我们到底要去往何方</p>
<p>它说：去码头整点薯条</p>
<p>好像每个人都有自己的答案，如果这是一场考试的话，大家早已填好答案交卷离场。答案就写在试卷下方，填上任何一个就能立刻结束虚无的煎熬。可正如《西西弗神话》描述的那样，</p>
<blockquote>
<p>“……这种人与生活，演员与布景的分离，正是荒谬的感觉。”（《西西弗的神话》）</p>
</blockquote>
<p>当幕后脏乱堆砌的道具、满脸疲惫的演员显露出来，台上再深情的缠绵悱恻都会化作某种滑稽与挣扎的混合体。若对此依然流露感动之情，总让我觉得虚伪无比。我只是不愿意填一个自欺欺人的答案。</p>
<p>只是有些固执和倔强，我才23岁，也许再想想就能有个属于自己的答案。</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140313462.jpeg" alt="Untitled"></p>
<p>所以，再等等吧，这场考试不会再有倒计时，等到我交卷离场的那天，我一定笑着热泪盈眶。</p>
<p>祝自己23岁生日快乐。</p>
]]></content>
      <categories>
        <category>十分人生</category>
      </categories>
      <tags>
        <tag>生日</tag>
      </tags>
  </entry>
  <entry>
    <title>写在大二上学期</title>
    <url>/post/7ce73c6e/</url>
    <content><![CDATA[<p>太久没写点东西了。有些情感压抑太久无处爆发，想敲点字出来又肚里实在是没墨。很多话就这么堵在嗓子眼，就着凌晨两点的咖啡一口咽下。</p>
<p>我觉得一个把大学过得像高中的人是很失败的。高中只有学习，大学里有学习，还有生活。而生活本身就不是一件容易的事情。大学是换了一个更大的监狱，多了几个门多了几堵围墙。每天忙忙碌碌地上课，碌碌无为到半夜。我这大学一年多，最最开心的时候是大一上期末考最后一门考试成绩出来，我知道我转专业有希望了。当尘埃落定，生活又露出真实的狰狞模样。我依然喜欢我做的事情，我也清楚我现在所学是在积累是在等某一天的厚积薄发，但是这过程太孤独太枯燥了太漫长了。</p>
<p>今年很有幸，认识了很多好老师。这些老师都有一些共同的特点，把学生当朋友，不把成绩分数当做评判的唯一标准，能用人话分享知识，上课不点名，但是座无虚席。acm的刘春英老师也好，李国冰也好，韩敦敦也好。还有吴老师陈老师冯老师，你能很明显的感受到他们确实是希望你通过这一学期的课，能学到点东西。能抢到他们的课，三生有幸。当然今年压力也很大，因为如果我没学好我就不能找老师教的不好的借口了。</p>
<p>今年没做什么好玩的项目，帮儿子做了个网页应该是班里最好的吧，大概是唯一能吹嘘自己的东西了。没得什么奖，参加了一个数学竞赛拿了6分。怎么看待明知道一些比赛得不了奖还积极去参加这种行为？是因为德育分吗，是因为当时脑子热交了钱吗，是因为想要多一份难忘的记忆吗。</p>
<p>大学里取长和补短到底哪个重要，我问了很多人这个问题。其实我之所以为有这种疑问，是因为我在逃避我的短处。我数学很差，所以我觉得我参加数学竞赛很愚蠢，我觉得我做不出ACM的题就是因为我对数字不敏感。我希望人们告诉我大学里要多取长不用去补短，以此得到心里的慰藉。</p>
<p>最近听了很多演讲，马云的，黄西的，我发现成功的人也有一些共同点。对未来充分的积极乐观，对困难挫折的永不退缩。很土的两句话，但他们都做到了然后成功了。我很害怕未来，因为它不能被预测，不能被明确量化。我纠结我这个学期绩点会不会不好看，会不会没奖学金拿，我会因为别人发了一条拿了多少多少奖学金的说说感到不适，并不是嫉妒，而是对自己无能的自责。这真的不是我想要的生活啊。</p>
<p>我一直觉得，知道自己要做什么比自己在做什么更重要。前几天看数据结构书发现书上Dijkstra最优路径的代码其实就是在实现优先队列，就那一下下的触动，那一下下的成就感，我虽然反应慢，但好像也没那么蠢嘛。开学的时候一直在想，等我把作业全部写完，我就怎么样怎么样。如果把自己的房间装饰的很漂亮在请客的话，可能就没有朋友了。作业是写不完的，我要把时间花在自己身上，想做自己喜欢做的事情，学得慢怎么了，哪怕一天学一个知识点，一天做一道题，哪怕花几个小时写这么几个字。但我很快乐。</p>
<p>今年很满足，在物质上得到了自己渴望得到的一切。今年有点遗憾，对物质的追求略大于精神满足。</p>
<p>今年的第二个冬天。想Luke了，想一起去Glenelg Beach吹海风</p>
]]></content>
      <categories>
        <category>十分人生</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>写在大二下的期末考后</title>
    <url>/post/1520b5d6/</url>
    <content><![CDATA[<h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p>感谢秦老师，有点惭愧，感觉今年创新实践的成就根本对不起这个满绩的成绩</p>
<p>感谢付茜茜老师，我真的再也不会逃课去看演唱会了，还傻不拉几的去骗辅导员的假条唉</p>
<p>感谢张旻老师，好像除了体育我还没拿过这么高的分数，这一学期对算法的理解有明显的提升</p>
<p>感谢冯建文老师，比我想象的分数要高得多。跟了冯老师一年，能在大学里遇到这么负责任的老师不知道是有多幸运，以后说起数电和计组不知道是否能吹嘘一把，毕竟我们是冯建文的学生!</p>
<img data-src="http://qiniu.dcts.top/%E5%86%AF%E5%BB%BA%E6%96%87.jpg" style="zoom: 33%;">

<p>感谢王康泰老师，我特么模电没挂，还70多分我的妈啊，这是什么神仙老师啊</p>
<img data-src="http://qiniu.dcts.top/%E6%A8%A1%E7%94%B5%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95.jpg" style="zoom:33%;">

<p>感谢李国冰老师，四学期的体育三学期满绩。跟了李国冰一年，学了好多做人的道理，大学应该是除去知识后所有能力的培养。大骗子李国冰，有缘江湖再见</p>
<img data-src="http://qiniu.dcts.top/%E6%88%B7%E5%A4%96%E6%8B%93%E5%B1%95%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95.jpg" style="zoom: 33%;">]]></content>
      <categories>
        <category>十分人生</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>博客待办事项</title>
    <url>/post/7bc2355c/</url>
    <content><![CDATA[<ul>
<li><del>图片管理</del></li>
<li>页面美化（还是有点丑。。）</li>
<li><del>标签和分类整理</del></li>
<li><del>评论</del></li>
<li>源文件的分支  <a href="https://www.zhihu.com/question/21193762">https://www.zhihu.com/question/21193762</a></li>
<li>建站笔记整理</li>
<li>百度搜索</li>
<li><del>站内搜索</del></li>
<li><del>字数统计</del></li>
<li><del>微信公众号底部链接</del></li>
<li><del>文章摘要（阅读更多）</del></li>
<li>侧边栏社交</li>
<li>分享</li>
</ul>
]]></content>
      <categories>
        <category>七分热爱</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>大一学习资料清单</title>
    <url>/post/4e7be00e/</url>
    <content><![CDATA[<h3 id="大一上学习资料清单"><a href="#大一上学习资料清单" class="headerlink" title="大一上学习资料清单"></a>大一上学习资料清单</h3><hr>
<h3 id="一些资料"><a href="#一些资料" class="headerlink" title="一些资料"></a>一些资料</h3><ol>
<li><p>杭电助手的“<a href="http://dl.hduhelp.com/#">助手期末福利</a>”</p>
<blockquote>
<p>提供各类卷子和资料</p>
</blockquote>
</li>
<li><p>群里发的一些资料</p>
<blockquote>
<p>是我往年准备考试时使用的一些试卷和答案，我不整理了，需要的话自取</p>
</blockquote>
</li>
</ol>
<h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><ul>
<li><a href="https://lyricstraining.com/">听英文歌学英语</a></li>
</ul>
<h3 id="高数、线代、概率论"><a href="#高数、线代、概率论" class="headerlink" title="高数、线代、概率论"></a>高数、线代、概率论</h3><ul>
<li><p><a href="https://space.bilibili.com/74434623/video">小元老师（视频）</a> </p>
<blockquote>
<p>线代、高数、概率论都有，讲的很形象，适合当做正课来听。（正餐，类似大学课堂上课）</p>
</blockquote>
</li>
<li><p><a href="https://space.bilibili.com/88461692?from=search&amp;seid=6895568666388242406"><strong>3Blue1Brown（视频）</strong></a></p>
<blockquote>
<p>主要是线代和高数的微积分这块，用动画的形式讲解线代的本质、微积分的本质（零食，课外补充帮助理解）</p>
</blockquote>
</li>
<li><p><a href="https://www.matongxue.com/">马同学（博客）</a></p>
<blockquote>
<p>帮助通俗易懂地去理解一些概念和定义（甜点，遇到那个概念不懂的时候可以去他博客里查）</p>
</blockquote>
</li>
</ul>
<h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><ul>
<li><p><a href="http://www.icourse163.org/course/ZJU-1001614008?tid=1002163012">浙大翁凯老师的课</a></p>
<blockquote>
<p>几乎每个杭电的都会看这个老师的C语言</p>
</blockquote>
</li>
<li><p><a href="http://acm.hdu.edu.cn/listproblem.php?vol=11">杭电oj</a></p>
<blockquote>
<p>编程语言的学习需要自己上手敲代码才会印象深刻，可以在杭电oj上刷题，在problem archive板块下从11页开始刷。刷OJ时请先到FAQ板块去了解下OJ上提交代码的规则</p>
</blockquote>
</li>
<li><p>写C语言的软件（IDE、文本编辑器）</p>
<blockquote>
<p>首先你需要自行百度去了解什么是IDE，什么是文本编辑器</p>
<p>简单说文本编辑器就是用来码字的，比如win10的文本文档，只是在码字这个基础上装了很多插件，是其可以编译运行代码</p>
</blockquote>
<p><strong>IDE</strong>（很笨重，但不用折腾，安装了就能用）：</p>
<ol>
<li><p>Visual Studio</p>
<blockquote>
<p>号称宇宙最强IDE，但我个人不推荐新手尝试</p>
</blockquote>
</li>
<li><p>DevC++</p>
<blockquote>
<p>如果你是跟着翁凯老师学的 就用这个吧</p>
</blockquote>
</li>
<li><p>code block</p>
</li>
</ol>
<p><strong>文本编辑器</strong>（轻量但是需要装插件，需要折腾，请自行百度了解）:</p>
<ol>
<li><p>sublime text3</p>
<blockquote>
<p>我的主力写代码软件</p>
</blockquote>
</li>
<li><p>vs code</p>
</li>
<li><p>atom</p>
</li>
<li><p><del>记事本</del></p>
</li>
</ol>
</li>
</ul>
<h3 id="建议去自行了解的一些工具"><a href="#建议去自行了解的一些工具" class="headerlink" title="建议去自行了解的一些工具"></a>建议去自行了解的一些工具</h3><ul>
<li><p>什么是Git？</p>
</li>
<li><p>什么是Github，在Github我能找到什么？</p>
</li>
<li><p>什么是Markdown？为什么要用符号来帮助写文章？（本篇文章使用markdown完成）</p>
</li>
<li><p><a href="http://pygments.org/">pygments</a></p>
<blockquote>
<p>一个可以使代码高亮的网站，高亮后的代码放入word文档就不会很丑</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>学习资料</tag>
      </tags>
  </entry>
  <entry>
    <title>微信聊天记录分析（IOS系统）</title>
    <url>/post/e5a040a0/</url>
    <content><![CDATA[<h3 id="获得聊天记录"><a href="#获得聊天记录" class="headerlink" title="获得聊天记录"></a>获得聊天记录</h3><ol>
<li> 使用itunes或其他工具备份ios手机到pc上<strong>不要加密备份</strong></li>
<li> 使用工具，导出指定wx聊天记录。扫文章底部二维码关注公众号，回复 <strong>聊天记录</strong> 可获得工具。一共提供了两个工具，选择其一即可</li>
</ol>
<h3 id="处理和分析聊天记录"><a href="#处理和分析聊天记录" class="headerlink" title="处理和分析聊天记录"></a>处理和分析聊天记录</h3><ol>
<li> 正则表达式</li>
<li> Excel</li>
<li> <a href="http://www.eteste.com/">字数统计</a></li>
<li> Sublime Text</li>
<li> ….</li>
</ol>
<h3 id="生成词云"><a href="#生成词云" class="headerlink" title="生成词云"></a>生成词云</h3><ol>
<li><p>使用在线生成词云网站 <a href="http://www.picdata.cn/picdata/index.php">图悦</a></p>
</li>
<li><p>使用Jieba和WordCloud做词云</p>
</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud, ImageColorGenerator</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取文件内容</span></span><br><span class="line">txt_path=<span class="string">'聊天文件地址如./11.txt'</span></span><br><span class="line">txt_open=(<span class="built_in">open</span>(txt_path,encoding=<span class="string">'UTF-8'</span>).read())</span><br><span class="line"></span><br><span class="line"><span class="comment">#图片路径</span></span><br><span class="line">tran_pic = <span class="string">'如./12.jpg'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置字体</span></span><br><span class="line"><span class="comment">#可自行上网寻找 提供网站 http://www.cyhd.net/html/2014/fonts_0815/19.html</span></span><br><span class="line">font=<span class="string">'字体地址 如 ./STFangSong.ttf'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置背景图片并转化为数组的形式</span></span><br><span class="line">image = Image.<span class="built_in">open</span>(tran_pic)</span><br><span class="line">image_= np.array(image)</span><br><span class="line"></span><br><span class="line"><span class="comment">#jieba分词</span></span><br><span class="line">world_jieba_after = jieba.cut(txt_open, cut_all=<span class="literal">True</span>)<span class="comment">#True全模式分词</span></span><br><span class="line">world_merge= <span class="string">' '</span>.join(world_jieba_after)</span><br><span class="line"></span><br><span class="line">wc = WordCloud(</span><br><span class="line">    background_color=<span class="string">"white"</span>,  <span class="comment"># 背景颜色</span></span><br><span class="line">    max_words=<span class="number">2000</span>,<span class="comment"># 词云显示的最大词数</span></span><br><span class="line">    mask=image_,  <span class="comment"># 设置背景图片</span></span><br><span class="line">    max_font_size=<span class="number">700</span>,  <span class="comment"># 字体最大值</span></span><br><span class="line"></span><br><span class="line">    collocations=<span class="literal">False</span>,</span><br><span class="line">    margin=<span class="number">2</span>,</span><br><span class="line">    <span class="comment"># width=540,</span></span><br><span class="line">    width=<span class="number">768</span>,</span><br><span class="line">    <span class="comment"># height=960,</span></span><br><span class="line">    height=<span class="number">1024</span>,</span><br><span class="line">    font_path=font</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"><span class="comment">#生成词云</span></span><br><span class="line">wc.generate(world_merge)</span><br><span class="line"></span><br><span class="line"><span class="comment">#背景图片生成颜色值</span></span><br><span class="line">image_colors = ImageColorGenerator(image_)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.imshow(wc)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 保存图片</span></span><br><span class="line">wc.to_file(<span class="string">'2.png'</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>使用上述代码时，词云背景自定义需要忽略白色部分（白色的地方没有信息），所以需要将图片不需要的部分变白，方法如下：<ol>
<li> &nbsp;可以用ps 扣除主体后 加一个白色的图层</li>
<li> 使用<a href="https://www.gaoding.com/clip?id=30840600">在线抠图网站</a></li>
</ol>
</li>
</ol>
<h3 id="词云效果"><a href="#词云效果" class="headerlink" title="词云效果"></a>词云效果</h3><p><img data-src="http://qiniu.dcts.top/%E5%BE%AE%E4%BF%A1%E8%AF%8D%E4%BA%91%E5%9B%BE%E7%89%87.png"></p>
<h3 id="使用H5制作总结报告"><a href="#使用H5制作总结报告" class="headerlink" title="使用H5制作总结报告"></a>使用H5制作总结报告</h3><p>我是用的是<a href="%5Bhttp://www.eqxiu.com%5D(http://www.eqxiu.com/)">易企秀</a>，学习成本较低，效果如下</p>
<p><img data-src="http://qiniu.dcts.top/H5%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg"></p>
]]></content>
      <categories>
        <category>七分热爱</category>
      </categories>
      <tags>
        <tag>词云</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影学习笔记（二）———— Pr快捷键</title>
    <url>/post/4235b453/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.bilibili.com/video/av7301488">视频来源B站影视飓风</a></p>
</blockquote>
<ol>
<li><p>快速转场</p>
<ol>
<li> <code>Shift + D</code> 音频和视频的转场</li>
<li> <code>Ctrl + D</code> 单独添加视频转场</li>
<li> <code>Ctrl + Shift + D</code> 单独添加音频转场</li>
<li> 在效果面板中可以设置默认的转场类型</li>
</ol>
</li>
<li><p>波纹剪辑</p>
<ol>
<li> <code>Q 和 W</code></li>
<li> <code>Shift + Q 和 Shift + W</code> 延长素材</li>
</ol>
</li>
<li><p>匹配侦</p>
<ol>
<li> <code>F</code> 在素材监视器上找到对应的帧</li>
<li> <code>Shift + R</code> 反向匹配帧</li>
</ol>
</li>
<li><p>缩放时间轴</p>
<ol>
<li> <code>+/-</code>缩放时间轴</li>
<li> <code>\</code> 快速缩放</li>
<li> <code>Ctrl + \</code> 隐藏顶部项目信息</li>
</ol>
</li>
<li><p> 移动剪辑 1.<code>Alt + 方向键</code> 2.<code>Alt + Shift + 方向键</code> 快速移动</p>
</li>
<li><p>抽取与删除</p>
<ol>
<li> I/O 设定区域</li>
<li> <code>;</code> 删除</li>
<li> <code>'</code> 抽取</li>
</ol>
</li>
<li><p>轨道缩放</p>
<ol>
<li> <code>Ctrl + 加号减号</code></li>
<li> <code>Shift + 加号减号</code> 一次性缩放所有轨道</li>
</ol>
</li>
<li><p> 迅速切换窗口 <code>Shift+123</code></p>
</li>
<li><p>其他快捷键</p>
<blockquote>
<p><a href="https://www.bilibili.com/video/av32947400?spm_id_from=333.788.b_765f64657363.1">视频来源B站南道</a></p>
</blockquote>
<ol>
<li> V 选择箭头</li>
<li> A 往前选中</li>
<li> Shift + A 往后选中</li>
<li> Ctrl + K 编辑</li>
<li> Ctrl + Alt + V 超级黏贴</li>
</ol>
</li>
<li><p>制作电影宽荧幕遮幅</p>
<p>调整图层 效果 搜索裁剪 上11.8 下11.8 添加关键帧 动态效果</p>
</li>
</ol>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>Pr</tag>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影学习笔记（一）————  基础知识介绍</title>
    <url>/post/271a4a90/</url>
    <content><![CDATA[<h1 id="1-光圈"><a href="#1-光圈" class="headerlink" title="1. 光圈"></a>1. 光圈</h1><ul>
<li>光圈是表示镜头中孔径大小的比值。</li>
<li>光圈越大数值越小,光圈越小数值越大。</li>
<li>光圈越大越明亮,光圈越小越暗。</li>
<li>光圈越大虚化越强,光圈越小虚化越弱。</li>
</ul>
<h1 id="2-快门"><a href="#2-快门" class="headerlink" title="2. 快门"></a>2. 快门</h1><ul>
<li><p>比1/4秒慢的，就是很慢的快门速度了。</p>
</li>
<li><p>比1/60秒慢的，就是慢门。</p>
</li>
<li><p>比1/250秒快的，就是高速快门。</p>
</li>
<li><p>比1/2000秒快的，就是很高的高速快门了。</p>
</li>
<li><p>快门慢 曝光时间长 亮（长曝光）</p>
</li>
<li><p>快门快 运动快的东西也会被凝固住</p>
</li>
</ul>
<h1 id="3-ISO"><a href="#3-ISO" class="headerlink" title="3. ISO"></a>3. ISO</h1><ul>
<li>ISO越高越亮 但是照片质量会下降</li>
</ul>
<p><img data-src="https://pic3.zhimg.com/581c5a62630b8b36942a0e54cd4075ae_b.jpg" alt="ISO图"></p>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实验一</title>
    <url>/post/e11b459a/</url>
    <content><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>记录杭电操作系统实验一:编译内核&amp;增加nice系统调用.<strong>本文仅严格记录本人成功的实验流程</strong>,方便日后修改.</p>
<h3 id="二、实验准备"><a href="#二、实验准备" class="headerlink" title="二、实验准备"></a>二、实验准备</h3><ul>
<li>虚拟机: VirtualBox 6.0.12 <a href="https://www.virtualbox.org/">官网</a></li>
<li>Ubuntu: 18.04.3(desktop-amd64) <a href="https://opsx.alibaba.com/mirror">阿里云镜像</a></li>
<li>内核版本:5.3.7 <a href="https://www.kernel.org/">官网</a></li>
</ul>
<h3 id="三、主要参考资料"><a href="#三、主要参考资料" class="headerlink" title="三、主要参考资料"></a>三、主要参考资料</h3><ul>
<li>资料1:<a href="https://www.okcode.net/article/746#_61">Ubuntu 18.04环境下编译Linux内核以及添加系统调用</a></li>
<li>资料2:<a href="https://blog.csdn.net/babybabyup/article/details/79839734">添加一个系统调用，实现对指定进程的nice值的修改或读取功能，并返回系统最新的nice值即优先级prio</a></li>
</ul>
<h3 id="四、-实验过程"><a href="#四、-实验过程" class="headerlink" title="四、 实验过程"></a>四、 实验过程</h3><h4 id="4-1编译内核"><a href="#4-1编译内核" class="headerlink" title="4.1编译内核"></a>4.1编译内核</h4><ul>
<li><p>编译内核严格按照<a href="https://www.okcode.net/article/746#_61">Ubuntu 18.04环境下编译Linux内核以及添加系统调用</a>这篇参考资料进行,直至重启系统后使用命令<code>uname -a</code> 显示最新内核</p>
</li>
<li><p>耗时:晚上睡觉前开始<code>sudo make</code> 一觉醒来就搞定了</p>
</li>
<li><p>部分截图:</p>
<!-- <div align=center >
    <img data-src="http://qiniu.dcts.top/1.jpg" alt="1" style="zoom:33%;display:float;flex:left" />
    <img data-src="http://qiniu.dcts.top/2.jpg" alt="2" style="zoom: 33%;display:float;flex:left" />
    <img data-src="http://qiniu.dcts.top/3.jpg" alt="3" style="zoom:33%;display:float;flex:left" />
    <img data-src="http://qiniu.dcts.top/4.jpg" alt="4" style="zoom: 33%;display:float;flex:left" />
    <img data-src="http://qiniu.dcts.top/5.jpg" alt="5" style="zoom: 33%;" />
</div> -->

<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="http://qiniu.dcts.top/1.jpg"></div><div class="group-picture-column"><img data-src="http://qiniu.dcts.top/2.jpg"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="http://qiniu.dcts.top/3.jpg"></div><div class="group-picture-column"><img data-src="http://qiniu.dcts.top/4.jpg"></div><div class="group-picture-column"><img data-src="http://qiniu.dcts.top/5.jpg"></div></div></div>


</li>
</ul>
<h4 id="4-2增加系统调用"><a href="#4-2增加系统调用" class="headerlink" title="4.2增加系统调用"></a>4.2增加系统调用</h4><p>主要参考资料:<a href="https://blog.csdn.net/babybabyup/article/details/79839734">添加一个系统调用，实现对指定进程的nice值的修改或读取功能，并返回系统最新的nice值即优先级prio</a></p>
<p><strong>以下命令在/usr/src/linux-5.3.6中执行</strong></p>
<h5 id="4-2-1-题目描述"><a href="#4-2-1-题目描述" class="headerlink" title="4.2.1 题目描述"></a>4.2.1 题目描述</h5><ol>
<li>添加一个系统调用，实现对指定进程的nice值的修改或读取功能，并返回系统最新的nice值即优先级prio。<br>建议调用原型为：<code>int mysetnice(pid_t pid, int flag, int nicevalue,void_user*prio,void_user*nice)</code></li>
</ol>
<p><strong>参数含义</strong>：</p>
<ul>
<li><code>pid</code>：进程ID</li>
<li><code>flag</code>：若值为0，表示读取nice值；若值为1表示修改nice值。</li>
<li><code>prio</code>，nice：指向进程当前优先级及nice值。</li>
<li><code>返回值</code>：系统调用成功时返回0，失败时返回错误码EFAULT。</li>
</ul>
<ol start="2">
<li>写一个简单的应用程序测试</li>
</ol>
<h5 id="4-2-2-步骤描述"><a href="#4-2-2-步骤描述" class="headerlink" title="4.2.2 步骤描述"></a>4.2.2 步骤描述</h5><ul>
<li>修改系统调用表</li>
<li>申明系统调用服务例程原型</li>
<li>实现系统调用服务例程</li>
<li>重新编译</li>
<li>编写测试函数进行测试</li>
</ul>
<h5 id="4-2-3-具体操作"><a href="#4-2-3-具体操作" class="headerlink" title="4.2.3 具体操作"></a>4.2.3 具体操作</h5><ol>
<li><p>修改系统调用表</p>
<p><code>sudo vim arch/x86/entry/syscalls/syscall_64.tbl</code></p>
<img data-src="http://qiniu.dcts.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%80%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A1%A8.png" alt="1571416426714" style="zoom: 150%;">

<p><strong>一定要使用__x64 否则报如下错误</strong></p>
<p><img data-src="http://qiniu.dcts.top/52F_FX$7PQ5X60FQ7H66JTF.jpg"></p>
</li>
<li><p>申明系统调用服务例程原型</p>
<p><code>sudo vim include/linux/syscalls.h </code></p>
<p><strong>添加以下代码</strong></p>
<p><code>asmlinkage long sys_mysetnice(pid_t pid,int flag,int nicevalue,void __user*prio,void __user*nice);</code></p>
<p><img data-src="http://qiniu.dcts.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%80%E5%8E%9F%E5%9E%8B%E5%A3%B0%E6%98%8E.png"></p>
</li>
<li><p>实现系统调用服务例程</p>
<p><code>vim kernel/sys.c </code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE5(mysetnice,<span class="keyword">pid_t</span>,pid,<span class="keyword">int</span>,flag,<span class="keyword">int</span>,nicevalue,<span class="keyword">void</span> __user*,prio,<span class="keyword">void</span> __user*,nice){</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> * <span class="title">kpid</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">task</span>;</span></span><br><span class="line">    kpid = find_get_pid(pid);<span class="comment">/* 返回pid */</span></span><br><span class="line">    task = pid_task(kpid, PIDTYPE_PID);<span class="comment">/* 返回task_struct */</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    n = task_nice(task);<span class="comment">/* 返回进程当前nice值 */</span></span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    p = task_prio(task);<span class="comment">/*返回进程当前prio值*/</span></span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        set_user_nice(task, nicevalue);<span class="comment">/* 修改进程nice值 */</span></span><br><span class="line">        n = task_nice(task);<span class="comment">/*重新取得进程nice值*/</span></span><br><span class="line">        p = task_prio(task);<span class="comment">/*重新获取进程prio值 这里和参考资料不一样!!! */</span></span><br><span class="line">        copy_to_user(nice,&amp;n,<span class="keyword">sizeof</span>(n));<span class="comment">/*将nice值拷贝到用户空间*/</span></span><br><span class="line">        copy_to_user(prio,&amp;p,<span class="keyword">sizeof</span>(p));<span class="comment">/*将prio值拷贝到用户空间*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        copy_to_user(nice,&amp;n,<span class="keyword">sizeof</span>(n));<span class="comment">/*将nice值拷贝到用户空间*/</span></span><br><span class="line">        copy_to_user(prio,&amp;p,<span class="keyword">sizeof</span>(p));<span class="comment">/*将prio值拷贝到用户空间*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> EFAULT;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>编译</p>
<p>使用ccache<strong>加快编译</strong></p>
<p>参考文档:<a href="https://blog.csdn.net/fuyuande/article/details/90485882">ubuntu 使用ccache加快linux内核编译速度</a> <strong>注意将</strong><code>usr</code><strong>改为自己的用户名,6G改为10G</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="variable">$sudo</span> make clean</span><br><span class="line"><span class="comment">#仍采用原内核配置文件</span></span><br><span class="line"><span class="variable">$sudo</span> make localmodconfig <span class="comment">#使用localmodconfig加速编译</span></span><br><span class="line"><span class="variable">$sudo</span> make -j8 <span class="comment">#使用多线程编译</span></span><br><span class="line"><span class="variable">$sudo</span> make modules_install</span><br><span class="line"><span class="variable">$sudo</span> make install</span><br></pre></td></tr></tbody></table></figure>

<p><strong>整个过程大概只用了30分钟,编译完内核后一定要重启!!!!!</strong></p>
</li>
<li><p>编写测试函数</p>
<p><code>vim test.c</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> nicevalue;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *prio;</span><br><span class="line">    <span class="keyword">int</span> *nice;</span><br><span class="line">    prio = &amp;p;</span><br><span class="line">    nice = &amp;n;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *     获取pid</span></span><br><span class="line"><span class="comment"> *         */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入pid：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pid);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *     获取nice；</span></span><br><span class="line"><span class="comment"> *         */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pid赋值成功\n请输入nice：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nicevalue);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *     获取flag；</span></span><br><span class="line"><span class="comment"> *         */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"nice赋值成功\n请输入flag：\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;flag);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *     调用添加的系统调用；</span></span><br><span class="line"><span class="comment"> *         */</span></span><br><span class="line">    syscall(<span class="number">334</span>,pid,flag,nicevalue,prio,nice);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *     输出最新的prio以及nice；</span></span><br><span class="line"><span class="comment"> *         */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"现在的nice为%d\n,prio为%d\n"</span>,n,p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>编译运行</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">top</span><br><span class="line">gcc test.c</span><br><span class="line">$./a.out</span><br></pre></td></tr></tbody></table></figure>



</li>
</ol>
<p>​    </p>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实验二</title>
    <url>/post/da9b6b33/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="1-内核态和用户态-特权级"><a href="#1-内核态和用户态-特权级" class="headerlink" title="1.内核态和用户态,特权级"></a>1.内核态和用户态,特权级</h3><p>Linux中每个进程有两个栈，分别用于用户态和内核态的进程执行，其中的内核栈就是用于内核态的堆栈，它和进程的task_struct结构，更具体的是thread_info结构一起放在两个连续的页框大小的空间内。 现在我们从特权级的调度来理解用户态和内核态就比较好理解了，当程序运行在<strong>3级特权级</strong>上时，就可以称之为运行在<strong>用户态</strong>，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，当程序运行在<strong>0级特权级</strong>上时，就可以称之为运行在<strong>内核态</strong>。虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同。运行在用户态的程序不能访问操作系统内核数据结构合程序。</p>
<p>当我们在系统中执行一个程序时，大部分时间是运行在用户态下的。在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。 Linux进程的4GB地址空间，3G-4G部分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程开始是运行在用户态的，如果要执行文件操作，网络数据发送等操作，<strong>必须通过write，send等系统调用</strong>，这些系统调用会调用内核中的代码来完成操作，这时，必须切换到<strong>Ring0</strong>，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回<strong>Ring3</strong>，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。保护模式，通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据。</p>
<p>在内核态下，CPU可执行任何指令，在用户态下CPU只能执行非特权指令。当CPU处于内核态，可以随意进入用户态；而当CPU处于用户态，只能通过<strong>中断的方式</strong>进入内核态。一般程序一开始都是运行于用户态，当程序需要使用系统资源时，就必须通过调用软中断进入内核态. </p>
<p> Intel x86架构的cpu一共有0～4四个特权级，0级最高，3级最低，硬件上在执行每条指令时都会对指令所具有的特权级做相应的检查。硬件已经提供了一套特权级使用的相关机制，软件自然要好好利用，这属于操作系统要做的事情，<strong>对于UNIX/LINUX来说，只使用了0级特权级别和3级特权级</strong>。也就是说在UNIX/LINUX系统中，一条工作在0级特权级的指令具有了CPU能提供的最高权力，而一条工作在3级特权的指令具有CPU提供的最低或者说最基本权力 </p>
<h3 id="2-什么是单体式结构"><a href="#2-什么是单体式结构" class="headerlink" title="2.什么是单体式结构?"></a>2.什么是单体式结构?</h3><p>大内核，将OS的全部功能都做进内核中，包括调度、文件系统、网络、设备驱动器、存储管理。比如设备驱动管理、资源分配、进程间通信、进程间切换管理、文件系统、存储管理、网络等。单体内核是指在一大块代码中实际包含了所有操作系统功能，并作为一个单一进程运行，具有唯一地址空间。大部分UNIX（包括Linxu）系统都采用的单体内核。</p>
<h3 id="3-什么是微内核结构"><a href="#3-什么是微内核结构" class="headerlink" title="3.什么是微内核结构"></a>3.什么是微内核结构</h3><p>微内核只是将OS中最核心的功能加入内核，包括IPC通信、地址空间分配和基本的调度，这些东西处在内核态运行。如：WINCE系统。而其他功能如设备驱动、文件系统、存储管理、网络等作为一个个处于用户态的进程而向外提供某种服务来实现，而且这些处于用户态的进程可以针对某些特定的应用和环境需求进行定制</p>
<h2 id="部分源码理解"><a href="#部分源码理解" class="headerlink" title="部分源码理解"></a>部分源码理解</h2><h3 id="1-task-struct"><a href="#1-task-struct" class="headerlink" title="1. task_struct"></a>1. task_struct</h3><p><a href="https://blog.csdn.net/npy_lp/article/details/7292563">1.Linux进程管理之task_struct结构体（上）</a></p>
<p><a href="https://blog.csdn.net/npy_lp/article/details/7335187">2.Linux进程管理之task_struct结构体（下）</a></p>
<p><a href="https://www.cnblogs.com/shihuvini/p/10043251.html">Linux pid与tgid概念</a></p>
<ol>
<li><p>表示进程亲属关系的成员  </p>
 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">real_parent</span>;</span> <span class="comment">/* real parent process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span> <span class="comment">/* recipient of SIGCHLD, wait4() reports */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span>	<span class="comment">/* list of my children */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span>	<span class="comment">/* linkage in my parent's children list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span>	<span class="comment">/* threadgroup leader */</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>进程名</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> comm[TASK_COMM_LEN];</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h3 id="2-list-head"><a href="#2-list-head" class="headerlink" title="2. list_head"></a>2. list_head</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#kernel/inclue/linux/types.h </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><img data-src="http://qiniu.dcts.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%93%BE%E8%A1%A8%E5%85%84%E5%BC%9F%E5%AD%A9%E5%AD%90%E5%85%B3%E7%B3%BB.jpg"></p>
<h3 id="3-一些函数的理解"><a href="#3-一些函数的理解" class="headerlink" title="3. 一些函数的理解"></a>3. 一些函数的理解</h3><h4 id="3-1-list-for-each"><a href="#3-1-list-for-each" class="headerlink" title="3.1 list_for_each"></a>3.1 list_for_each</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// head是一个list_head</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each(pos, head) \</span></span><br><span class="line"><span class="keyword">for</span> (pos = (head)-&gt;next; pos != (head);pos = pos-&gt;next)</span><br></pre></td></tr></tbody></table></figure>

<p>它实际上是一个 for 循环，利用传入的pos 作为循环变量，从表头 head开始，逐项向后（next方向）移动 pos ，直至又回到 head </p>
<p>注意：此宏必要把list_head放在数据结构第一项成员，至此，它的地址也就是结构变量的地址。</p>
<p><img data-src="http://qiniu.dcts.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%93%BE%E8%A1%A8.jpg"></p>
<h4 id="3-2-struct-pid"><a href="#3-2-struct-pid" class="headerlink" title="3.2 struct pid"></a>3.2 struct pid</h4><p>很多时候在写内核模块的时候，需要通过进程的<strong>pid</strong>(int)找到对应进程的<strong>task_struct</strong>,其中首先就需要通过进程的pid找到进程的<strong>struct pid</strong>，然后再通过<strong>struct pid</strong>找到进程的<strong>task_struct</strong>,实现从pid到task_struct的内核函数struct pid 是进程描述符，在<code>include/linux/pid.h</code> 中，其定义如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">        <span class="keyword">atomic_t</span> count;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> level;</span><br><span class="line">        <span class="comment">/* lists of tasks that use this pid */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">tasks</span>[<span class="title">PIDTYPE_MAX</span>];</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">upid</span> <span class="title">numbers</span>[1];</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>struct pid *find_get_pid(pid_t nr)</code></li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//是通过进程号pid_t nr得到进程描述符(结构体)，并将结构体中的count加1</span></span><br><span class="line"><span class="function">struct pid *<span class="title">find_get_pid</span><span class="params">(<span class="keyword">pid_t</span> nr)</span>  </span></span><br><span class="line"><span class="function"></span>{  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span> </span><br><span class="line">    rcu_read_lock();  </span><br><span class="line">    pid = get_pid(find_vpid(nr));  </span><br><span class="line">    rcu_read_unlock();  </span><br><span class="line">    <span class="keyword">return</span> pid;  </span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure>

<p> <code>find_get_pid</code>和<code>find_vpid</code>有一点差异，就是使用<code>find_get_pid</code>将返回的<code>struct pid</code>中的字段count加1，而<code>find_vpid</code>没有加1 </p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct pid *<span class="title">get_pid</span><span class="params">(struct pid *pid)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        <span class="keyword">if</span> (pid)</span><br><span class="line">                atomic_inc(&amp;pid-&gt;count);</span><br><span class="line">        <span class="keyword">return</span> pid;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>find_vpid</code>和<code>find_pid_ns</code>是一样的</p>
<ul>
<li><code>struct pid *find_vpid(int nr) </code></li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">struct pid *<span class="title">find_vpid</span><span class="params">(<span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        <span class="keyword">return</span> find_pid_ns(nr, task_active_pid_ns(current));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>struct pid *find_pid_ns(int nr, struct pid_namespace *ns)</code></li>
</ul>
<p><a href="http://blog.chinaunix.net/uid-27033491-id-3291637.html">find_pid_ns详解</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">struct pid *<span class="title">find_pid_ns</span><span class="params">(<span class="keyword">int</span> nr, struct pid_namespace *ns)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">        <span class="keyword">return</span> idr_find(&amp;ns-&gt;idr, nr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> <img data-src="http://qiniu.dcts.top/%E4%B8%89%E7%A7%8D%E8%8E%B7%E5%8F%96pid.png"> </p>
<h4 id="3-3-pid-task"><a href="#3-3-pid-task" class="headerlink" title="3.3 pid_task"></a>3.3 pid_task</h4><p>根据PID(结构体)查找task_struct(PCB),一般<code>p = pid_task(find_vpid(pid), PIDTYPE_PID);</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">struct task_struct *<span class="title">pid_task</span><span class="params">(struct pid *pid, <span class="keyword">enum</span> pid_type type)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">result</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (pid) {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span></span><br><span class="line">        first = rcu_dereference_check(hlist_first_rcu(&amp;pid-&gt;tasks[type]),</span><br><span class="line">        lockdep_tasklist_lock_is_held());</span><br><span class="line">        <span class="keyword">if</span> (first)</span><br><span class="line">            result = hlist_entry(first, struct task_struct, pids[(type)].node);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="3-4-list-entry"><a href="#3-4-list-entry" class="headerlink" title="3.4 list_entry"></a>3.4 list_entry</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// list_entry 就是 container_of </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line">	container_of(ptr, type, member)</span><br></pre></td></tr></tbody></table></figure>

<p> 那<code>container_of(ptr, type, member)</code>,又是什么呢</p>
<h4 id="3-5-container-of"><a href="#3-5-container-of" class="headerlink" title="3.5 container_of"></a>3.5 container_of</h4><p><a href="https://www.cnblogs.com/hicjiajia/archive/2012/07/01/2571791.html">资料</a> </p>
<p><a href="https://blog.csdn.net/zsj100213/article/details/81843523">通俗理解</a></p>
<p><code>container_of(ptr, type, member)</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) ({			\</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="title">typeof</span><span class="params">( ((type *)<span class="number">0</span>)-&gt;member )</span> *__mptr </span>= (ptr);	\</span><br><span class="line">        (type *)( (<span class="keyword">char</span> *)__mptr - offsetof(type,member) );})	</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p> container_of()的作用就是通过一个结构变量中一个成员的地址找到这个结构体变量的首地址</p>
<p>比如</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Struct test</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">char</span> k;</span><br><span class="line">};</span><br><span class="line">Struct test temp;</span><br></pre></td></tr></tbody></table></figure>

<p>现在呢如果我想通过<code>temp.j</code>的地址找到<code>temp</code>的首地址就可以使用<code>container_of(&amp;(temp.j),struct test,j);</code> </p>
<p>如果我能知道<code>temp.j</code>的地址A,也能知道<code>temp.j</code>的偏移量B,那么A-B就是temp的首地址</p>
<p>网上有一种很形象的比喻:<code>x-&gt;member = ptr</code>，求 x (结构体)的地址是多少</p>
<h4 id="3-6-for-each-process"><a href="#3-6-for-each-process" class="headerlink" title="3.6 for_each_process"></a>3.6 for_each_process</h4><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for_each_process(p) \</span></span><br><span class="line">	<span class="keyword">for</span> (p = &amp;init_task ; (p = next_task(p)) != &amp;init_task ; )</span><br></pre></td></tr></tbody></table></figure>

<p>就是个for循环,其中<code>p = next_task(p)</code>,这个<code>next_task</code>是怎么实现的呢</p>
<h4 id="3-6-next-task"><a href="#3-6-next-task" class="headerlink" title="3.6 next_task"></a>3.6 next_task</h4><p>Linux内核链表,其中next_task也是宏循环控制语句，在<code>/include/linux/sched/signal.h</code>中：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_task(p) \</span></span><br><span class="line">	list_entry_rcu((p)-&gt;tasks.next, struct task_struct, tasks)</span><br></pre></td></tr></tbody></table></figure>

<p>而task_struct中有：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> {</span>    </span><br><span class="line">...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">tasks</span>;</span></span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里的<code>list_entry_rcu</code>作用和<code>list_entry</code>是一样的,我通过task_struct中, 1️⃣ tasks这个成员变量,2️⃣tasks这个成员变量的地址<code>(p)-&gt;tasks.next</code>,得到下一个task_struct的首地址,即下一个进程</p>
<h2 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h2><p><a href="https://github.com/TD21forever/HDU_operating_system">杭电操作系统实验二代码</a></p>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理笔记（1）——三级模式二级映射</title>
    <url>/post/d6ef9902/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>数据库（DataBase）</p>
<blockquote>
<p>相关数据的集合，数据由DBMS统一管理和维护</p>
</blockquote>
</li>
<li><p>数据库系统（DataBase System）</p>
<blockquote>
<p>由计算机硬件、操作系统、DBMS、DB、应用程序、用户、数据库开发和管理人员</p>
</blockquote>
</li>
<li><p>数据库管理系统（DataBase Management System）</p>
<blockquote>
<p>向用户提供一套命令，管理数据库</p>
</blockquote>
</li>
</ul>
<h3 id="数据的三级模式"><a href="#数据的三级模式" class="headerlink" title="数据的三级模式"></a>数据的三级模式</h3><p>​    <strong>目的：将用户应用和数据库分离</strong></p>
<p><img data-src="http://qiniu.dcts.top/%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E4%BA%8C%E7%BA%A7%E6%98%A0%E5%B0%84.png" alt="img"></p>
<ol>
<li><p>模式(概念集)</p>
<ul>
<li>也称逻辑模式</li>
<li>概括出一个数据库所需的所有数据，并抽像出这些数据间的逻辑结构和各个数据的特征，依此才能开始建立数据库。</li>
<li>模式不是数据库本身，仅仅描述数据库的结构。</li>
<li>不涉及硬件环境和物理存储，不和任何计算机语言有关</li>
<li>DBMS提供模式描述语言(模式DDL)</li>
</ul>
</li>
<li><p>外模式(用户级)</p>
<ul>
<li>也称子模式或者用户模式</li>
<li>用户能看到的数据库中的各个表，这些表中包含的数据以及数据之间的联系（表的逻辑结构）是跟某个应用或用户具体的需求相关的</li>
<li>外模式描述的是一个特定用户感兴趣的那部分数据库，隐藏数据库的其他部分</li>
<li>是模式的子集，不同用户外模式不同</li>
<li>DBMS提供外模式描述语言(Sub-DDL) </li>
</ul>
</li>
<li><p>内模式(物理级)</p>
<ul>
<li>也叫存储模式</li>
<li>描述数据库中的所有数据在物理介质上的存储形式</li>
<li>定义了数据库中全部数据的物理结构，定义了存储方法、存储策略</li>
<li>DBMS提供内模式描述语言(内模式DDL)</li>
</ul>
<h4 id="三级模式总结"><a href="#三级模式总结" class="headerlink" title="三级模式总结"></a>三级模式总结</h4><ol>
<li>一个应用程序只能启用一个外模式，一个外模式可被多个应用程序使用</li>
<li>对于一个数据库系统来说，只有一个模式和内模式，但可以有多个外模式</li>
</ol>
</li>
</ol>
<h3 id="数据的二级映像"><a href="#数据的二级映像" class="headerlink" title="数据的二级映像"></a>数据的二级映像</h3><ol>
<li>外模式/模式<ul>
<li>当模式改变时，只要相应改变外模式/模式映像，即可使外模式保持不变</li>
<li>数据的逻辑独立性</li>
</ul>
</li>
<li>模式/内模式<ul>
<li>当存储方式发生改变时，只需要修改这个模式/内模式映像就可以保持模式不变</li>
<li>数据的物理独立性</li>
</ul>
</li>
<li>SQL的三级模式<ol>
<li>基本表<ul>
<li>基本表是模式的基本内容</li>
<li>实际存在的关系</li>
</ul>
</li>
<li>视图 <ul>
<li>外模式的基本单位</li>
<li>视图是逻辑上的定义，实际并不存在（虚表）</li>
</ul>
</li>
<li>存储文件<ul>
<li>内模式的基本单位</li>
<li>每一个存储文件可以存储一个或多个基本表的内容</li>
<li>存储文件的存储结构对用户透明</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理笔记（2）——概念模型和数据模型</title>
    <url>/post/caace43d/</url>
    <content><![CDATA[<h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><ol>
<li><p>实体-联系模型(E-R模型)</p>
<ul>
<li>实体集</li>
<li>属性</li>
<li>联系</li>
</ul>
</li>
<li><p>一些名词</p>
<ul>
<li><p>实体</p>
<ul>
<li>客观存在并且可相互区别的事物</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li>属性名(职工号，姓名，性别，年龄，婚否)</li>
<li>属性值(1001,Tim,Male,43,Married)</li>
</ul>
</li>
<li><p>实体集</p>
<ul>
<li>所有属性名完全相同的实体在一起组成集合（简单理解为一张职工信息表里的所有职工，每个职工是个实体）</li>
</ul>
</li>
<li><p>域</p>
<ul>
<li>对属性取值的范围限制</li>
</ul>
</li>
<li><p>码</p>
<ul>
<li>唯一确定实体的属性(比如职工号能确定每个职工)</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><ol>
<li><p>层次模型</p>
<ul>
<li>非关系模型</li>
<li>淘汰了</li>
</ul>
</li>
<li><p>网状模型</p>
<ul>
<li>菲关系模型</li>
<li>淘汰了</li>
</ul>
</li>
<li><p><strong>关系模型</strong></p>
<ul>
<li><p>关系是关系模型中最基本的数据结构</p>
</li>
<li><p>主要术语</p>
<ul>
<li><p>关系</p>
<p>一个关系对应一个二维表</p>
</li>
<li><p>属性</p>
<p>二维表的列，叫做属性</p>
</li>
<li><p>域</p>
<p>属性值的取值范围</p>
</li>
<li><p>元组</p>
<p>二维表的每一行，叫做元组</p>
</li>
<li><p>分量</p>
<p>元组中的每一个属性值</p>
</li>
<li><p>候选码（简称码）</p>
<p>某个属性(或者多个属性形成属性组)<strong>的值</strong>能唯一标识关系中的各个元组,<strong>且不含多余的属性</strong></p>
<p>如下表中,图书证和学号都可以唯一标识一个元组,学号和图书证都可以作为候选码</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th align="left">性别</th>
<th>年龄</th>
<th>图书证号</th>
<th>所在系</th>
</tr>
</thead>
<tbody><tr>
<td>S3001</td>
<td>张明</td>
<td align="left">男</td>
<td>22</td>
<td>B20050101</td>
<td>外语</td>
</tr>
<tr>
<td>S3002</td>
<td>李静</td>
<td align="left">女</td>
<td>21</td>
<td>B20050102</td>
<td>外语</td>
</tr>
<tr>
<td>S4001</td>
<td>赵丽</td>
<td align="left">女</td>
<td>21</td>
<td>B20050301</td>
<td>管理</td>
</tr>
</tbody></table>
</li>
<li><p>主码（PrimaryKey）</p>
<p>如果有多个候选码,选其中一个为主码</p>
</li>
<li><p>主属性</p>
<p>包含在任何一个候选码中的属性</p>
</li>
<li><p>外部码</p>
<p>关系中的某个属性虽然<strong>不是这个关系的主键</strong>，但它却<strong>是另外一个关系的主键</strong>时，则称之为外键或者外码</p>
</li>
<li><p>关系模式</p>
<p>关系名+全部属性的集合</p>
<p><strong>职工(职工号,姓名,性别,年龄,婚否,职称,所在部门)</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>面向对象模型</p>
</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li><p>什么是概念模型</p>
<p>E-R图（一对一、一对多、多对多）</p>
<p><img data-src="http://qiniu.dcts.top/ER%E5%9B%BE.png" alt="1555732724053"></p>
</li>
<li><p>什么是关系模型</p>
<p>最常用的数据模型</p>
<p><img data-src="http://qiniu.dcts.top/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.png" alt="1555732868332"></p>
</li>
<li><p><strong>如何实现E-R模型向关系模型的转化</strong></p>
<p>见课本</p>
</li>
</ol>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习入门（一）</title>
    <url>/post/53dcc771/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>根据我自己的学习资料，总结了下机器学习入门时经常会遇到的几个问题。</p>
<h3 id="什么是人工智能？"><a href="#什么是人工智能？" class="headerlink" title="什么是人工智能？"></a>什么是人工智能？</h3><ol>
<li> ❓ 什么是强人工智能？请自行百度解决</li>
<li> ❓ 什么是弱人工智能？请自行百度解决</li>
</ol>
<h3 id="什么是机器学习？"><a href="#什么是机器学习？" class="headerlink" title="什么是机器学习？"></a>什么是机器学习？</h3><p> 阅读<a href="https://www.cnblogs.com/subconscious/p/4107357.html">从机器学习谈起</a>回答下列问题：</p>
<ol>
<li> ❓ 什么是监督学习？什么是无监督学习？</li>
<li>❓ 什么是线性回归？<ul>
<li>  拓展阅读：<a href="https://www.matongxue.com/madocs/818.html">如何理解最小二乘法</a></li>
</ul>
</li>
<li> ❓ 什么是逻辑回归？</li>
<li>❓ 除了神经网络算法和回归算法，还有哪些机器学习算法？<ul>
<li>  拓展阅读：<a href="http://ai.51cto.com/art/201712/561181.htm">漫画解读：轻松看懂机器学习十大常用算法</a></li>
</ul>
</li>
</ol>
<h3 id="什么是人工神经网络？"><a href="#什么是人工神经网络？" class="headerlink" title="什么是人工神经网络？"></a>什么是人工神经网络？</h3><p>参考资料： 阅读<a href="https://www.cnblogs.com/subconscious/p/5058741.html">神经网络浅讲：从神经元到深度学习</a>回答问题：</p>
<ol>
<li> ❓ 权重W如果表示为$ W_{2,3}^{(2)}$是什么意思？</li>
<li> ❓ 神经元如果表示为$a_1^{(2)}$是什么意思？</li>
<li> ❓ 常见的激活函数有哪些？这些激活函数的效果是什么？<a href="https://blog.csdn.net/tyhj_sf/article/details/79932893">常用激活函数（激励函数）理解与总结</a></li>
<li> ❓ 为什么两个线性分类任务结合就可以做非线性分类任务？</li>
</ol>
<p><strong>认真</strong>观看三个视频(不做强制要求，但是<strong>强烈推荐</strong>) </p>
<p><a href="https://www.bilibili.com/video/av15532370/?spm_id_from=333.788.videocard.1">【官方双语】深度学习之神经网络的结构 Part 1 ver 2.0</a></p>
<p> <a href="https://www.bilibili.com/video/av16144388/?spm_id_from=333.788.videocard.0">【官方双语】深度学习之梯度下降法 Part 2 ver 0.9 beta</a> </p>
<p><a href="https://www.bilibili.com/video/av16577449/?spm_id_from=333.788.videocard.0">【官方双语】深度学习之反向传播算法 上/下 Part 3 ver 0.9 beta</a> </p>
<p>进一步理解梯度下降、反向传播</p>
<h3 id="什么是深度学习？"><a href="#什么是深度学习？" class="headerlink" title="什么是深度学习？"></a>什么是深度学习？</h3><p>参考资料：</p>
<ol>
<li> <a href="https://blog.csdn.net/solo95/article/details/79165300">What is Deep Learning?（什么是深度学习？）</a></li>
</ol>
<p>阅读<a href="https://bigquant.com/community/t/topic/128034">深度概览卷积神经网络全景图，没有比这更全的了</a> 回答问题：</p>
<ol>
<li> ❓ 什么是卷积神经网络？卷积神经网络的发展历史？</li>
</ol>
<ul>
<li>  拓展阅读<a href="https://bigquant.com/community/t/topic/126015">一日搞懂卷积神经网络</a></li>
<li>  拓展阅读<a href="https://www.dcts.top/?p=45">CNN&amp;Alexnet模型简单总结</a></li>
</ul>
<ol start="2">
<li> ❓ 除了卷积神经网络，还有什么多层神经网络模型？</li>
</ol>
<ul>
<li>  可以再<a href="https://space.bilibili.com/243821484/video?tid=0&amp;page=2&amp;keyword=&amp;order=pubdate">莫烦python</a>中寻找相关网络模型形象的概述</li>
</ul>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>入门</tag>
        <tag>学习资料</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币投资心得</title>
    <url>/post/372d12c5/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p>人没有办法做到很理性，这个世界上不存理想的人。这个世界上只存在一般的人 </p>

</blockquote>

<p>我只是一般人，既然是一般人，就要承认自己在面对诱惑时无法永远都保持理智与理性，我能做的是让自身尽量远离诱惑，而让机器，让代码，让绝对的理性去代替我做决策。</p>
<p>幸运的是，我有一套交易策略，并且有一套与之匹配的能严格执行策略的系统。我要做的是不断优化系统的同时，尽最大可能减少人为的干预，让系统带我走向局部最优即可。</p>
<p>永远不要想着靠合约去一夜暴富，因为这不是在赌博，这是在投资。马太效应一定会回归平均。靠运气赚的钱总有一天会连本带息地还回去，把合约当做投资，能在力所能及的情况下赚点小钱足够了。</p>
<p>我曾经也尝试过手操，但手操会有如下的后果</p>
<ul>
<li>急迫的回本欲望</li>
<li>强烈的抗拒止损的心理</li>
<li>将亏损的结果怪罪到手操不当上</li>
</ul>
<p>手操很多时候是逆趋势而上，对抗趋势又不愿止损，迎来的就是爆仓。然后又将自己的亏损结果怪罪到自己不当的操作上。等冷静下来后，又开始急迫的回本欲望，又是一轮可怕的循环。</p>
<p>因此有一些原则，我把它标定为是不可逾越的底线：</p>
<ul>
<li>三倍杠杆是底线，不得大于三倍</li>
<li>不做陌生币种，根据回测数据选择币种</li>
</ul>
<p>人啊，需要限制自己的自由，克制内心的无尽的欲望来保护自己。</p>
<p>永远要带着敬畏之心。</p>
<p><img data-src="https://qiniu.dcts.top/%E6%95%AC%E7%95%8F.jpg" alt="敬畏"></p>
<h3 id="2021年1月4日更新"><a href="#2021年1月4日更新" class="headerlink" title="2021年1月4日更新"></a>2021年1月4日更新</h3><p>经历了人生第一次爆仓。没多少钱，但确实是把我吓到了。怎么爆的仓？ETH涨疯了，BTC开始回调，于是20倍做空ETH，半小时爆仓…..</p>
<p>讽刺的是，就在前一天我们还修改了策略，还千叮咛万嘱咐，再手操就是傻逼。结果还是抵挡不住内心的诱惑。还好只是几百块，不是几十万也不是几百万。很多话明明是我自己讲出来的，可我自己都做不到。人啊，我终于开始明白为什么总说人的虚伪，人是永远都无法克制内心的贪婪的，人能做的只能是远离贪婪的源头。</p>
<p><img data-src="https://qiniu.dcts.top/%E4%BA%A4%E6%98%93%E8%AD%A6%E5%91%8A.jpg" alt="交易警告"></p>
<p><img data-src="https://qiniu.dcts.top/%E4%BA%A4%E6%98%93%E8%AD%A6%E5%91%8A2.jpg" alt="交易警告"></p>
]]></content>
      <categories>
        <category>七分热爱</category>
      </categories>
      <tags>
        <tag>投资</tag>
        <tag>数字货币</tag>
      </tags>
  </entry>
  <entry>
    <title>科目三过啦</title>
    <url>/post/280328b7/</url>
    <content><![CDATA[<p>科三内容真的挺少的，折算成大学课程，估计就一节课45分钟的量。所以早早地预约，练了四个上午，就去考场熟悉道路，准备第二天的考试。考前一天熟悉道路，我练的不好，每个人开四次，挂了两次。烈日当头，车里如摆设般的空调，没有空调的候车室，轮流练车时无止境的等待，加上练车时教练还在一旁啰啰嗦嗦，实在是磨人耐心。想着老子要是这次没过，就特么不学了。练车时我都感觉自己是一具没有灵魂的空壳，全程靠教练指挥，越练越拘谨，越练越没信心。</p>
<p>第二天考试，和我一辆车里的另一个哥们先考，在公交车站牌，刹车踩重了，“档位与速度不匹配”，挂了，回起点，又出发，又在公交车站牌，刹车踩轻了，“未按规定减速慢行”，挂了….吓得我立马找机会塞了安全员一张毛爷爷。于是，我起步忘按喇叭，拍大腿提醒我。公交车站牌敲窗户提醒我，帮忙踩了脚刹车。第一个路口帮忙踩了脚刹车。百米冲刺速度降太慢，帮忙踩了脚刹车。靠边停车，帮忙点了下刹车，我立马踩离合刹车跟进，回空挡拉手刹一气呵成，“成绩合格”。然后我科三就结束了，结束的意犹未尽。</p>
<p>我挺不愿意提这件事情的，因为我清楚地记得当我爸妈说别人科三都是这么做的时，我还义正言辞“我才不会这么做，他凭什么拿我钱，我干嘛给他钱？”，当时还愤慨激昂，觉得自己不干这种”肮脏“的事情，现在呢，”如果没有那几脚刹车，我明确肯定我是过不了科三的“，我考完这么感慨。真的，我到现在还是这么感慨的，甚至觉得多给一张也不为过。事后想了想，这样做其实是把安全员和我绑在了同一条船上，大学的象牙塔里呆久了，又怎会知道社会里水有多深。</p>
<hr>
<p>其实7月22日上午就考完了,但那天一直都不愿去回忆，有太多让我后怕的东西。如果我是第一个考试的，如果第一个哥们没挂掉，我可能就没时间和安全员打招呼，就不会有之后的提醒和帮踩刹车，就会在同一个点挂两次，就又特么又要在大太阳底下没完没了的开25码，开过来开过去，又要浪费这么枯燥无聊的等待时间。还好啊，都结束了。</p>
]]></content>
      <categories>
        <category>十分人生</category>
      </categories>
      <tags>
        <tag>学车</tag>
      </tags>
  </entry>
  <entry>
    <title>科目二复习</title>
    <url>/post/2d9df1e8/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>以为今天不练车，一觉睡到大天亮。起来看到手机里十几个教练的未接电话就蒙了。原来早上的喇叭声，不是堵车是在喊我练车。。。。</p>
<p>可他也没提前通知，让我误以为今天他去上虞考试不练车，哎。搞得我有点惭愧</p>
<p>所以复习下科目二的几个点，弥补下内心的愧疚</p>
<h3 id="倒车入库"><a href="#倒车入库" class="headerlink" title="倒车入库"></a>倒车入库</h3><ol>
<li>遇到肩膀线向右打一圈多，回方向把车子放正。</li>
<li>倒车遇到肩膀线向右打死，遇到库角回半圈，看到底部蓝线回完</li>
<li>看反光镜，左边大往右边调，右边大往左边调</li>
<li>换一档，遇到肩膀线向左打一圈半</li>
<li>前轮压线后，倒退，车身与石头成一条直线，向左打死</li>
<li>回方向盘，调整车距</li>
</ol>
<h3 id="侧边停车"><a href="#侧边停车" class="headerlink" title="侧边停车"></a>侧边停车</h3><ol>
<li>保持左边1.5米左右</li>
<li>倒车，肩膀线向右打死</li>
<li>看到红牛罐回完</li>
<li>左后轮压黄线向左打死</li>
<li>等到前轮进入黄线，停车，换一档，打转向灯</li>
<li>看到红牛罐回完，离合器压一压减速</li>
<li>注意开出来不要压线</li>
</ol>
<h3 id="S弯"><a href="#S弯" class="headerlink" title="S弯"></a>S弯</h3><ol>
<li>肩膀线右打一圈，拉直车身，保持左边50cm左右进入</li>
<li>肩膀线左打一圈进入第一个弯道，看左后轮，不要压线，看距离调整车距</li>
<li>回完，对点，进入第二个弯道，看前轮，头伸出去，调整距离不要压线</li>
</ol>
<h3 id="直角转弯"><a href="#直角转弯" class="headerlink" title="直角转弯"></a>直角转弯</h3><ol>
<li>提前打转向灯，往右靠一点，肩膀线向左打死，速度慢一点</li>
</ol>
<h3 id="取卡和上坡停车"><a href="#取卡和上坡停车" class="headerlink" title="取卡和上坡停车"></a>取卡和上坡停车</h3><ol>
<li>取卡往左靠，距离边线30cm之内</li>
<li>上坡对点，向右靠</li>
<li>踩离合踩刹车，拉手刹，慢抬离合，车子抖起来松刹车，不准溜坡，上不去踩油门</li>
</ol>
]]></content>
      <categories>
        <category>十分人生</category>
      </categories>
      <tags>
        <tag>学车</tag>
      </tags>
  </entry>
  <entry>
    <title>科目二结束</title>
    <url>/post/762968e9/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>总算结束了这该死的科目二，这几天下来身心俱疲，每次早起练车内心都是强烈的抗拒，刚熬过大学的期末考，暑假又是一个接一个的训练、考试，实在是难以说服自己去接受。好在过了，长舒一口气。拿驾照之路还长，不过这几天可以歇一歇了，再接着训练科三之前，总算是可以做点自己计划中的事情，就再回味回味这份经历。</p>
<h3 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h3><h4 id="7月10日-9-24"><a href="#7月10日-9-24" class="headerlink" title="7月10日 9:24"></a>7月10日 9:24</h4><p>油门踩到底，下了坡，听到旁边机子说考试合格，然后被安全员指挥到起始位置。下车，和安全员说谢谢，走出考场，路上一直在口吐芬芳，骂着这该死的科目二总算结束了。</p>
<h4 id="7月10日9-14"><a href="#7月10日9-14" class="headerlink" title="7月10日9:14"></a>7月10日9:14</h4><p>上车踩了踩离合，转了转方向盘，觉得很舒服。起步后一直在自言自语，给自己提醒要对的点。说真的，下次不一定有这么舒服的离合，这么舒服的方向盘，这么舒服的肩膀线，这么舒服的天气，这么熟悉的道路了。</p>
<h4 id="7月10日-9-00"><a href="#7月10日-9-00" class="headerlink" title="7月10日 9:00"></a>7月10日 9:00</h4><p>在D区等6号车，车上的大哥一直很顺利，开到上坡久久没下来我就知道他没了，有点害怕，感觉是辆破车啊。</p>
<hr>
<p>考试比我想象的顺利，我把原因归结为运气好。今天确实天时地利人和，甚至于今天去的<strong>10个人居然全都过了</strong>。但考前实在是太紧张，漫长的等待时间把内心的焦躁快推到了极限了，一直在担忧，没有肩膀线怎么办，点对错了怎么办，车子不习惯怎么办，上坡熄火怎么办…..</p>
<p>想想驾考是我经历的第一场，与不同龄人同台竞争的考试，考试水平与学历与年龄与见识无关。客观的来说其实驾考的内容很少，而且容错率挺高的，科目二要记住的内容加起来估计也就模电一章的知识点的量，考前还能练考场，相当于考前就把试卷发你了，而且允许你做两次。但你说让我现在再去考一次？我死都不想再踏进那个考场半步了，而且我肯定会挂…..</p>
<h3 id="练车"><a href="#练车" class="headerlink" title="练车"></a>练车</h3><p>看知乎上有好多关于驾考的话题，像什么科目二考试技巧、科目二挂科怎么办….之类的，我考前还以此为参考资料，考完觉得其实没必要去看这些技巧和心灵鸡汤之类的东西。其实最好还是以教练教的为标准，有不懂得就直接问教练就好了，怕忘记就自己根据教练讲的记在本子上。知乎上的话题大多经过作者艺术渲染，带入太多个人情绪了，而且和教练教的方法不一定统一，反而影响了心态，慌了自己手脚。</p>
<p>花了两天时间把科目二的内容学会了，然后考前连着四、五天一直在练车。练车最烦的还是等待，等待实在是漫长，坐在车里玩手机，没心思背单词，知乎刷了一遍又一遍，就干等着，浪费时间。每天重复同样的内容，几个点对来对去，明明就这么点内容，考前练到第三天就已经对学车产生了生生的厌恶，心想着我特么要是没过我就不学车了。</p>
<p>还是有进步的，毕竟从第一天连离合踩都不稳到今天起码踩着离合能溜溜弯。很期待科目三结束后自己的进步。</p>
]]></content>
      <categories>
        <category>十分人生</category>
      </categories>
      <tags>
        <tag>学车</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员的自我修养 | 目标文件</title>
    <url>/post/128714c8/</url>
    <content><![CDATA[<h1 id="第三章-目标文件"><a href="#第三章-目标文件" class="headerlink" title="第三章-目标文件"></a>第三章-目标文件</h1><aside>
🧐 动态链接库是一种文件类型，而动态链接是一种使用这种文件类型的方法


</aside>

<p>编译器编译源代码后生成的文件叫做目标文件，格式上来说，它是已经编译后的可执行文件格式，只是还没有经过链接过程。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在Linux中目标文件是ELF格式的，其中，除了文件头还有很多段，比如数据段、代码段</p>
<h3 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h3><p>目标文件在Linux中是ELF格式（Executable Linkable Format），除此之外还有很多ELF格式的文件</p>
<ul>
<li><p>可重定位文件</p>
<ul>
<li>Linux的 .o</li>
<li>这类文件包含了代码和数据，可以被用来链接成可执行文件或共享目标文件</li>
<li>静态链接库</li>
</ul>
</li>
<li><p>可执行文件</p>
<ul>
<li>/bin/bash 下的文件，可以直接执行</li>
</ul>
</li>
<li><p>共享目标文件</p>
<ul>
<li>Linux 的 .so</li>
</ul>
<p><img data-src="https://qiniu.dcts.top/typora/202303140236370.png" alt="Untitled"></p>
</li>
<li><p>核心转储文件</p>
</li>
</ul>
<h3 id="目标文件的内容"><a href="#目标文件的内容" class="headerlink" title="目标文件的内容"></a>目标文件的内容</h3><p><img data-src="https://qiniu.dcts.top/typora/202303140236850.png" alt="Untitled"></p>
<p>有不同的段</p>
<ul>
<li><p>文件头</p>
<ul>
<li>描述整个文件的属性<ul>
<li>是否可执行</li>
<li>是静态链接还是动态链接</li>
<li>入口地址</li>
<li>目标硬件</li>
<li>目标操作系统</li>
<li>段表：文件中各个段的位置</li>
</ul>
</li>
</ul>
</li>
<li><p>代码段（.code .text)</p>
<ul>
<li>编译后执行语句都编译成机器代码保存在.text段</li>
<li>属于指令区域，只读</li>
</ul>
</li>
<li><p>数据段 (.data)</p>
<ul>
<li>已经初始化的全局变量和局部静态变量</li>
<li>属于数据区域</li>
</ul>
</li>
<li><p>bss段</p>
<ul>
<li>未初始化的全局变量和局部静态变量</li>
<li>属于数据区域</li>
<li>仅仅记录所需大小</li>
</ul>
<p>但事实上上述只是简化版的ELF结构，真正的结构如下图</p>
</li>
</ul>
<p><img data-src="https://qiniu.dcts.top/typora/202303140236397.png" alt="Untitled"></p>
<aside>
🧐 指令和数据为什么要分开


</aside>

<ul>
<li>数据和指令会被映射到两个虚拟存储区域<ul>
<li>数据可读可写，指令区域只读</li>
<li>CPU缓存是数据缓存和指令缓存分离，有利于提高程序的局部性</li>
<li>如果同时运行多个改程序，由于指令都是一样的，内存中只需要保存一份该程序的指令副本</li>
</ul>
</li>
</ul>
<h3 id="ELF文件的文件头"><a href="#ELF文件的文件头" class="headerlink" title="ELF文件的文件头"></a>ELF文件的文件头</h3><p><img data-src="https://qiniu.dcts.top/typora/202303140236415.png" alt="Untitled"></p>
<h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>保存ELF文件中各种段的基本属性的结构。描述了各个段的段名、段长度、在文件中的偏移、读写权限等</p>
<aside>
🧐 除了之前了解到的代码段、数据段，还有很多辅助段


</aside>

<p><img data-src="https://qiniu.dcts.top/typora/202303140236431.png" alt="Untitled"></p>
<p>段表的结构是一个数组里面每个元素是一个结构体，数组的长度就是不同的段的个数。如图上图所示，这个目标文件中一共有11个段，其中第一个元素是无效的段描述符，因此一共有10个有效的段。每一个结构体长下图这样</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140236447.png" alt="Untitled"></p>
<h3 id="重定位表-rel-text"><a href="#重定位表-rel-text" class="headerlink" title="重定位表 .rel.text"></a>重定位表 .rel.text</h3><p>链接器在处理目标文件时，需要对目标文件中某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用的位置。这些重定位信息都记录在ELF文件的重定位表里面。对于每个需要重定位的代码段和数据段，都会有一个相应的重定位表</p>
<p>比如.rel.text表示对.text段的重定位表, .rel.data就是对.data段的重定位表</p>
<h3 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h3><p><code>.strtab</code> 或 <code>.shstrtab</code> 表示字符串表和段表字符串表</p>
<p>字符串表用来保存普通的字符串，比如符号的名字</p>
<p>段表字符串表用来保存段名字</p>
<h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>记录了目标文件中用到的所有符号，有符号名和符号值，符号值就是地址。</p>
<ul>
<li>定义在本目标文件中的全局符号</li>
<li>在本目标文件中引用的全局符号，但没有定义在本目标文件中（外部符号）<ul>
<li>printf</li>
</ul>
</li>
</ul>
<p>上述两个最重要，因为链接过程就是要把全局符号黏在一起，下面三个对于其他目标文件是不可见的，在链接过程中无关紧要</p>
<ul>
<li>段名</li>
<li>局部符号：局部变量的变量名<ul>
<li>对链接过程没有作用</li>
</ul>
</li>
<li>行号信息</li>
</ul>
<p>一个具体的符号表例子</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140236465.png" alt="Untitled"></p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140236478.png" alt="Untitled"></p>
<h3 id="调试表"><a href="#调试表" class="headerlink" title="调试表"></a>调试表</h3><p><img data-src="https://qiniu.dcts.top/typora/202303140236850.png" alt="Untitled"></p>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《程序员的自我修养》—— 静态链接</title>
    <url>/post/92141e30/</url>
    <content><![CDATA[<h1 id="第四章-静态链接"><a href="#第四章-静态链接" class="headerlink" title="第四章-静态链接"></a>第四章-静态链接</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个c语言程序需要经过预处理、编译、汇编、链接四个过程后才会生成可执行文件。预处理做了什么？编译做了什么？这里记得复习，汇编之后生成了目标文件。目标文件中包括文件头以及不同的段，比如代码段存放二进制代码、数据段存放初始化的变量等等很多段。为什么要有链接这一个过程呢？因为目标文件可能引用了其他目标文件中的符号，比如引用了全局变量或者函数，这些符号在目标文件中是没有准确的地址的，或者是一个假的地址，这需要链接器来确定这些符号的地址。整个链接步骤分为两步：首先是空间与地址分配，获取每个目标文件各个段的长度和位置，然后按照段合在一起，就是相似段合并，然后分配每一个段的虚拟地址。然后根据重定位表（也是目标文件中的一个段）找到重定位入口（找到哪一些符号是需要重新分配地址的），因为每一个符号在所在段中相对位置是确定的，然后现在每个段的虚拟地址也确定了，因此可以得到每个符号的虚拟地址。</p>
<p>当我们有两个目标文件，如何把他们链接起来呢？</p>
<p>整个连接步骤分为两步</p>
<ul>
<li><p>空间与地址分配</p>
<ul>
<li>获得每个目标文件各个段的长度、属性和位置</li>
<li>符号表中的所有符号定义和符号引用收集起来，统一放到一个全局符号表</li>
</ul>
</li>
<li><p>符号解析与重定位</p>
<ul>
<li>读取输入文件中段的数据、重定位信息</li>
<li>进行符号解析与重定位、调整代码中的地址</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">ld a.o b.o -e main -o ab </span><br><span class="line"><span class="comment">// -e 表示main作为程序入口 默认是_start</span></span><br><span class="line"><span class="comment">// -o 表示链接输出文件名位ab 默认是a.out</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="空间与地址分配"><a href="#空间与地址分配" class="headerlink" title="空间与地址分配"></a>空间与地址分配</h2><p>对于多个输入目标文件，链接器如何将他们的各个段合并到输出文件？</p>
<h3 id="相似段合并"><a href="#相似段合并" class="headerlink" title="相似段合并"></a>相似段合并</h3><p><img data-src="https://qiniu.dcts.top/typora/202303140242136.png" alt="Untitled"></p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140242165.png" alt="Untitled"></p>
<p>上图展示了链接前后各个段的情况</p>
<ul>
<li>链接前VMA（虚拟地址）都是0，因为虚拟空间还没有被分配，链接后都被分配了相应的虚拟地址</li>
<li>链接后各段的大小都进行了合并</li>
</ul>
<p><img data-src="https://qiniu.dcts.top/typora/202303140242182.png" alt="Untitled"></p>
<aside>
🧐


<p>在一个进程的虚拟地址空间中，ELF文件是从0x8048000这个地址开始加载的。这个地址是由ld的默认脚本指定的，可以通过命令<code>ld --verbose</code>查看¹。这个值并没有特殊意义，好像是早期386上的某个类unix系统用了这个值，就一直延续下来了¹。</p>
</aside>

<h3 id="符号地址的确定"><a href="#符号地址的确定" class="headerlink" title="符号地址的确定"></a>符号地址的确定</h3><p>在第一步的扫描和空间分配阶段，链接器完成了空间分配，这个时候各个段的虚拟地址已经确定了</p>
<p>首先，各个符号在段内的相对位置是固定的，比如a.o中的main函数相对于.text段的偏移是X，而各个段的虚拟地址也已经确定，所以main的虚拟地址就是在.text的虚拟地址+X</p>
<h2 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h2><p>对于下面两个文件，a中调用了外部的一个全局变量shared以及一个函数swap</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140242197.png" alt="Untitled"></p>
<p>对于单独的a的目标文件，编译器并不能确定shared和swap的地址究竟是什么，所以用的都是假地址，真正的地址计算工作留给了链接器</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140242210.png" alt="Untitled"></p>
<p>在第一步中已经知道了每个符号的虚拟地址，因此链接器可以根据符号的地址对每个需要重定位的指令进行地址修正，下图是修正后的结果</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140242224.png" alt="Untitled"></p>
<p>很自然的一个问题，链接器是怎么知道shared和swap这两条指令需要被调整呢？</p>
<h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>对于可重定位的ELF文件来说，必须包含有重定位表，用来描述如何修改相应的段里的内容，一个重定位表就是目标文件中的一个段，比如.rel.text段保存了代码段的重定位表，.rel.data保存了数据段的重定位表</p>
<p>下面是一个代码段的重定位表，偏移表示代码段中必须要重定位的位置。每一行都是一个重定位入口</p>
<aside>
🧐 1c就是share所在指令的位置，27就是swap所在指令的位置，这个在上上一张图中可以明确找到


</aside>

<p><img data-src="https://qiniu.dcts.top/typora/202303140242239.png" alt="Untitled"></p>
<h3 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h3><p>之所以要链接是因为我们目标文件中用到的符号被定义在其他目标文件中</p>
<p>所有未定义的符号都应该能够在全局符号表中找到，否则链接器就报符号未定义错误。</p>
<h2 id="静态库链接"><a href="#静态库链接" class="headerlink" title="静态库链接"></a>静态库链接</h2><p>一个静态库可以看做是一组目标文件的集合,比如Linux中有C语言静态库libc位于/usr/lib/libc.a</p>
<p>把零散的目标文件直接给库的使用者比较麻烦，通常使用ar压缩程序将多个目标文件压缩到一起，libc.a 就是这么形成的</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140242252.png" alt="Untitled"></p>
<p>我们可以看到libc中是包含有printf这个函数所在的目标文件的</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140242264.png" alt="Untitled"></p>
<p>那是不是我们写的helloword.c代码只要和printf.o以及printf.o中用到的目标文件，全部链接起来就可以了呢，就像下图一样？</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140242277.png" alt="Untitled"></p>
<p>而真实在链接的过程其实更加复杂，不仅仅会涉及到printf.o，甚至不仅会用到libc.a C语言库，还有其他一些辅助性质的目标文件和库, 使用-verbose会将整个编译链接过程的中间步骤打印出来</p>
<p>具体步骤如下：</p>
<ul>
<li>第一步调用cc1程序编译成汇编语言，再用as程序汇编成目标文件，最后调用collect2程序完成链接</li>
<li>collect2是ld链接器的一个包装，不仅会调用ld链接器，还会对链接结果做一些处理</li>
<li>至少有这么多库被链接了起来</li>
</ul>
<p><img data-src="https://qiniu.dcts.top/typora/202303140242287.png" alt="Untitled"></p>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础课|数学知识|博弈论</title>
    <url>/post/cb5353c6/</url>
    <content><![CDATA[<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><h2 id="（先手）必胜状态和必败状态"><a href="#（先手）必胜状态和必败状态" class="headerlink" title="（先手）必胜状态和必败状态"></a>（先手）必胜状态和必败状态</h2><ul>
<li>必胜状态：<ul>
<li>先手进行某一个操作，留给后手的是一个必败状态时，我们称先手处于一个必胜状态。即先手可以走到某一个必败状态</li>
</ul>
</li>
<li>必败状态：<ul>
<li>先手进行某一个操作，无论怎么操作，留给后手的一定是必胜状态，我们称先手处于一个必败状态。即先手走不到任意一个必败状态。</li>
</ul>
</li>
</ul>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p>有N堆石子</p>
<p>$a_1,a_2,a_3,a_4,a_5…$, 如果$a_1 \wedge a_2 \wedge a_3 \wedge a_4… \wedge a_n \not= 0$ ，则先手必胜，否则先手必败</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p><img data-src="https://qiniu.dcts.top/typora/202303140308241.png" alt="Untitled"></p>
<h2 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h2><ul>
<li>mex函数：设集合S是一个自然数集合，mex(s)表示不属于s的最小自然数<ul>
<li>mex({2,3,4,5}) = 0</li>
<li>mex({1,2,3}) = 0</li>
<li>mex({0,1,3,4}) = 2</li>
</ul>
</li>
</ul>
<p><img data-src="https://qiniu.dcts.top/typora/202303140308273.png" alt="Untitled"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sg</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> f[x] != -<span class="number">1</span>: <span class="keyword">return</span> f[x]</span><br><span class="line">    s = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">if</span> x &gt;= item:</span><br><span class="line">            s.add(sg(x - item))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">            f[x] = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> f[x]</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> lis:</span><br><span class="line">    res = res ^ sg(item)</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>七分热爱</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>算法基础课</tag>
        <tag>数学知识</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础课|数学知识|约数</title>
    <url>/post/28cc849c/</url>
    <content><![CDATA[<h1 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h1><h3 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h3><p>时间复杂度：O(sqrt(n))</p>
<p>约数也是成对出现，枚举每一对中较小的那一个，处理一下边界</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">n</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(n ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            res.append(i)</span><br><span class="line">						<span class="comment"># 9的约数是3 * 3 不能重复放进去 </span></span><br><span class="line">            <span class="keyword">if</span> i != n // i: res.append(n // i)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></tbody></table></figure>

<h3 id="约数个数-amp-约数的和"><a href="#约数个数-amp-约数的和" class="headerlink" title="约数个数 &amp; 约数的和"></a>约数个数 &amp; 约数的和</h3><aside>
🤔 INT范围内最多约数个数大概1500个
基础动作都是做分解质因数


</aside>

<p>一个数N分解质因数，其约数个数为ans</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140304243.png" alt="Untitled"></p>
<p>比如 $2^5$的约数为（$2^0,2^1,2^2,2^3,..,2^5)$一共六个</p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140304273.png" alt="Untitled"></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items():</span><br><span class="line">    res = res * (v + <span class="number">1</span>) % MODE</span><br></pre></td></tr></tbody></table></figure>

<p>计算约数的和时，可以使用 t = (t * p + 1)</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> q, a <span class="keyword">in</span> dic.items():</span><br><span class="line">        t = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a):</span><br><span class="line">            t = (t * q + <span class="number">1</span>) % MODE</span><br><span class="line">        res = res * t % MODE</span><br></pre></td></tr></tbody></table></figure>

<p><img data-src="https://qiniu.dcts.top/typora/202303140304290.jpeg" alt="Untitled"></p>
<h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><p>时间复杂度： O(logn)</p>
<p>最大公约数（GCD）可以使用欧几里得算法（辗转相除法）求得。该算法的基本思想是不断用较小的数除以较大的数，直到两个数中有一个是0为止。此时，另一个非零的数就是最大公约数。</p>
<ul>
<li>性质一：如果d能够整除a，d能够整除b，那么d可以整除 a * x + b * y</li>
<li>性质二：a和b的最大公约数(a, b)，等价于 (b, a mod b)</li>
</ul>
<p><img data-src="https://qiniu.dcts.top/typora/202303140304305.png" alt="Untitled"></p>
<p><img data-src="https://qiniu.dcts.top/typora/202303140304319.jpeg" alt="Untitled"></p>
]]></content>
      <categories>
        <category>七分热爱</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>算法基础课</tag>
        <tag>数学知识</tag>
        <tag>约数</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础课|数学知识|质数</title>
    <url>/post/8675ff1b/</url>
    <content><![CDATA[<h1 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h1><aside>
🤔 质数的定义范围是大于等于2的自然数2，3，4，5….，对于小于等于1的数，既不是质数也不是合数


</aside>

<p>质数的定义：大于1的自然数，只包含1和本身连个约束</p>
<h3 id="质数的判定——试除法"><a href="#质数的判定——试除法" class="headerlink" title="质数的判定——试除法"></a>质数的判定——试除法</h3><p>从2到n-1，遍历判断元素能否整除n，如果可以整除则说明不是质数</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span>            </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>

<p>优化：</p>
<ul>
<li><p>性质一：如果d能够整除n，则 n / d 也能整除n</p>
<p>比如：4能够整除12，则3也能够整除12， n的约数一定是成双成对的，因此可以枚举每一对中较小的数</p>
</li>
</ul>
<p><img data-src="https://qiniu.dcts.top/typora/202303140306145.png" alt="Untitled"></p>
<h3 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h3><p><code>时间复杂度：O(sqrt(n))</code></p>
<p>优化：</p>
<ul>
<li><p>性质一：n中最多只包含一个大于根号n的质因子</p>
<p>因为如果有两个，乘起来就大于n了</p>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">n</span>):</span></span><br><span class="line">	<span class="comment"># 质因子，一定是从2开始的</span></span><br><span class="line">	<span class="comment"># 不用担心合数，如果能被4整除也一定可以被2整除 </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n ** <span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n % i == <span class="number">0</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                n = n // i</span><br><span class="line">            print(i, cnt)</span><br><span class="line">		<span class="comment"># 如果n有一个大于根号n的质因子，则单独处理</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">1</span>: print(n, <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h3><p>时间复杂度：<code>O(nlogn) 更具体一点 调和级数 O(nlnn)左右</code></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">n</span>):</span></span><br><span class="line">    st = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        j = i + i</span><br><span class="line">				<span class="comment"># 如果没有被筛过，就是质数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> st[i]: cnt += <span class="number">1</span></span><br><span class="line">				<span class="comment"># 遍历这个数所有的倍数 它的倍数都不是 质数</span></span><br><span class="line">        <span class="keyword">while</span> j &lt;= n:</span><br><span class="line">            st[j] = <span class="literal">True</span></span><br><span class="line">            j += i</span><br><span class="line">    <span class="keyword">return</span> cnt</span><br></pre></td></tr></tbody></table></figure>

<p>优化：</p>
<p>不需要遍历所有数的倍数，只需要遍历质数的倍数</p>
<ul>
<li>性质一：1 - N 中有 $N/ln N$ 个质数</li>
</ul>
<p>时间复杂度：<code>O(nloglogn) 约等于O(n)</code></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 埃氏筛法</span></span><br><span class="line"><span class="comment"># O(nloglogn) 约等于O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">n</span>):</span></span><br><span class="line">    st = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        j = i + i</span><br><span class="line">				<span class="comment"># 如果这个数是质数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> st[i]: </span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= n:</span><br><span class="line">                st[j] = <span class="literal">True</span></span><br><span class="line">                j += i</span><br><span class="line">    <span class="keyword">return</span> cnt</span><br></pre></td></tr></tbody></table></figure>

<p>优化：</p>
<p>n只会被它的最小质因子筛掉，欧拉筛，线性筛</p>
]]></content>
      <categories>
        <category>七分热爱</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>算法基础课</tag>
        <tag>数学知识</tag>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title>关于约数的数小知识</title>
    <url>/post/ba82db5c/</url>
    <content><![CDATA[<h3 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h3><p>有一个小于2000的四位数，有14个约数，其中有一个质因数，个位是1</p>
<ol>
<li><p>首先要知道<a href="https://baike.baidu.com/item/%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%AE%9A%E7%90%86"><strong>约数个数定理</strong></a></p>
<p> 例题：正整数12共有多少个正约数</p>
<p> 解：将12分解质因数12=2^2×3^1</p>
<p> 由约数个数定理可知12共有正约数(2+1)×(1+1)6个。即1,12,2,6,3,4</p>
</li>
<li><p>14 个约数，按照约数个数定理，可以分为1*14 或者 2*7</p>
<ul>
<li><p>  如果是1*14个，(0+1)×(13+1)，即一个数的0次方乘以另一个数的13次方等于那个四位数，2的13次方已经大于2000，所以这种情况不可能</p>
</li>
<li><p>如果是2*7个，(1+1)×(6+1)，即一个数的1次方乘以另一个数的6次方等于那个四位数，2的6次方等于64,3的6次方等于729</p>
<ul>
<li>  另一个数，是个位为1的质因数，最小也有11吧，729*11 大于2000了，64*11等于704，64*31等于1984 所以为1984</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>三分技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>黑客与画家</title>
    <url>/post/3f152ec7/</url>
    <content><![CDATA[<h4 id="为什么书呆子不受欢迎"><a href="#为什么书呆子不受欢迎" class="headerlink" title="为什么书呆子不受欢迎"></a>为什么书呆子不受欢迎</h4><ol>
<li>在普通美国高校中,成为”强人”的标准高的吓人.青少年每时每刻都想融入群体中,都想变得更受欢迎</li>
<li>书呆子指这个人的社交技能不够强,比起更受欢迎,他们更愿意让自己聪明</li>
<li>讨厌书呆子的人其实并不恨书呆子,他们只是需要一个共同的目标;与不受欢迎的小孩保持距离,可以加分</li>
<li>大部分欺处于下一等的学生,焦虑的中间层,在一个人产生了良知之前,折磨就是一种娱乐.你把水踩下去,你的身体就会被托起来</li>
<li>除了书呆子,还有怪人(freak)</li>
</ol>
<h4 id="黑客与画家"><a href="#黑客与画家" class="headerlink" title="黑客与画家"></a>黑客与画家</h4><ol>
<li>创造优美的事物往往不是从头做起,而是在现有成果的基础上,做一些小小的调整,或者将已有的观点用比较新的方式组合起来.这种类型的工作很难用研究性的论文表达</li>
<li>黑客,并不需要知道特别多理论</li>
<li>创业公司将设计软件的任务交给一群产品经理,这对公司来说是<strong>占优之处</strong>.但编程是一个创作的过程,前期不管对错把代码堆上去,其实是在打草稿.把整个程序想清楚的时间点,<strong>应该是在编写代码的同时</strong></li>
<li>一份为了赚钱的工作(day job),一份为了爱好的工作</li>
<li><strong>学会换位思考</strong>,并不意味着自我牺牲.软件的使用方式最好能符合用户的直觉</li>
<li><strong>程序写出来是给人看的,附带能在机器上运行</strong>——《计算机程序的结构与解释》</li>
<li>一幅优秀的绘画作品必须比它应该有的样子更好;一款优秀的软件<strong>没有人看见的部分也是优美的</strong>.</li>
<li>黑客的出发点是原创,最终得到一个优美的结果;科学家的出发点是别人优美的结果,最终得到原创性</li>
<li>应该<strong>定期地从头开始</strong>,而不要长年累月地在一个项目上不断工作,并且试图把所有的最新想法都以修订版的形式包括进去</li>
</ol>
<h4 id="不能说的话"><a href="#不能说的话" class="headerlink" title="不能说的话"></a>不能说的话</h4><ol>
<li><p>所谓时尚,本质上就是自己看不见自己的样子</p>
</li>
<li><p>最令人暴跳如雷的言论,就是被认为说出了真相的言论</p>
</li>
<li><p>孩子眼里的世界是不真实的,是一个被灌输进她们头脑的假想世界</p>
</li>
<li><p>道德禁忌的最大制造者是那些有实力推行禁忌,同时有软弱到需要禁忌保护自己的利益的一方</p>
</li>
<li><p>有很多人接受流行,不是因为想要与众不同,而是因为<strong>害怕与众不同</strong></p>
</li>
<li><p>如何找到”不能说的话”?</p>
<ul>
<li><p>判断言论的真伪:那些听上去大逆不道的话,有没有可能是真的?</p>
<blockquote>
<p>早恋不会影响学习,有没有可能是真的?</p>
</blockquote>
</li>
<li><p>关注”异端邪说”:不一定正确,但极富争议的言论</p>
</li>
<li><p>回顾过去:找过去被认为理所当然,如今却认为不可思议的事情;将当代观念 古代观念 diff;</p>
</li>
<li><p>寻找一本正经的卫道者,看看他们到底在捍卫什么</p>
<blockquote>
<p>学校 老师 家长</p>
</blockquote>
</li>
<li><p>观察禁忌如何产生</p>
</li>
</ul>
</li>
<li><p>训练自己去想那些不能想的事情,获得的好处会超过所得到的思想本身</p>
</li>
<li><p>一个公司是否健康运作,可以用对负面评价的容忍程度来衡量</p>
</li>
<li><p><strong>与笨蛋辩论,你也会变成笨蛋</strong></p>
</li>
<li><p>思想和言论之间要有明确的界限,**在心里无所不想,但是不一定要说出来.**格斗俱乐部的第一条规则,就是不要提到格斗俱乐部</p>
</li>
<li><p>要对每一个人微笑,但是不要说出自己的真实想法</p>
</li>
<li><p>最好找一些信得过的知己,只与他们畅所欲言、无所不谈。这样不仅可以获得新观点，还可以用来选择朋友。能够一起谈论“异端邪说”，并且不会因此气急败坏的人，就是你最应该认识的朋友</p>
</li>
<li><p>一个人完全可以识别和抵制外界流行的带的观念，把它们与内心世界分离</p>
</li>
<li><p>如果自己就是潮水的部分，怎么能看见潮流的方向呢？你只能永远保持质疑，问自己什么话是我不能说的？为什么？</p>
</li>
</ol>
<h4 id="良好的自由"><a href="#良好的自由" class="headerlink" title="良好的自由"></a>良好的自由</h4><ol>
<li>对适当的不服从管教,保持宽容不会有太大坏处,不仅能吸引聪明人,还能吸引自负的人</li>
<li>公民自由真的是国家强富的原因,而不是结果吗?</li>
<li>“反抗政府的精神,在某些场合是如此珍贵,我希望它永远保持活跃”</li>
</ol>
<h4 id="另一条路"><a href="#另一条路" class="headerlink" title="另一条路"></a>另一条路</h4><ol>
<li><p>Viaweb的开发人员总是与客服人员保持密切联系</p>
</li>
<li><p>计划这个词,只是将构思束之高阁的另一种表达方式,只要想到好的构思,我们就立刻着手实现</p>
</li>
<li><p>《人月神话》：向一个项目增加人手，往往会拖慢项目进程</p>
</li>
<li><p>资本支出/除以服务器所能支持的最大用户数量=为每个用户付出的成本</p>
</li>
<li><p>盗版软件是的你的软件多了一个用户,市场影响力就更大了一些.(价格歧视)</p>
</li>
<li><p>大公司购买软件付出的高价中,很大一部分是商家为了让大公司买下这个商品而付出的费用</p>
</li>
<li><p>1998年的时候很多人认为再推出一个新的搜索引擎已经太晚了</p>
</li>
<li><p>桌面软件迫使用户变成系统管理员,互联网软件则迫使程序员变成系统管理员;用户的压力变小了,程序员的压力变大了.</p>
<blockquote>
<p>长时间工作变成了一种必须,因为竞争者也能做到这一点.因为你能做到,所以必须做到.</p>
</blockquote>
</li>
<li><p>管理企业只需要记住两点:</p>
<ol>
<li>做出用户喜欢的产品</li>
<li>保证开支小于收入</li>
</ol>
</li>
<li><p>要使用自己开发的产品;如果不打算自己动手设计和开发,那就不要创业</p>
</li>
</ol>
<h4 id="如何创造财富"><a href="#如何创造财富" class="headerlink" title="如何创造财富"></a>如何创造财富</h4><ol>
<li><p>创业公司其实就是解决了某个技术难题的小公司</p>
</li>
<li><p>创业你不再是低强度工作四十年,而是以极限强度工作四年</p>
<blockquote>
<p>作者是一点都没有否认创业辛苦呀,也没有否认程序员的工作时间之长</p>
</blockquote>
</li>
<li><p>财富才是你的目标,金钱不是</p>
</li>
<li><p>大多数生意的目的是为了创造财富,做出人们真正需要的东西</p>
</li>
<li><p>要去思考那些着眼于你自己感兴趣的东西的商业计划,而不仅仅只是自己感兴趣的东西</p>
</li>
<li><p>金钱不是财富,而只是我们用来转移财富所有权的东西</p>
</li>
<li><p>人们需要的东西就是财富</p>
</li>
<li><p>公司存在的目的,就是满足人们的某种需要</p>
</li>
<li><p>你需要去做一些人们需要的东西</p>
</li>
<li><p>真正重要的是做出人们需要的东西,而不是加入某个公司</p>
</li>
<li><p>工作就是一个组织中,与许多人共同合作,做出某种人们需要的东西</p>
</li>
<li><p>如果一家公司真正能够按照贡献付薪,它将取得巨大成功</p>
</li>
<li><p>在大公司中,个人的表现无法单独测量,公司里其他人会拖累你</p>
</li>
<li><p>致富需要的东西</p>
<ol>
<li><p><strong>可测量性</strong>: 你的职位产生的业绩,应该是可测量的(来自小团队的合作)</p>
<blockquote>
<p>大学生活也一样,有一个小团队,会比一个人或者一班级为集体生活得更加愉快.</p>
</blockquote>
</li>
<li><p><strong>可放大性</strong>: 做出的决定能够产生巨大的效应,是否存在可放大性,可以看失败的可能性.(来自开发新技术)</p>
</li>
</ol>
</li>
<li><p>巨大的获利可能,必定存在巨大的失败可能.如果有一个令你感到安全的工作,你是不会致富的.没有危险,就没有可放大性</p>
</li>
<li><p>公司越小,就越能准确估计每个人的贡献</p>
</li>
<li><p>找出色的人合作,因为他们的工作和你的一起平均计算.</p>
</li>
<li><p>创业成败取决于最早加入公司的那十个人——乔布斯</p>
</li>
<li><p>我们不需要小村庄的那种小,而需要全明星第一阵容的那种小</p>
</li>
<li><p>“一次开发,普遍使用”</p>
</li>
<li><p>“进入壁垒”(barriers to entry),即开发出来的技术要是竞争对手难于复制的.</p>
</li>
<li><p><strong>如果有两个选择,就选择比较难的那个</strong></p>
</li>
<li><p>促成买房掏钱的最好办法不是让买家看到有获利的可能,而是让他们感到收取机会的恐惧</p>
</li>
<li><p>用户数量是很重要的因素</p>
</li>
<li><p>懂的藏富于民,国家就会变得强大</p>
</li>
</ol>
<h4 id="关注贫富分化"><a href="#关注贫富分化" class="headerlink" title="关注贫富分化"></a>关注贫富分化</h4><ol>
<li>现在由于技术的发展,富人的生活与普通人的差距缩小了</li>
<li>技术在加大收入差距的同时,缩小了大部分其他差距</li>
<li>收入差距是因为,每个人创造财富的能力是不一样的,每个人技能不同,导致收入不同,这才是贫富分化的主要原因</li>
<li>如果想创造大量财富且不扩大收入差距,只能让创造大量财富的人不获取报酬</li>
</ol>
<h4 id="设计者的品味"><a href="#设计者的品味" class="headerlink" title="设计者的品味"></a>设计者的品味</h4><ol>
<li><p>品味有好坏之分</p>
</li>
<li><p>如果解决方法是丑陋的,那就肯定有更好的解决方法,只是还没有发现而已</p>
</li>
<li><p>世界上有有益的痛,也有无益的痛苦</p>
</li>
<li><p><strong>把事情做对比原创更加重要</strong></p>
<blockquote>
<p>等你逐渐对一件事情产生热情的时候,就不会满足于模仿了.你的品位就进入了第二阶段,开始自觉地进行原创</p>
<p>足够自信地使用他人的成果,完全不用担心因此丧失个人的特点</p>
</blockquote>
</li>
<li><p>风格是自然而然形成的,追求做出好的作品,完成之后再回过头看</p>
</li>
<li><p>优秀作品的秘诀:非常严格的品味,再加上实现这种品味的能力</p>
</li>
</ol>
]]></content>
      <categories>
        <category>十分人生</category>
      </categories>
      <tags>
        <tag>摘抄</tag>
      </tags>
  </entry>
</search>
